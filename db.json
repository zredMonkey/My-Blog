{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/butterfly/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/bg-cover.jpeg","path":"img/bg-cover.jpeg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-1.png","path":"img/java-stream-1.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/githubImage.jpg","path":"img/githubImage.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-2.png","path":"img/java-stream-2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-3.png","path":"img/java-stream-3.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-4.png","path":"img/java-stream-4.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-6.png","path":"img/java-stream-6.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-5.png","path":"img/java-stream-5.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java_stream.jpg","path":"img/java_stream.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/monkeyHand.jpg","path":"img/monkeyHand.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/suanfa.png","path":"img/suanfa.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain1.png","path":"img/mysql_explain1.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain2.png","path":"img/mysql_explain2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain3.png","path":"img/mysql_explain3.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain4.png","path":"img/mysql_explain4.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain5.png","path":"img/mysql_explain5.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain6.png","path":"img/mysql_explain6.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain7.png","path":"img/mysql_explain7.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain8.png","path":"img/mysql_explain8.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain10.png","path":"img/mysql_explain10.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain9.png","path":"img/mysql_explain9.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain12.png","path":"img/mysql_explain12.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain11.png","path":"img/mysql_explain11.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain13.png","path":"img/mysql_explain13.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain14.png","path":"img/mysql_explain14.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain15.png","path":"img/mysql_explain15.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain16.png","path":"img/mysql_explain16.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain17.png","path":"img/mysql_explain17.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain19.png","path":"img/mysql_explain19.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain18.png","path":"img/mysql_explain18.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain20.png","path":"img/mysql_explain20.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain23.png","path":"img/mysql_explain23.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain21.png","path":"img/mysql_explain21.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain22.png","path":"img/mysql_explain22.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain25.png","path":"img/mysql_explain25.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain26.png","path":"img/mysql_explain26.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain24.png","path":"img/mysql_explain24.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain27.png","path":"img/mysql_explain27.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain28.png","path":"img/mysql_explain28.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain29.png","path":"img/mysql_explain29.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain30.png","path":"img/mysql_explain30.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain33.png","path":"img/mysql_explain33.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain31.png","path":"img/mysql_explain31.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain32.png","path":"img/mysql_explain32.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain34.png","path":"img/mysql_explain34.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain35.png","path":"img/mysql_explain35.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain36.png","path":"img/mysql_explain36.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain37.png","path":"img/mysql_explain37.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain39.png","path":"img/mysql_explain39.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain38.png","path":"img/mysql_explain38.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain41.png","path":"img/mysql_explain41.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain40.png","path":"img/mysql_explain40.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain42.png","path":"img/mysql_explain42.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain44.png","path":"img/mysql_explain44.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/mysql_explain43.png","path":"img/mysql_explain43.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/oom-1.png","path":"img/oom-1.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/slow-sql.jpg","path":"img/slow-sql.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/oom.png","path":"img/oom.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/techbeat.png","path":"img/techbeat.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/leetcode.png","path":"img/leetcode.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"c084e1513e2b2462e1620baa17f9684068555a49","modified":1693594410911},{"_id":"source/_posts/Explain详解与索引最佳实践.md","hash":"05bb93614b96422f4494ab6834841e15fbd095fa","modified":1693673434840},{"_id":"source/_posts/OOM-内存溢出问题排查.md","hash":"205ede64439a7b3a41d0fa798dfb8005e9e5f57e","modified":1693671652095},{"_id":"source/categories/index.md","hash":"18a5dc5b164c5ecedf3fc3fee35e6611a8860044","modified":1693566710275},{"_id":"source/link/index.md","hash":"77d6585cce9e319b6c4de9561d129568b9f281f3","modified":1693566741262},{"_id":"source/_data/link.yml","hash":"cd6188fbcc1bd9c91e8a0b5d23b59affb1c79ef7","modified":1694009406012},{"_id":"source/_posts/将本地代码提交至github仓库.md","hash":"309cb2f1637000951ca1a59e281f2aaf5da97c28","modified":1693673560726},{"_id":"source/tags/index.md","hash":"60231d8c5df2a77e9f4ae14c8f5b33a9cbefa3f6","modified":1693566625134},{"_id":"source/_posts/JAVA之用Stream流将List转化为Map.md","hash":"e68016e24074c96616f2e1d5907b324b4a1fc6b9","modified":1693673560736},{"_id":"source/_data/valine.json","hash":"a46b37da1ee0ad67a4623c4ce59ae95d13afe86e","modified":1693594043381},{"_id":"source/_posts/Algorithm.md","hash":"a02a89934c0e1f59b1f2c8e58aa796c5816c1d1e","modified":1693673560736},{"_id":"themes/butterfly/_config.yml","hash":"36f26f9d88ff80c10d6eec8817df1e2ee2a87ab5","modified":1693593776271},{"_id":"themes/butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1693501706500},{"_id":"themes/butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1693501706500},{"_id":"themes/butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1693501706457},{"_id":"themes/butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1693501706457},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1693501706458},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1693501706458},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1693501706459},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1693501706459},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1693501706499},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1693501706499},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1693501706500},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1693501706499},{"_id":"themes/butterfly/source/CNAME","hash":"c084e1513e2b2462e1620baa17f9684068555a49","modified":1693595178068},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1693501706455},{"_id":"themes/butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1693501706456},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1693501706454},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1693501706454},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1693501706455},{"_id":"themes/butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1693501706456},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1693501706459},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1693501706461},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1693501706461},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"b50b0afdc41c54279587410c3f82c8cb3c5ff46d","modified":1693501706461},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1693501706467},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1693501706471},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1693501706473},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1693501706473},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1693501706501},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1693501706502},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1693501706501},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1693501706502},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"92683cb785a29e5a73701b33dba73d3afac268c3","modified":1693501706454},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1693501706502},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1693501706504},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1693501706505},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1693501706503},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1693501706506},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1693501706505},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1693501706506},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1693501706507},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1693501706455},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1693501706504},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1693501706504},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1693501706507},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1693501706508},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1693501706508},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1693501706508},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1693501706509},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1693501706509},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1693501706511},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1693501706529},{"_id":"themes/butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1693501706532},{"_id":"themes/butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1693501706529},{"_id":"themes/butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1693501706533},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1693501706532},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1693501706530},{"_id":"themes/butterfly/source/_data/valine.json","hash":"a46b37da1ee0ad67a4623c4ce59ae95d13afe86e","modified":1693594048693},{"_id":"themes/butterfly/source/img/githubImage.jpg","hash":"762bc8312e83001222bdf28b4ca8b5c24de11745","modified":1693585801951},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1693501706530},{"_id":"themes/butterfly/source/img/java-stream-2.png","hash":"88b15cd36c8281e94f9cedbed1bb40e431155b16","modified":1693587586028},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1693501706531},{"_id":"themes/butterfly/source/img/java-stream-1.png","hash":"be068ed1d654e82010aac3bebae03ff38055b59a","modified":1693587268141},{"_id":"themes/butterfly/source/img/java-stream-3.png","hash":"1a2fce5a6b7e57c454464035c3c6a38296fedf9b","modified":1693587634336},{"_id":"themes/butterfly/source/img/java_stream.jpg","hash":"efafa2831e18bcc735df78003545507dc153dfd5","modified":1693587037612},{"_id":"themes/butterfly/source/img/java-stream-4.png","hash":"0cacfb4e34cbd5c017510a03a06605cad6d6715b","modified":1693587680951},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1693501706462},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1693501706462},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1693501706462},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1693501706463},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1693501706463},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1693501706463},{"_id":"themes/butterfly/source/img/java-stream-6.png","hash":"bcd658567df4d1ac34435c8949d1162bd350b568","modified":1693587753639},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1693501706463},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1693501706464},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1693501706465},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1693501706465},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1693501706466},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1693501706465},{"_id":"themes/butterfly/source/img/java-stream-5.png","hash":"93476ef6eae523c7717f9ba8e57625c5602f2345","modified":1693587717842},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1693501706466},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1693501706466},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1693501706468},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1693501706468},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1693501706468},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1693501706469},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1693501706469},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1693501706471},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1693501706471},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1693501706485},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1693501706474},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1693501706489},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1693501706490},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1693501706490},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1693501706494},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1693501706496},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1693501706496},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1693501706496},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1693501706497},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1693501706497},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1693501706497},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1693501706498},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1693501706498},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1693501706499},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1693501706513},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1693501706514},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1693501706512},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1693501706512},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1693501706515},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1693501706515},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1693501706516},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1693501706516},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1693501706516},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1693501706517},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1693501706517},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1693501706519},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1693501706519},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1693501706524},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1693501706525},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1693501706520},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1693501706521},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1693501706525},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1693501706526},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1693501706526},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1693501706526},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1693501706527},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1693501706527},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1693501706527},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1693501706528},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1693501706528},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1693501706521},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1693501706522},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1693501706521},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1693501706522},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1693501706522},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1693501706523},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1693501706523},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1693501706528},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1693501706532},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1693501706474},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1693501706524},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1693501706474},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1693501706475},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1693501706475},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1693501706475},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1693501706476},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1693501706476},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1693501706476},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1693501706477},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1693501706477},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1693501706480},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1693501706480},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1693501706481},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1693501706481},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1693501706482},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1693501706532},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1693501706482},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1693501706482},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1693501706483},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1693501706483},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1693501706483},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1693501706484},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1693501706484},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1693501706484},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1693501706485},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1693501706478},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1693501706478},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1693501706478},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1693501706479},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1693501706479},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1693501706479},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1693501706487},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1693501706487},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1693501706489},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1693501706489},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1693501706491},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1693501706491},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1693501706491},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1693501706492},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1693501706492},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1693501706492},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1693501706494},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1693501706494},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1693501706513},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1693501706513},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1693501706514},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1693501706514},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1693501706514},{"_id":"themes/butterfly/source/img/monkeyHand.jpg","hash":"ac095c9dbbdd9730534040696204e44f1bde995b","modified":1693503160780},{"_id":"themes/butterfly/source/img/suanfa.png","hash":"90b516298ec51879146f807686aa55870c5b0519","modified":1693568587569},{"_id":"themes/butterfly/source/img/wechat.jpg","hash":"490cf3bfb19c8f7d019943b1910efdb03f6ad00b","modified":1693569915508},{"_id":"themes/butterfly/source/img/bg.jpg","hash":"f22a82dbb773cc14ffc52113729f78fc3e21bc6a","modified":1693502010883},{"_id":"themes/butterfly/source/img/bg-cover.jpeg","hash":"af30216fc80a250f79550b0968a9891f3a2518a6","modified":1693503735685},{"_id":"public/search.xml","hash":"19df9b2d6948fc2966c1d76e89c080be90551f42","modified":1693673557556},{"_id":"public/categories/index.html","hash":"0ef79095bf412bca5cebccc88d316c7142ae4121","modified":1694009465820},{"_id":"public/tags/index.html","hash":"7787b6b394430072f62bd998805dd63029b81647","modified":1694009465820},{"_id":"public/link/index.html","hash":"c4061df8b27682cff50e8db3d99093c4f9e5de13","modified":1694009465820},{"_id":"public/Algorithm/index.html","hash":"c0b2bef7970a8ca95f1d5a735b088d2a9ba82a15","modified":1693673751287},{"_id":"public/Explain详解与索引最佳实践/index.html","hash":"40ff9574145ce01d273ecc593670fc3dd8bcaa2a","modified":1693673557556},{"_id":"public/OOM-内存溢出问题排查/index.html","hash":"af41227f3e203f23edcfbbcc2e31fa05d1cd0223","modified":1693673557556},{"_id":"public/将本地代码提交至github仓库/index.html","hash":"0d2c08643d4ddc6759d392650bd8d601eb48830e","modified":1693673751287},{"_id":"public/JAVA之用Stream流将List转化为Map/index.html","hash":"e48350cc38000c913b07f4dddd5c72bd00485d5b","modified":1693673751287},{"_id":"public/archives/index.html","hash":"d6beefc17fb47d5b6944a582a00f2c41c9e2e7f7","modified":1694009465820},{"_id":"public/archives/2018/index.html","hash":"302ad7cf27eab0d1a626bb814fd08b55284abc27","modified":1694009465820},{"_id":"public/archives/2018/01/index.html","hash":"1a221ae5cec329a868f6aa4e86468313f43d4010","modified":1694009465820},{"_id":"public/archives/2019/02/index.html","hash":"372274ba88501af1db1c921034076021550e3f8d","modified":1694009465820},{"_id":"public/archives/2019/index.html","hash":"93b6885a0268ac9af577e7736a5e517bd3110ad9","modified":1694009465820},{"_id":"public/archives/2020/index.html","hash":"2fa71781f84fd4800da16b7729972b6fa7077b57","modified":1694009465820},{"_id":"public/archives/2020/05/index.html","hash":"a7e12feb6c98c92b3981767d8cf297e4ef001233","modified":1694009465820},{"_id":"public/archives/2020/08/index.html","hash":"85817ce87d7104d4a28d4973b4c192f69acabde5","modified":1694009465820},{"_id":"public/archives/2023/index.html","hash":"9a1f3af9383e5b5826983afc866043c71fbd982e","modified":1694009465820},{"_id":"public/tags/github仓库/index.html","hash":"2e8e3ea383875d89d0e969d97fcc23d9121535bd","modified":1694009465820},{"_id":"public/archives/2023/08/index.html","hash":"d7f4b5f64840895ad266da815fe5cd4340277981","modified":1694009465820},{"_id":"public/tags/github/index.html","hash":"76939f250d02bb8bcf419ea493426e27bdb5d9de","modified":1694009465820},{"_id":"public/tags/git/index.html","hash":"5ee26d13aadd886e50f97eb8ea0638936ec46412","modified":1694009465820},{"_id":"public/tags/本地代码/index.html","hash":"7f892b57d8af5339b3fc4dff8a81b927629a7cab","modified":1694009465820},{"_id":"public/tags/Stream流/index.html","hash":"893f8a1abd0e02db5200d48daf66bf0fdcfb2bce","modified":1694009465820},{"_id":"public/tags/JDK-1-8/index.html","hash":"e84f27dadd1484dc4b909d4085d73eaadca6d229","modified":1694009465820},{"_id":"public/tags/OOM/index.html","hash":"03257379178db4d9caf29298db7b389eb088ee15","modified":1694009465820},{"_id":"public/tags/List转化为Map/index.html","hash":"c8e3253dedb7a1c8c798d1858758c817aa326148","modified":1694009465820},{"_id":"public/tags/内存溢出/index.html","hash":"9e9defcc42f7756337f6afb288e8e04a657d3ddb","modified":1694009465820},{"_id":"public/tags/Explain执行计划/index.html","hash":"230d1337b93f86783fb1baba86909307f5b42a8a","modified":1694009465820},{"_id":"public/tags/索引/index.html","hash":"a1e97857907f463d5210ad5b3611321e94326f9b","modified":1694009465820},{"_id":"public/tags/mysql优化实践/index.html","hash":"b43a1c969cea5af57294de4ef731e814c5e26bea","modified":1694009465820},{"_id":"public/tags/B-树索引/index.html","hash":"aa450751909d92b2468f9a3ac20dd1071394fe0c","modified":1694009465820},{"_id":"public/tags/SQL慢查询优化/index.html","hash":"bdc10b74bf0f0c48f88237726eefbf8ee59af797","modified":1694009465820},{"_id":"public/tags/算法/index.html","hash":"639c826254792b6bf4e98188a00846f9520ca774","modified":1694009465820},{"_id":"public/tags/动态规划/index.html","hash":"9936856be17895fefd36ee32d23ef20c13ee52ac","modified":1694009465820},{"_id":"public/tags/贪心算法/index.html","hash":"5ae4aae1e060f853fc9abe8dcc9449bdb3a23090","modified":1694009465820},{"_id":"public/tags/回溯算法/index.html","hash":"30ae76921543bb0d1ef056288ce4e33bf07b1382","modified":1694009465820},{"_id":"public/index.html","hash":"d4cdbb8ab2051575c273e32003e8bc94099123de","modified":1694009465820},{"_id":"public/categories/github仓库/index.html","hash":"35565060389c0627ad99487e39c79c9a6b74d7a3","modified":1694009465820},{"_id":"public/categories/Stream流/index.html","hash":"2c8a7738df42039ac9228dbd9efc1d76cd185756","modified":1694009465820},{"_id":"public/categories/github仓库/github/index.html","hash":"4f739f3bfbe2594bf3457429a6f49ca8120e8748","modified":1694009465820},{"_id":"public/categories/Stream流/List转化为Map/index.html","hash":"3d3c2c34621147945cefb24704f6491de311b92f","modified":1694009465820},{"_id":"public/categories/OOM/index.html","hash":"ae0734efd5bbc87ed15651132c96dced6e84e9d9","modified":1694009465820},{"_id":"public/categories/Explain执行计划/index.html","hash":"336f77c4a3a3482d00cdffaf0b8e143afc2b330a","modified":1694009465820},{"_id":"public/categories/OOM/内存溢出/index.html","hash":"31d0feafcdba51a78a96b006367f46639edebf1b","modified":1694009465820},{"_id":"public/categories/Explain执行计划/索引/index.html","hash":"603e461999a91d1b27ab20c9a85be72be77bbf49","modified":1694009465820},{"_id":"public/categories/Explain执行计划/索引/SQL慢查询优化/index.html","hash":"136a1b5a96da8ec68288f77fc7a22d2185c0528a","modified":1694009465820},{"_id":"public/categories/算法/index.html","hash":"0d83f47603ce2ba4efae9eaff21539772a22b0f0","modified":1694009465820},{"_id":"public/categories/算法/动态规划/index.html","hash":"82964513d27a6bab5cd69d66de15a135698c024c","modified":1694009465820},{"_id":"public/categories/算法/动态规划/回溯算法/index.html","hash":"dfb1fd07425432c0dbe856edfa943821ffecd7d5","modified":1694009465820},{"_id":"public/CNAME","hash":"c084e1513e2b2462e1620baa17f9684068555a49","modified":1693673557556},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1693673557556},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1693673557556},{"_id":"public/img/java-stream-1.png","hash":"be068ed1d654e82010aac3bebae03ff38055b59a","modified":1693673557556},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1693673557556},{"_id":"public/img/githubImage.jpg","hash":"762bc8312e83001222bdf28b4ca8b5c24de11745","modified":1693673557556},{"_id":"public/img/java-stream-4.png","hash":"0cacfb4e34cbd5c017510a03a06605cad6d6715b","modified":1693673557556},{"_id":"public/img/java-stream-3.png","hash":"1a2fce5a6b7e57c454464035c3c6a38296fedf9b","modified":1693673557556},{"_id":"public/img/java-stream-6.png","hash":"bcd658567df4d1ac34435c8949d1162bd350b568","modified":1693673557556},{"_id":"public/img/java-stream-2.png","hash":"88b15cd36c8281e94f9cedbed1bb40e431155b16","modified":1693673557556},{"_id":"public/img/java-stream-5.png","hash":"93476ef6eae523c7717f9ba8e57625c5602f2345","modified":1693673557556},{"_id":"public/img/java_stream.jpg","hash":"efafa2831e18bcc735df78003545507dc153dfd5","modified":1693673557556},{"_id":"public/img/suanfa.png","hash":"90b516298ec51879146f807686aa55870c5b0519","modified":1693673557556},{"_id":"public/img/monkeyHand.jpg","hash":"ac095c9dbbdd9730534040696204e44f1bde995b","modified":1693673557556},{"_id":"public/img/wechat.jpg","hash":"490cf3bfb19c8f7d019943b1910efdb03f6ad00b","modified":1693673557556},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1693673557556},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1693673557556},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1693673557556},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1693673557556},{"_id":"public/css/index.css","hash":"d0ae3b76e56e8b518f3b97fb24656fd845de38c5","modified":1693673557556},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1693673557556},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1693673557556},{"_id":"public/img/bg.jpg","hash":"f22a82dbb773cc14ffc52113729f78fc3e21bc6a","modified":1693673557556},{"_id":"public/img/bg-cover.jpeg","hash":"af30216fc80a250f79550b0968a9891f3a2518a6","modified":1693673557556},{"_id":"themes/butterfly/source/img/mysql_explain1.png","hash":"4ed05f7974fe5348223b9037c40cc068e8ca014c","modified":1692636789429},{"_id":"themes/butterfly/source/img/mysql_explain10.png","hash":"41a7218c910030fc20fb30f6ccdb24643ff33c87","modified":1692636789430},{"_id":"themes/butterfly/source/img/mysql_explain11.png","hash":"c1bc6fadca35490b51bee07934b10b2f1f3846b4","modified":1692636789430},{"_id":"themes/butterfly/source/img/mysql_explain12.png","hash":"eb7d5cf2b5c94719858298baaf631b331786d2e3","modified":1692636789431},{"_id":"themes/butterfly/source/img/mysql_explain13.png","hash":"81477fcc9c28241c1d705879573035f98976459b","modified":1692636789431},{"_id":"themes/butterfly/source/img/mysql_explain14.png","hash":"86c0a14383d697f8f11eda40ae18f44b3260fe9d","modified":1692636789432},{"_id":"themes/butterfly/source/img/mysql_explain15.png","hash":"cd394849f71dd16dc2def6c3823995c806f54d25","modified":1692636789432},{"_id":"themes/butterfly/source/img/mysql_explain16.png","hash":"0075293238d0239197d17c73096f56c8f954610d","modified":1692636789433},{"_id":"themes/butterfly/source/img/mysql_explain17.png","hash":"a46ead917adde8616fc9bf74c43d44efe6a580bb","modified":1692636789434},{"_id":"themes/butterfly/source/img/mysql_explain18.png","hash":"7b22066c8b72af572abf8fbe09b6c820890b0f3b","modified":1692636789434},{"_id":"themes/butterfly/source/img/mysql_explain19.png","hash":"5c622868efccd74a9b48a01329ac90802546c985","modified":1692636789435},{"_id":"themes/butterfly/source/img/mysql_explain2.png","hash":"1d6b9576400bbfbec880fee3be5e1bdf1a899877","modified":1692636789435},{"_id":"themes/butterfly/source/img/mysql_explain20.png","hash":"1282e1ab340ecedff93b9a303e9899d64d4607e5","modified":1692636789436},{"_id":"themes/butterfly/source/img/mysql_explain21.png","hash":"85835dba8dd2a856feba4ce6b27bc7e524404069","modified":1692636789436},{"_id":"themes/butterfly/source/img/mysql_explain22.png","hash":"a0a85ba57dd0dd9030604d0d87bcdb6c4519a9b8","modified":1692636789436},{"_id":"themes/butterfly/source/img/mysql_explain23.png","hash":"ac6c9187dc77b7325af427c6580b0f86f4506f64","modified":1692636789437},{"_id":"themes/butterfly/source/img/mysql_explain24.png","hash":"3ae1a192ef67476b0479a3564e7653c27b4675e2","modified":1692636789438},{"_id":"themes/butterfly/source/img/mysql_explain25.png","hash":"640c5cd5ee02380fa24d190a28a75ce2ec79eb64","modified":1692636789438},{"_id":"themes/butterfly/source/img/mysql_explain26.png","hash":"7b121e6c8abc973e2ff94c84ef4a9f4f1968c8af","modified":1692636789439},{"_id":"themes/butterfly/source/img/mysql_explain27.png","hash":"f8c98edc19ead414e1ffb0f1ea184457f1b7396b","modified":1692636789439},{"_id":"themes/butterfly/source/img/mysql_explain28.png","hash":"168c5c76f3b8027ff52c4a7f43957264a887edba","modified":1692636789440},{"_id":"themes/butterfly/source/img/mysql_explain3.png","hash":"068d4c303ee0ca10cb024ac117cb819969ef47ba","modified":1692636789440},{"_id":"themes/butterfly/source/img/mysql_explain29.png","hash":"bff7e422ae34532578179b5d588bf12ea84d9f0f","modified":1692636789440},{"_id":"themes/butterfly/source/img/mysql_explain30.png","hash":"f254911d8568cf12f69141d5ce6ec9f390baa266","modified":1692636789441},{"_id":"themes/butterfly/source/img/mysql_explain31.png","hash":"d2d529bf61248f6d79ec2a7c6bfe00c4123451fd","modified":1692636789441},{"_id":"themes/butterfly/source/img/mysql_explain32.png","hash":"a060742362dddbd355d9755301279f6f68953a4d","modified":1692636789442},{"_id":"themes/butterfly/source/img/mysql_explain33.png","hash":"92803812f2b8124f4d3089955d60f42d73c2bcc4","modified":1692636789442},{"_id":"themes/butterfly/source/img/mysql_explain34.png","hash":"a2c2da54e0bf5a03f3921522dd7f6a6d182d089f","modified":1692636789443},{"_id":"themes/butterfly/source/img/mysql_explain35.png","hash":"ae092c639b783fd819f7734bb863d2cd84806fbd","modified":1692636789443},{"_id":"themes/butterfly/source/img/mysql_explain36.png","hash":"ac44570bf18ee64b74393ba8cd4423208d98fe2e","modified":1692636789444},{"_id":"themes/butterfly/source/img/mysql_explain38.png","hash":"a0153907db5652e1fb96ead54ee112592eebfe30","modified":1692636789444},{"_id":"themes/butterfly/source/img/mysql_explain37.png","hash":"daab581181684e6b25f49de849a7ac2359b55acf","modified":1692636789444},{"_id":"themes/butterfly/source/img/mysql_explain4.png","hash":"dd884b8cf5733fe367f94290841576c5b2166298","modified":1692636789446},{"_id":"themes/butterfly/source/img/mysql_explain39.png","hash":"00414ed7b4835e51836819885dcf759ed094267f","modified":1692636789446},{"_id":"themes/butterfly/source/img/mysql_explain40.png","hash":"6c6de934247fb908cc214a804c69fe35d01558b6","modified":1692636789447},{"_id":"themes/butterfly/source/img/mysql_explain41.png","hash":"686058f1a6c816ca8b5d1f7f2abec0b083cdc387","modified":1692636789447},{"_id":"themes/butterfly/source/img/mysql_explain42.png","hash":"7fb6a4a3aa283b4cd35b8a98591eb61dd8947f2e","modified":1692636789448},{"_id":"themes/butterfly/source/img/mysql_explain43.png","hash":"e29f7a02dcd352da05e7fd3394f5675a76eb7e01","modified":1692636789448},{"_id":"themes/butterfly/source/img/mysql_explain6.png","hash":"53ce2c80e9a990b0f9a849f6c1dff0e018d3da65","modified":1692636789450},{"_id":"themes/butterfly/source/img/mysql_explain5.png","hash":"f81aba718cb80c4934ccabdb185ba4975b57fb1e","modified":1692636789449},{"_id":"themes/butterfly/source/img/mysql_explain7.png","hash":"b915c17db6d9f57b3f1c426d124ddb63fd03c6f3","modified":1692636789450},{"_id":"themes/butterfly/source/img/mysql_explain8.png","hash":"3c35e6986bdf23577e293a0fbe80366d189f87de","modified":1692636789451},{"_id":"themes/butterfly/source/img/mysql_explain9.png","hash":"ba3cb1e89eaca659e9d5c6b5b0c45deb21628857","modified":1692636789451},{"_id":"themes/butterfly/source/img/oom-1.png","hash":"d1f1685f3112759961ce23c7d2b9decd73b39dea","modified":1693671604718},{"_id":"themes/butterfly/source/img/slow-sql.jpg","hash":"29cfb7c71f78e6d3c2c75d8161ecb193f63ca187","modified":1693672245809},{"_id":"themes/butterfly/source/img/mysql_explain44.png","hash":"b07d279015d7e07562a53d6ef93ad5cc064782fa","modified":1692636789449},{"_id":"public/img/mysql_explain1.png","hash":"4ed05f7974fe5348223b9037c40cc068e8ca014c","modified":1693673751287},{"_id":"public/img/mysql_explain2.png","hash":"1d6b9576400bbfbec880fee3be5e1bdf1a899877","modified":1693673751287},{"_id":"public/img/mysql_explain3.png","hash":"068d4c303ee0ca10cb024ac117cb819969ef47ba","modified":1693673751287},{"_id":"public/img/mysql_explain4.png","hash":"dd884b8cf5733fe367f94290841576c5b2166298","modified":1693673751287},{"_id":"public/img/mysql_explain10.png","hash":"41a7218c910030fc20fb30f6ccdb24643ff33c87","modified":1693673751287},{"_id":"public/img/mysql_explain9.png","hash":"ba3cb1e89eaca659e9d5c6b5b0c45deb21628857","modified":1693673751287},{"_id":"public/img/mysql_explain6.png","hash":"53ce2c80e9a990b0f9a849f6c1dff0e018d3da65","modified":1693673751287},{"_id":"public/img/mysql_explain12.png","hash":"eb7d5cf2b5c94719858298baaf631b331786d2e3","modified":1693673751287},{"_id":"public/img/mysql_explain11.png","hash":"c1bc6fadca35490b51bee07934b10b2f1f3846b4","modified":1693673751287},{"_id":"public/img/mysql_explain13.png","hash":"81477fcc9c28241c1d705879573035f98976459b","modified":1693673751287},{"_id":"public/img/mysql_explain14.png","hash":"86c0a14383d697f8f11eda40ae18f44b3260fe9d","modified":1693673751287},{"_id":"public/img/mysql_explain15.png","hash":"cd394849f71dd16dc2def6c3823995c806f54d25","modified":1693673751287},{"_id":"public/img/mysql_explain16.png","hash":"0075293238d0239197d17c73096f56c8f954610d","modified":1693673751287},{"_id":"public/img/mysql_explain17.png","hash":"a46ead917adde8616fc9bf74c43d44efe6a580bb","modified":1693673751287},{"_id":"public/img/mysql_explain19.png","hash":"5c622868efccd74a9b48a01329ac90802546c985","modified":1693673751287},{"_id":"public/img/mysql_explain18.png","hash":"7b22066c8b72af572abf8fbe09b6c820890b0f3b","modified":1693673751287},{"_id":"public/img/mysql_explain20.png","hash":"1282e1ab340ecedff93b9a303e9899d64d4607e5","modified":1693673751287},{"_id":"public/img/mysql_explain23.png","hash":"ac6c9187dc77b7325af427c6580b0f86f4506f64","modified":1693673751287},{"_id":"public/img/mysql_explain21.png","hash":"85835dba8dd2a856feba4ce6b27bc7e524404069","modified":1693673751287},{"_id":"public/img/mysql_explain22.png","hash":"a0a85ba57dd0dd9030604d0d87bcdb6c4519a9b8","modified":1693673751287},{"_id":"public/img/mysql_explain25.png","hash":"640c5cd5ee02380fa24d190a28a75ce2ec79eb64","modified":1693673751287},{"_id":"public/img/mysql_explain26.png","hash":"7b121e6c8abc973e2ff94c84ef4a9f4f1968c8af","modified":1693673751287},{"_id":"public/img/mysql_explain24.png","hash":"3ae1a192ef67476b0479a3564e7653c27b4675e2","modified":1693673751287},{"_id":"public/img/mysql_explain27.png","hash":"f8c98edc19ead414e1ffb0f1ea184457f1b7396b","modified":1693673751287},{"_id":"public/img/mysql_explain29.png","hash":"bff7e422ae34532578179b5d588bf12ea84d9f0f","modified":1693673751287},{"_id":"public/img/mysql_explain28.png","hash":"168c5c76f3b8027ff52c4a7f43957264a887edba","modified":1693673751287},{"_id":"public/img/mysql_explain30.png","hash":"f254911d8568cf12f69141d5ce6ec9f390baa266","modified":1693673751287},{"_id":"public/img/mysql_explain33.png","hash":"92803812f2b8124f4d3089955d60f42d73c2bcc4","modified":1693673751287},{"_id":"public/img/mysql_explain31.png","hash":"d2d529bf61248f6d79ec2a7c6bfe00c4123451fd","modified":1693673751287},{"_id":"public/img/mysql_explain36.png","hash":"ac44570bf18ee64b74393ba8cd4423208d98fe2e","modified":1693673751287},{"_id":"public/img/mysql_explain32.png","hash":"a060742362dddbd355d9755301279f6f68953a4d","modified":1693673751287},{"_id":"public/img/mysql_explain35.png","hash":"ae092c639b783fd819f7734bb863d2cd84806fbd","modified":1693673751287},{"_id":"public/img/mysql_explain37.png","hash":"daab581181684e6b25f49de849a7ac2359b55acf","modified":1693673751287},{"_id":"public/img/mysql_explain34.png","hash":"a2c2da54e0bf5a03f3921522dd7f6a6d182d089f","modified":1693673751287},{"_id":"public/img/mysql_explain39.png","hash":"00414ed7b4835e51836819885dcf759ed094267f","modified":1693673751287},{"_id":"public/img/mysql_explain38.png","hash":"a0153907db5652e1fb96ead54ee112592eebfe30","modified":1693673751287},{"_id":"public/img/mysql_explain41.png","hash":"686058f1a6c816ca8b5d1f7f2abec0b083cdc387","modified":1693673751287},{"_id":"public/img/mysql_explain40.png","hash":"6c6de934247fb908cc214a804c69fe35d01558b6","modified":1693673751287},{"_id":"public/img/mysql_explain42.png","hash":"7fb6a4a3aa283b4cd35b8a98591eb61dd8947f2e","modified":1693673751287},{"_id":"public/img/mysql_explain43.png","hash":"e29f7a02dcd352da05e7fd3394f5675a76eb7e01","modified":1693673751287},{"_id":"public/img/mysql_explain5.png","hash":"f81aba718cb80c4934ccabdb185ba4975b57fb1e","modified":1693673751287},{"_id":"public/img/mysql_explain8.png","hash":"3c35e6986bdf23577e293a0fbe80366d189f87de","modified":1693673751287},{"_id":"public/img/mysql_explain7.png","hash":"b915c17db6d9f57b3f1c426d124ddb63fd03c6f3","modified":1693673751287},{"_id":"public/img/mysql_explain44.png","hash":"b07d279015d7e07562a53d6ef93ad5cc064782fa","modified":1693673751287},{"_id":"public/img/oom-1.png","hash":"d1f1685f3112759961ce23c7d2b9decd73b39dea","modified":1693673751287},{"_id":"public/img/slow-sql.jpg","hash":"29cfb7c71f78e6d3c2c75d8161ecb193f63ca187","modified":1693673751287},{"_id":"themes/butterfly/source/img/oom.png","hash":"ef73fc7bf83993e75ca8e080ffcfacbd7e2ae0ac","modified":1693671457309},{"_id":"public/img/oom.png","hash":"ef73fc7bf83993e75ca8e080ffcfacbd7e2ae0ac","modified":1693673798292},{"_id":"themes/butterfly/source/img/techbeat.png","hash":"e915193d5a0847c5792723f3ff949f3d319f7093","modified":1694009146153},{"_id":"public/img/techbeat.png","hash":"e915193d5a0847c5792723f3ff949f3d319f7093","modified":1694009225726},{"_id":"themes/butterfly/source/img/leetcode.png","hash":"f3592ccbed2bb75f086f7cdafd9c48b0ca1967d5","modified":1694009362206},{"_id":"public/img/leetcode.png","hash":"f3592ccbed2bb75f086f7cdafd9c48b0ca1967d5","modified":1694009413718}],"Category":[{"name":"github仓库","_id":"clm29i994000488th6uur00oa"},{"name":"Stream流","_id":"clm29i996000788thdgxb0s9c"},{"name":"github","parent":"clm29i994000488th6uur00oa","_id":"clm29i997000988th2x4j8xvm"},{"name":"List转化为Map","parent":"clm29i996000788thdgxb0s9c","_id":"clm29i997000b88th6jjk7n76"},{"name":"OOM","_id":"clm29i99s000t88th311gezw7"},{"name":"Explain执行计划","_id":"clm29i99t000v88th29ipe58z"},{"name":"内存溢出","parent":"clm29i99s000t88th311gezw7","_id":"clm29i99t000x88thbt7eb2x9"},{"name":"索引","parent":"clm29i99t000v88th29ipe58z","_id":"clm29i99u001188th2iecdwoe"},{"name":"SQL慢查询优化","parent":"clm29i99u001188th2iecdwoe","_id":"clm29i99v001688th2u7v21le"},{"name":"算法","_id":"clm29i9a6001i88th07zy8nmy"},{"name":"动态规划","parent":"clm29i9a6001i88th07zy8nmy","_id":"clm29i9a7001l88thf99fbrkv"},{"name":"回溯算法","parent":"clm29i9a7001l88thf99fbrkv","_id":"clm29i9a8001n88theujgaprd"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"TechBeat","link":"https://www.techbeat.net/","avatar":"/img/techbeat.png","descr":"模型训练交流网站"},{"name":"LeetCode","link":"https://leetcode.cn/","avatar":"/img/leetcode.png","descr":"算法题库"}]}]},{"_id":"valine","data":{"妙":"bilibiliHotKey/1.jpg"}}],"Page":[{"title":"categories","date":"2023-09-01T11:11:30.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-09-01 19:11:30\ntype: \"categories\"\n---\n","updated":"2023-09-01T11:11:50.275Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clm29i98w000088thgnpx8o9l","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover":false,"excerpt":"","more":""},{"title":"link","date":"2023-09-01T11:12:08.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-09-01 19:12:08\ntype: \"link\"\n---\n","updated":"2023-09-01T11:12:21.262Z","path":"link/index.html","comments":1,"layout":"page","_id":"clm29i991000288th2e6d5855","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-09-01T11:09:22.000Z","type":"tags","orderby":"length","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-09-01 19:09:22\ntype: \"tags\"\norderby: length\norder: 1\n---\n","updated":"2023-09-01T11:10:25.134Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clm29i995000688thbp9308dv","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"将本地代码提交至github仓库","top_img":"/img/githubImage.jpg","cover":"/img/githubImage.jpg","keywords":"github仓库","description":"将本地代码提交至github仓库","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"abbrlink":"ce3886d7","date":"2018-01-01T04:50:18.000Z","_content":"## 创建github账号：\n在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。\n\n## 创建代码仓库：\n在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。\n\n## 安装git\n在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。\n\n## 创建和配置密钥\n要在 Git 中创建密钥，请按照以下步骤进行操作：\n\n### 1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\n\n\n```\nssh-keygen -t rsa -b 4096 -C \"your_email\"\n```\n\n\n### 2.按回车键接受默认的文件名和位置。\n\n### 3.输入你的密码短语（如果需要）。\n\n### 4.确认密码短语。\n\n### 5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n### 6.复制你的公钥。\n\n### 7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\n\n### 8.点击 \"Add SSH key\"（或类似的按钮）。\n\n### 9.将你的公钥粘贴到 \"Key\" 字段中。\n\n### 10.输入一个描述性的标题以标识此密钥。\n\n### 11.点击 \"Add key\"（或类似的按钮）。\n\n现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。\n\n## 创建本地代码仓库：\n在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：\n\n\n```\ngit init\n```\n\n这将在该文件夹中创建一个新的Git仓库。\n\n## *添加文件到本地代码仓库（更新）：\n将新文件添加到本地代码仓库中。在终端中，执行以下命令：\n\n\n```\ngit add .\n```\n\n这将把hello-world.py文件添加到Git的暂存区。\n\n## *提交（更新）：\n提交更改描述。在终端中，执行以下命令：\n\n\n```\ngit commit -m \"Initial commit\"\n```\n\n这将提交文件更改，并把提交描述设置为“Initial commit”。\n\n## 建立本地仓库和github仓库的关联：\n在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：\n\n\n```\ngit remote add origin [仓库的URL地址]\n```\n\n这将将您的本地仓库与Github仓库关联起来。\n\n## *推送代码到github仓库（更新）：\n推送您的代码到Github仓库。执行以下命令：\n\n\n```\ngit push -u origin master\n```\n\n这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。\n\n完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。","source":"_posts/将本地代码提交至github仓库.md","raw":"---\ntitle: 将本地代码提交至github仓库\ntags:\n  - github仓库\n  - github\n  - git\n  - 本地代码\ncategories:\n  - github仓库\n  - github\ntop_img: /img/githubImage.jpg\ncover: /img/githubImage.jpg\nkeywords: github仓库\ndescription: 将本地代码提交至github仓库\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\nabbrlink: ce3886d7\ndate: 2018-01-01 12:50:18\n---\n## 创建github账号：\n在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。\n\n## 创建代码仓库：\n在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。\n\n## 安装git\n在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。\n\n## 创建和配置密钥\n要在 Git 中创建密钥，请按照以下步骤进行操作：\n\n### 1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\n\n\n```\nssh-keygen -t rsa -b 4096 -C \"your_email\"\n```\n\n\n### 2.按回车键接受默认的文件名和位置。\n\n### 3.输入你的密码短语（如果需要）。\n\n### 4.确认密码短语。\n\n### 5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n### 6.复制你的公钥。\n\n### 7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\n\n### 8.点击 \"Add SSH key\"（或类似的按钮）。\n\n### 9.将你的公钥粘贴到 \"Key\" 字段中。\n\n### 10.输入一个描述性的标题以标识此密钥。\n\n### 11.点击 \"Add key\"（或类似的按钮）。\n\n现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。\n\n## 创建本地代码仓库：\n在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：\n\n\n```\ngit init\n```\n\n这将在该文件夹中创建一个新的Git仓库。\n\n## *添加文件到本地代码仓库（更新）：\n将新文件添加到本地代码仓库中。在终端中，执行以下命令：\n\n\n```\ngit add .\n```\n\n这将把hello-world.py文件添加到Git的暂存区。\n\n## *提交（更新）：\n提交更改描述。在终端中，执行以下命令：\n\n\n```\ngit commit -m \"Initial commit\"\n```\n\n这将提交文件更改，并把提交描述设置为“Initial commit”。\n\n## 建立本地仓库和github仓库的关联：\n在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：\n\n\n```\ngit remote add origin [仓库的URL地址]\n```\n\n这将将您的本地仓库与Github仓库关联起来。\n\n## *推送代码到github仓库（更新）：\n推送您的代码到Github仓库。执行以下命令：\n\n\n```\ngit push -u origin master\n```\n\n这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。\n\n完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。","slug":"将本地代码提交至github仓库","published":1,"updated":"2023-09-02T16:52:40.726Z","_id":"clm29i98y000188th1ad5f6lr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"创建github账号：\"><a href=\"#创建github账号：\" class=\"headerlink\" title=\"创建github账号：\"></a>创建github账号：</h2><p>在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。</p>\n<h2 id=\"创建代码仓库：\"><a href=\"#创建代码仓库：\" class=\"headerlink\" title=\"创建代码仓库：\"></a>创建代码仓库：</h2><p>在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。</p>\n<h2 id=\"创建和配置密钥\"><a href=\"#创建和配置密钥\" class=\"headerlink\" title=\"创建和配置密钥\"></a>创建和配置密钥</h2><p>要在 Git 中创建密钥，请按照以下步骤进行操作：</p>\n<h3 id=\"1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\"><a href=\"#1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\" class=\"headerlink\" title=\"1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\"></a>1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-按回车键接受默认的文件名和位置。\"><a href=\"#2-按回车键接受默认的文件名和位置。\" class=\"headerlink\" title=\"2.按回车键接受默认的文件名和位置。\"></a>2.按回车键接受默认的文件名和位置。</h3><h3 id=\"3-输入你的密码短语（如果需要）。\"><a href=\"#3-输入你的密码短语（如果需要）。\" class=\"headerlink\" title=\"3.输入你的密码短语（如果需要）。\"></a>3.输入你的密码短语（如果需要）。</h3><h3 id=\"4-确认密码短语。\"><a href=\"#4-确认密码短语。\" class=\"headerlink\" title=\"4.确认密码短语。\"></a>4.确认密码短语。</h3><h3 id=\"5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"><a href=\"#5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\" class=\"headerlink\" title=\"5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"></a>5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-复制你的公钥。\"><a href=\"#6-复制你的公钥。\" class=\"headerlink\" title=\"6.复制你的公钥。\"></a>6.复制你的公钥。</h3><h3 id=\"7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\"><a href=\"#7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\" class=\"headerlink\" title=\"7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\"></a>7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。</h3><h3 id=\"8-点击-“Add-SSH-key”（或类似的按钮）。\"><a href=\"#8-点击-“Add-SSH-key”（或类似的按钮）。\" class=\"headerlink\" title=\"8.点击 “Add SSH key”（或类似的按钮）。\"></a>8.点击 “Add SSH key”（或类似的按钮）。</h3><h3 id=\"9-将你的公钥粘贴到-“Key”-字段中。\"><a href=\"#9-将你的公钥粘贴到-“Key”-字段中。\" class=\"headerlink\" title=\"9.将你的公钥粘贴到 “Key” 字段中。\"></a>9.将你的公钥粘贴到 “Key” 字段中。</h3><h3 id=\"10-输入一个描述性的标题以标识此密钥。\"><a href=\"#10-输入一个描述性的标题以标识此密钥。\" class=\"headerlink\" title=\"10.输入一个描述性的标题以标识此密钥。\"></a>10.输入一个描述性的标题以标识此密钥。</h3><h3 id=\"11-点击-“Add-key”（或类似的按钮）。\"><a href=\"#11-点击-“Add-key”（或类似的按钮）。\" class=\"headerlink\" title=\"11.点击 “Add key”（或类似的按钮）。\"></a>11.点击 “Add key”（或类似的按钮）。</h3><p>现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。</p>\n<h2 id=\"创建本地代码仓库：\"><a href=\"#创建本地代码仓库：\" class=\"headerlink\" title=\"创建本地代码仓库：\"></a>创建本地代码仓库：</h2><p>在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>这将在该文件夹中创建一个新的Git仓库。</p>\n<h2 id=\"添加文件到本地代码仓库（更新）：\"><a href=\"#添加文件到本地代码仓库（更新）：\" class=\"headerlink\" title=\"*添加文件到本地代码仓库（更新）：\"></a>*添加文件到本地代码仓库（更新）：</h2><p>将新文件添加到本地代码仓库中。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>这将把hello-world.py文件添加到Git的暂存区。</p>\n<h2 id=\"提交（更新）：\"><a href=\"#提交（更新）：\" class=\"headerlink\" title=\"*提交（更新）：\"></a>*提交（更新）：</h2><p>提交更改描述。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这将提交文件更改，并把提交描述设置为“Initial commit”。</p>\n<h2 id=\"建立本地仓库和github仓库的关联：\"><a href=\"#建立本地仓库和github仓库的关联：\" class=\"headerlink\" title=\"建立本地仓库和github仓库的关联：\"></a>建立本地仓库和github仓库的关联：</h2><p>在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin [仓库的URL地址]</span><br></pre></td></tr></table></figure>\n\n<p>这将将您的本地仓库与Github仓库关联起来。</p>\n<h2 id=\"推送代码到github仓库（更新）：\"><a href=\"#推送代码到github仓库（更新）：\" class=\"headerlink\" title=\"*推送代码到github仓库（更新）：\"></a>*推送代码到github仓库（更新）：</h2><p>推送您的代码到Github仓库。执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。</p>\n<p>完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover_type":"img","excerpt":"","more":"<h2 id=\"创建github账号：\"><a href=\"#创建github账号：\" class=\"headerlink\" title=\"创建github账号：\"></a>创建github账号：</h2><p>在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。</p>\n<h2 id=\"创建代码仓库：\"><a href=\"#创建代码仓库：\" class=\"headerlink\" title=\"创建代码仓库：\"></a>创建代码仓库：</h2><p>在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。</p>\n<h2 id=\"创建和配置密钥\"><a href=\"#创建和配置密钥\" class=\"headerlink\" title=\"创建和配置密钥\"></a>创建和配置密钥</h2><p>要在 Git 中创建密钥，请按照以下步骤进行操作：</p>\n<h3 id=\"1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\"><a href=\"#1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\" class=\"headerlink\" title=\"1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\"></a>1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-按回车键接受默认的文件名和位置。\"><a href=\"#2-按回车键接受默认的文件名和位置。\" class=\"headerlink\" title=\"2.按回车键接受默认的文件名和位置。\"></a>2.按回车键接受默认的文件名和位置。</h3><h3 id=\"3-输入你的密码短语（如果需要）。\"><a href=\"#3-输入你的密码短语（如果需要）。\" class=\"headerlink\" title=\"3.输入你的密码短语（如果需要）。\"></a>3.输入你的密码短语（如果需要）。</h3><h3 id=\"4-确认密码短语。\"><a href=\"#4-确认密码短语。\" class=\"headerlink\" title=\"4.确认密码短语。\"></a>4.确认密码短语。</h3><h3 id=\"5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"><a href=\"#5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\" class=\"headerlink\" title=\"5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"></a>5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-复制你的公钥。\"><a href=\"#6-复制你的公钥。\" class=\"headerlink\" title=\"6.复制你的公钥。\"></a>6.复制你的公钥。</h3><h3 id=\"7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\"><a href=\"#7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\" class=\"headerlink\" title=\"7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\"></a>7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。</h3><h3 id=\"8-点击-“Add-SSH-key”（或类似的按钮）。\"><a href=\"#8-点击-“Add-SSH-key”（或类似的按钮）。\" class=\"headerlink\" title=\"8.点击 “Add SSH key”（或类似的按钮）。\"></a>8.点击 “Add SSH key”（或类似的按钮）。</h3><h3 id=\"9-将你的公钥粘贴到-“Key”-字段中。\"><a href=\"#9-将你的公钥粘贴到-“Key”-字段中。\" class=\"headerlink\" title=\"9.将你的公钥粘贴到 “Key” 字段中。\"></a>9.将你的公钥粘贴到 “Key” 字段中。</h3><h3 id=\"10-输入一个描述性的标题以标识此密钥。\"><a href=\"#10-输入一个描述性的标题以标识此密钥。\" class=\"headerlink\" title=\"10.输入一个描述性的标题以标识此密钥。\"></a>10.输入一个描述性的标题以标识此密钥。</h3><h3 id=\"11-点击-“Add-key”（或类似的按钮）。\"><a href=\"#11-点击-“Add-key”（或类似的按钮）。\" class=\"headerlink\" title=\"11.点击 “Add key”（或类似的按钮）。\"></a>11.点击 “Add key”（或类似的按钮）。</h3><p>现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。</p>\n<h2 id=\"创建本地代码仓库：\"><a href=\"#创建本地代码仓库：\" class=\"headerlink\" title=\"创建本地代码仓库：\"></a>创建本地代码仓库：</h2><p>在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>这将在该文件夹中创建一个新的Git仓库。</p>\n<h2 id=\"添加文件到本地代码仓库（更新）：\"><a href=\"#添加文件到本地代码仓库（更新）：\" class=\"headerlink\" title=\"*添加文件到本地代码仓库（更新）：\"></a>*添加文件到本地代码仓库（更新）：</h2><p>将新文件添加到本地代码仓库中。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>这将把hello-world.py文件添加到Git的暂存区。</p>\n<h2 id=\"提交（更新）：\"><a href=\"#提交（更新）：\" class=\"headerlink\" title=\"*提交（更新）：\"></a>*提交（更新）：</h2><p>提交更改描述。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这将提交文件更改，并把提交描述设置为“Initial commit”。</p>\n<h2 id=\"建立本地仓库和github仓库的关联：\"><a href=\"#建立本地仓库和github仓库的关联：\" class=\"headerlink\" title=\"建立本地仓库和github仓库的关联：\"></a>建立本地仓库和github仓库的关联：</h2><p>在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin [仓库的URL地址]</span><br></pre></td></tr></table></figure>\n\n<p>这将将您的本地仓库与Github仓库关联起来。</p>\n<h2 id=\"推送代码到github仓库（更新）：\"><a href=\"#推送代码到github仓库（更新）：\" class=\"headerlink\" title=\"*推送代码到github仓库（更新）：\"></a>*推送代码到github仓库（更新）：</h2><p>推送您的代码到Github仓库。执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。</p>\n<p>完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。</p>\n"},{"title":"JAVA之用Stream流将List转化为Map","top_img":"/img/java_stream.jpg","cover":"/img/java_stream.jpg","keywords":"Stream流","description":"JAVA之用Stream流将List转化为Map的方式","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"abbrlink":"211807b3","date":"2019-02-01T04:50:18.000Z","_content":"# 1、**JDK1.8流方式**\n**用户类**\n```\nimport lombok.Data;\n\n@Data\npublic class User {\n\n    private String id;\n    private String name;\n\n    public User(String id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n## 1. **收集成key为id，value为name：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, String> collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));\n\n        for (Map.Entry<String, String> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-1.png)\n\n\n## **2. 收集成实体本身**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getId, user -> user));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-2.png)\n\nuser -> user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：\n```\nMap<String, User> collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n```\n\n**重复key的情况：**\n代码如下：\n```\nMap<String, User> collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());\n```\n这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。\n![图片](/img/java-stream-3.png)\n\n**toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-4.png)\n\n**这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, List<User>> collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));\n\n        for (Map.Entry<String, List<User>> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-5.png)\n\n## **3. 指定具体收集的map**\ntoMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2, LinkedHashMap::new));\n\n        for (Map.Entry<String, User> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-6.png)\n\n","source":"_posts/JAVA之用Stream流将List转化为Map.md","raw":"---\ntitle: JAVA之用Stream流将List转化为Map\ntags:\n  - Stream流\n  - JDK 1.8\n  - List转化为Map\ncategories:\n  - Stream流\n  - List转化为Map\ntop_img: /img/java_stream.jpg\ncover: /img/java_stream.jpg\nkeywords: Stream流\ndescription: JAVA之用Stream流将List转化为Map的方式\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\nabbrlink: 211807b3\ndate: 2019-02-01 12:50:18\n---\n# 1、**JDK1.8流方式**\n**用户类**\n```\nimport lombok.Data;\n\n@Data\npublic class User {\n\n    private String id;\n    private String name;\n\n    public User(String id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n## 1. **收集成key为id，value为name：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, String> collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));\n\n        for (Map.Entry<String, String> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-1.png)\n\n\n## **2. 收集成实体本身**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getId, user -> user));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-2.png)\n\nuser -> user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：\n```\nMap<String, User> collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n```\n\n**重复key的情况：**\n代码如下：\n```\nMap<String, User> collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());\n```\n这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。\n![图片](/img/java-stream-3.png)\n\n**toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-4.png)\n\n**这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, List<User>> collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));\n\n        for (Map.Entry<String, List<User>> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-5.png)\n\n## **3. 指定具体收集的map**\ntoMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2, LinkedHashMap::new));\n\n        for (Map.Entry<String, User> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-6.png)\n\n","slug":"JAVA之用Stream流将List转化为Map","published":1,"updated":"2023-09-02T16:52:40.736Z","_id":"clm29i992000388thdon7blnr","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1、JDK1-8流方式\"><a href=\"#1、JDK1-8流方式\" class=\"headerlink\" title=\"1、JDK1.8流方式\"></a>1、<strong>JDK1.8流方式</strong></h1><p><strong>用户类</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class User &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User(String id, String name) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-收集成key为id，value为name：\"><a href=\"#1-收集成key为id，value为name：\" class=\"headerlink\" title=\"1. 收集成key为id，value为name：\"></a>1. <strong>收集成key为id，value为name：</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, String&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, String&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-1.png\" alt=\"图片\"></p>\n<h2 id=\"2-收集成实体本身\"><a href=\"#2-收集成实体本身\" class=\"headerlink\" title=\"2. 收集成实体本身\"></a><strong>2. 收集成实体本身</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, user -&gt; user));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-2.png\" alt=\"图片\"></p>\n<p>user -&gt; user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br></pre></td></tr></table></figure>\n\n<p><strong>重复key的情况：</strong><br>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());</span><br></pre></td></tr></table></figure>\n<p>这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。<br><img src=\"/img/java-stream-3.png\" alt=\"图片\"></p>\n<p><strong>toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-4.png\" alt=\"图片\"></p>\n<p><strong>这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, List&lt;User&gt;&gt; collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, List&lt;User&gt;&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-5.png\" alt=\"图片\"></p>\n<h2 id=\"3-指定具体收集的map\"><a href=\"#3-指定具体收集的map\" class=\"headerlink\" title=\"3. 指定具体收集的map\"></a><strong>3. 指定具体收集的map</strong></h2><p>toMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2, LinkedHashMap::new));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-6.png\" alt=\"图片\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover_type":"img","excerpt":"","more":"<h1 id=\"1、JDK1-8流方式\"><a href=\"#1、JDK1-8流方式\" class=\"headerlink\" title=\"1、JDK1.8流方式\"></a>1、<strong>JDK1.8流方式</strong></h1><p><strong>用户类</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class User &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User(String id, String name) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-收集成key为id，value为name：\"><a href=\"#1-收集成key为id，value为name：\" class=\"headerlink\" title=\"1. 收集成key为id，value为name：\"></a>1. <strong>收集成key为id，value为name：</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, String&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, String&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-1.png\" alt=\"图片\"></p>\n<h2 id=\"2-收集成实体本身\"><a href=\"#2-收集成实体本身\" class=\"headerlink\" title=\"2. 收集成实体本身\"></a><strong>2. 收集成实体本身</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, user -&gt; user));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-2.png\" alt=\"图片\"></p>\n<p>user -&gt; user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br></pre></td></tr></table></figure>\n\n<p><strong>重复key的情况：</strong><br>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());</span><br></pre></td></tr></table></figure>\n<p>这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。<br><img src=\"/img/java-stream-3.png\" alt=\"图片\"></p>\n<p><strong>toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-4.png\" alt=\"图片\"></p>\n<p><strong>这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, List&lt;User&gt;&gt; collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, List&lt;User&gt;&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-5.png\" alt=\"图片\"></p>\n<h2 id=\"3-指定具体收集的map\"><a href=\"#3-指定具体收集的map\" class=\"headerlink\" title=\"3. 指定具体收集的map\"></a><strong>3. 指定具体收集的map</strong></h2><p>toMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2, LinkedHashMap::new));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-6.png\" alt=\"图片\"></p>\n"},{"title":"OOM-内存溢出问题排查","top_img":"/img/oom.png","cover":"/img/oom.png","keywords":"OOM","description":"内存溢出指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"abbrlink":"a67acf23","date":"2020-05-11T12:50:18.000Z","_content":"# **OOM(内存溢出的问题)排查**\n\n- **内存泄漏(Memory Leak)**:是指程序在申请内存后,无法释放已申请的内存空间,一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。\n\n- **内存溢出(Memory Overflow)**：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。\n\n\n**OOM原因：**\n\n1.一次性申请的数量太多\n(更改申请对象数量)\n\n2.内存资源耗尽未释放\n(找到未释放的对象进行释放)\n\n3.本身资源不够\njmap -heap 查看堆信息\n\n\n**OOM如何定位和解决的方法**\n**1.系统已经OOM挂了**\n\n提前设置：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=\n```\njava -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath= -jar xxxx.jar\n```\n![图片](/img/oom-1.png)\n再利用Java VisualVM去分析这个文件。\n\n**2.系统运行中还未OOM**\n\n导出dump文件：\n\n```\njmap -dump:format=b,file=./jvm_logs/xushu.hprof 24286\n```\n\n\n注：\n(1) file=表示dump文件打印的位置。\n(2)24286表示进程号。\n\n\n或使用Arthas软件。\n\n\n---\n\n线上系统OOM排查步骤：\n1. 使用top命令看一下线上的CPU、内存使用情况。\n2. 定位异常进程，看日志。\n3. 如果是OOM，则用jstat -gc pid 1000 100(每秒)监控JVM内存运行情况和gc频率。\n4. jmap -dump:live,format=b,file=dump3.hprof pid,\n   使用jmap dump内存快照。(导出dump文件命令)\n5. 使用MAT工具分析。\n可以看下面的注。\n\n注：\n1. jps (查看进程号)\n2. jmap -histo:live 进程号 > 存放路径  (将进程打印到文本中)\n3. start 路径名 (打开文本，查看实例个数)\n4. ps -ef | grep 服务名 ps -aux | grep 服务名\n   查看服务的进程是否存在\n5. 查看服务的日志\n   cat -n xxx_log |grep \"OutOfMemoryError\"\n6. 查看堆内存占用概况\n   jmap -heap 进程号\n7. 查看堆中对象的统计信息\n   jmap -histo 进程号 | head -n 100\n8. 查看GC统计信息\n   jstat -gcutil 进程号\n```\n   S0 S1 E O M CCS YGC YGCT FGC FGCT GCT\n   0.00 0.00 100.00 99.94 90.56 87.86 875 9.307 3223 5313.139 5322.446\n```\n    S0：幸存1区当前使用比例\n    S1：幸存2区当前使用比例\n    E：Eden Space（伊甸园）区使用比例\n    O：Old Gen（老年代）使用比例\n    M：元数据区使用比例\n    CCS：压缩使用比例\n    YGC：年轻代垃圾回收次数\n    FGC：老年代垃圾回收次数\n    FGCT：老年代垃圾回收消耗时间\n    GCT：垃圾回收消耗总时间\n    \n9. **生产对堆快照Heap dump**\n\n   **jmap -dump:format=b,file=/tmp/进程号_jmap_dump.hprof 进程号**\n\n\n","source":"_posts/OOM-内存溢出问题排查.md","raw":"---\ntitle: OOM-内存溢出问题排查\ntags:\n  - OOM\n  - 内存溢出\ncategories:\n  - OOM\n  - 内存溢出\ntop_img: /img/oom.png\ncover: /img/oom.png\nkeywords: OOM\ndescription: >-\n  内存溢出指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\nabbrlink: a67acf23\ndate: 2020-05-11 20:50:18\n---\n# **OOM(内存溢出的问题)排查**\n\n- **内存泄漏(Memory Leak)**:是指程序在申请内存后,无法释放已申请的内存空间,一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。\n\n- **内存溢出(Memory Overflow)**：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。\n\n\n**OOM原因：**\n\n1.一次性申请的数量太多\n(更改申请对象数量)\n\n2.内存资源耗尽未释放\n(找到未释放的对象进行释放)\n\n3.本身资源不够\njmap -heap 查看堆信息\n\n\n**OOM如何定位和解决的方法**\n**1.系统已经OOM挂了**\n\n提前设置：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=\n```\njava -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath= -jar xxxx.jar\n```\n![图片](/img/oom-1.png)\n再利用Java VisualVM去分析这个文件。\n\n**2.系统运行中还未OOM**\n\n导出dump文件：\n\n```\njmap -dump:format=b,file=./jvm_logs/xushu.hprof 24286\n```\n\n\n注：\n(1) file=表示dump文件打印的位置。\n(2)24286表示进程号。\n\n\n或使用Arthas软件。\n\n\n---\n\n线上系统OOM排查步骤：\n1. 使用top命令看一下线上的CPU、内存使用情况。\n2. 定位异常进程，看日志。\n3. 如果是OOM，则用jstat -gc pid 1000 100(每秒)监控JVM内存运行情况和gc频率。\n4. jmap -dump:live,format=b,file=dump3.hprof pid,\n   使用jmap dump内存快照。(导出dump文件命令)\n5. 使用MAT工具分析。\n可以看下面的注。\n\n注：\n1. jps (查看进程号)\n2. jmap -histo:live 进程号 > 存放路径  (将进程打印到文本中)\n3. start 路径名 (打开文本，查看实例个数)\n4. ps -ef | grep 服务名 ps -aux | grep 服务名\n   查看服务的进程是否存在\n5. 查看服务的日志\n   cat -n xxx_log |grep \"OutOfMemoryError\"\n6. 查看堆内存占用概况\n   jmap -heap 进程号\n7. 查看堆中对象的统计信息\n   jmap -histo 进程号 | head -n 100\n8. 查看GC统计信息\n   jstat -gcutil 进程号\n```\n   S0 S1 E O M CCS YGC YGCT FGC FGCT GCT\n   0.00 0.00 100.00 99.94 90.56 87.86 875 9.307 3223 5313.139 5322.446\n```\n    S0：幸存1区当前使用比例\n    S1：幸存2区当前使用比例\n    E：Eden Space（伊甸园）区使用比例\n    O：Old Gen（老年代）使用比例\n    M：元数据区使用比例\n    CCS：压缩使用比例\n    YGC：年轻代垃圾回收次数\n    FGC：老年代垃圾回收次数\n    FGCT：老年代垃圾回收消耗时间\n    GCT：垃圾回收消耗总时间\n    \n9. **生产对堆快照Heap dump**\n\n   **jmap -dump:format=b,file=/tmp/进程号_jmap_dump.hprof 进程号**\n\n\n","slug":"OOM-内存溢出问题排查","published":1,"updated":"2023-09-02T16:20:52.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm29i99r000r88th0f98chat","content":"<h1 id=\"OOM-内存溢出的问题-排查\"><a href=\"#OOM-内存溢出的问题-排查\" class=\"headerlink\" title=\"OOM(内存溢出的问题)排查\"></a><strong>OOM(内存溢出的问题)排查</strong></h1><ul>\n<li><p><strong>内存泄漏(Memory Leak)</strong>:是指程序在申请内存后,无法释放已申请的内存空间,一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。</p>\n</li>\n<li><p>**内存溢出(Memory Overflow)**：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>\n</li>\n</ul>\n<p><strong>OOM原因：</strong></p>\n<p>1.一次性申请的数量太多<br>(更改申请对象数量)</p>\n<p>2.内存资源耗尽未释放<br>(找到未释放的对象进行释放)</p>\n<p>3.本身资源不够<br>jmap -heap 查看堆信息</p>\n<p><strong>OOM如何定位和解决的方法</strong><br><strong>1.系统已经OOM挂了</strong></p>\n<p>提前设置：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath= -jar xxxx.jar</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/oom-1.png\" alt=\"图片\"><br>再利用Java VisualVM去分析这个文件。</p>\n<p><strong>2.系统运行中还未OOM</strong></p>\n<p>导出dump文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:format=b,file=./jvm_logs/xushu.hprof 24286</span><br></pre></td></tr></table></figure>\n\n\n<p>注：<br>(1) file&#x3D;表示dump文件打印的位置。<br>(2)24286表示进程号。</p>\n<p>或使用Arthas软件。</p>\n<hr>\n<p>线上系统OOM排查步骤：</p>\n<ol>\n<li>使用top命令看一下线上的CPU、内存使用情况。</li>\n<li>定位异常进程，看日志。</li>\n<li>如果是OOM，则用jstat -gc pid 1000 100(每秒)监控JVM内存运行情况和gc频率。</li>\n<li>jmap -dump:live,format&#x3D;b,file&#x3D;dump3.hprof pid,<br>使用jmap dump内存快照。(导出dump文件命令)</li>\n<li>使用MAT工具分析。<br>可以看下面的注。</li>\n</ol>\n<p>注：</p>\n<ol>\n<li><p>jps (查看进程号)</p>\n</li>\n<li><p>jmap -histo:live 进程号 &gt; 存放路径  (将进程打印到文本中)</p>\n</li>\n<li><p>start 路径名 (打开文本，查看实例个数)</p>\n</li>\n<li><p>ps -ef | grep 服务名 ps -aux | grep 服务名<br>查看服务的进程是否存在</p>\n</li>\n<li><p>查看服务的日志<br>cat -n xxx_log |grep “OutOfMemoryError”</p>\n</li>\n<li><p>查看堆内存占用概况<br>jmap -heap 进程号</p>\n</li>\n<li><p>查看堆中对象的统计信息<br>jmap -histo 进程号 | head -n 100</p>\n</li>\n<li><p>查看GC统计信息<br>jstat -gcutil 进程号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S0 S1 E O M CCS YGC YGCT FGC FGCT GCT</span><br><span class=\"line\">0.00 0.00 100.00 99.94 90.56 87.86 875 9.307 3223 5313.139 5322.446</span><br></pre></td></tr></table></figure>\n<p> S0：幸存1区当前使用比例<br> S1：幸存2区当前使用比例<br> E：Eden Space（伊甸园）区使用比例<br> O：Old Gen（老年代）使用比例<br> M：元数据区使用比例<br> CCS：压缩使用比例<br> YGC：年轻代垃圾回收次数<br> FGC：老年代垃圾回收次数<br> FGCT：老年代垃圾回收消耗时间<br> GCT：垃圾回收消耗总时间</p>\n</li>\n<li><p><strong>生产对堆快照Heap dump</strong></p>\n<p><strong>jmap -dump:format&#x3D;b,file&#x3D;&#x2F;tmp&#x2F;进程号_jmap_dump.hprof 进程号</strong></p>\n</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover_type":"img","excerpt":"","more":"<h1 id=\"OOM-内存溢出的问题-排查\"><a href=\"#OOM-内存溢出的问题-排查\" class=\"headerlink\" title=\"OOM(内存溢出的问题)排查\"></a><strong>OOM(内存溢出的问题)排查</strong></h1><ul>\n<li><p><strong>内存泄漏(Memory Leak)</strong>:是指程序在申请内存后,无法释放已申请的内存空间,一次内存泄漏似乎不会有大的影响,但内存泄漏堆积后的后果就是内存溢出。</p>\n</li>\n<li><p>**内存溢出(Memory Overflow)**：指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</p>\n</li>\n</ul>\n<p><strong>OOM原因：</strong></p>\n<p>1.一次性申请的数量太多<br>(更改申请对象数量)</p>\n<p>2.内存资源耗尽未释放<br>(找到未释放的对象进行释放)</p>\n<p>3.本身资源不够<br>jmap -heap 查看堆信息</p>\n<p><strong>OOM如何定位和解决的方法</strong><br><strong>1.系统已经OOM挂了</strong></p>\n<p>提前设置：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath= -jar xxxx.jar</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/oom-1.png\" alt=\"图片\"><br>再利用Java VisualVM去分析这个文件。</p>\n<p><strong>2.系统运行中还未OOM</strong></p>\n<p>导出dump文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:format=b,file=./jvm_logs/xushu.hprof 24286</span><br></pre></td></tr></table></figure>\n\n\n<p>注：<br>(1) file&#x3D;表示dump文件打印的位置。<br>(2)24286表示进程号。</p>\n<p>或使用Arthas软件。</p>\n<hr>\n<p>线上系统OOM排查步骤：</p>\n<ol>\n<li>使用top命令看一下线上的CPU、内存使用情况。</li>\n<li>定位异常进程，看日志。</li>\n<li>如果是OOM，则用jstat -gc pid 1000 100(每秒)监控JVM内存运行情况和gc频率。</li>\n<li>jmap -dump:live,format&#x3D;b,file&#x3D;dump3.hprof pid,<br>使用jmap dump内存快照。(导出dump文件命令)</li>\n<li>使用MAT工具分析。<br>可以看下面的注。</li>\n</ol>\n<p>注：</p>\n<ol>\n<li><p>jps (查看进程号)</p>\n</li>\n<li><p>jmap -histo:live 进程号 &gt; 存放路径  (将进程打印到文本中)</p>\n</li>\n<li><p>start 路径名 (打开文本，查看实例个数)</p>\n</li>\n<li><p>ps -ef | grep 服务名 ps -aux | grep 服务名<br>查看服务的进程是否存在</p>\n</li>\n<li><p>查看服务的日志<br>cat -n xxx_log |grep “OutOfMemoryError”</p>\n</li>\n<li><p>查看堆内存占用概况<br>jmap -heap 进程号</p>\n</li>\n<li><p>查看堆中对象的统计信息<br>jmap -histo 进程号 | head -n 100</p>\n</li>\n<li><p>查看GC统计信息<br>jstat -gcutil 进程号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S0 S1 E O M CCS YGC YGCT FGC FGCT GCT</span><br><span class=\"line\">0.00 0.00 100.00 99.94 90.56 87.86 875 9.307 3223 5313.139 5322.446</span><br></pre></td></tr></table></figure>\n<p> S0：幸存1区当前使用比例<br> S1：幸存2区当前使用比例<br> E：Eden Space（伊甸园）区使用比例<br> O：Old Gen（老年代）使用比例<br> M：元数据区使用比例<br> CCS：压缩使用比例<br> YGC：年轻代垃圾回收次数<br> FGC：老年代垃圾回收次数<br> FGCT：老年代垃圾回收消耗时间<br> GCT：垃圾回收消耗总时间</p>\n</li>\n<li><p><strong>生产对堆快照Heap dump</strong></p>\n<p><strong>jmap -dump:format&#x3D;b,file&#x3D;&#x2F;tmp&#x2F;进程号_jmap_dump.hprof 进程号</strong></p>\n</li>\n</ol>\n"},{"title":"Explain详解与索引最佳实践","top_img":"/img/slow-sql.jpg","cover":"/img/slow-sql.jpg","keywords":"Explain执行计划","description":"SQL慢查询优化","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"abbrlink":"9da9fd2","date":"2020-08-16T13:50:18.000Z","_content":"**1. Explain使用与详解**  \n**1. Explain介绍**\n使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈\n在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会\n返回执行计划的信息，而不是执行这条SQL。\n**注意**： 如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。\n\n**Explain分析示例**\n\n```\n示例表：\n2 DROP TABLE IF EXISTS `actor`;\n3 CREATE TABLE `actor` (\n4 `id` int(11) NOT NULL,\n5 `name` varchar(45) DEFAULT NULL,\n6 `update_time` datetime DEFAULT NULL,\n7 PRIMARY KEY (`id`)\n8 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n9\n10 INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (1,'a','2017‐12‐22\n15:27:18'), (2,'b','2017‐12‐22 15:27:18'), (3,'c','2017‐12‐22 15:27:18');\n11\n12 DROP TABLE IF EXISTS `film`;\n13 CREATE TABLE `film` (\n14 `id` int(11) NOT NULL AUTO_INCREMENT,\n15 `name` varchar(10) DEFAULT NULL,\n16 PRIMARY KEY (`id`),\n17 KEY `idx_name` (`name`)\n18 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n19\n20 INSERT INTO `film` (`id`, `name`) VALUES (3,'film0'),(1,'film1'),(2,'film2');\n21\n22 DROP TABLE IF EXISTS `film_actor`;\n23 CREATE TABLE `film_actor` (\n24 `id` int(11) NOT NULL,\n25 `film_id` int(11) NOT NULL,\n26 `actor_id` int(11) NOT NULL,\n27 `remark` varchar(255) DEFAULT NULL,\n28 PRIMARY KEY (`id`),\n29 KEY `idx_film_actor_id` (`film_id`,`actor_id`)\n30 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n31\n32 INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (1,1,1),(2,1,2),(3,2,1);\n```\n\n\n```\nmysql> explain select * from actor;\n```\n\n![图片](/img/mysql_explain1.png)\n在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。\n\n**explain 两个变种**\n**1）explain extended**：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。\n\n```\n1 mysql> explain extended select * from film where id = 1;\n```\n![图片](/img/mysql_explain2.png)\n\n```\n1 mysql> show warnings;\n```\n![图片](/img/mysql_explain3.png)\n\n\n**2）explain partitions**：相比 explain 多了个 partitions字段，如果查询是基于分区表\n的话，会显示查询将访问的分区。\n\n\n### **explain中的列**\n接下来我们将展示 explain 中每个列的信息。\n\n**1. id列**\nid列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。\nid列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。\n举例： id有1,2,3，则id为3的执行优先级最高。\n\n**2. select_type列**\nselect_type 表示对应行是简单还是复杂的查询。\n\n1）simple：简单查询。查询不包含子查询和union。\n\n```\n1 mysql> explain select * from film where id = 2;\n```\n![图片](/img/mysql_explain4.png)\n2）primary：复杂查询中最外层的 select。\n3）subquery：包含在 select 中的子查询（不在 from 子句中）。\n4）derived：衍生查询。包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）。\n用这个例子来了解 primary、subquery 和 derived 类型\n\n\n```\n1 mysql> set session optimizer_switch='derived_merge=off'; #关闭mysql5.7新特性对衍生表的合\n并优化\n2 mysql> explain select (select 1 from actor where id = 1) from (select * from film where\nid = 1) der;\n```\n![图片](/img/mysql_explain5.png)\n\n\n```\n1 mysql> set session optimizer_switch='derived_merge=on'; #还原默认配置\n```\n5）union：在 union 中的第二个和随后的 select\n\n```\n1 mysql> explain select 1 union all select 1;\n```\n![图片](/img/mysql_explain6.png)\n\n**3. table列**\n这一列表示 explain 的一行正在访问哪个表。\n当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。\n当有 union 时，UNION RESULT 的 table 列的值为<union1,2>，1和2表示参与 union 的 select 行id。\n\n**4. type列**\n这一列表示**关联类型或访问类型**，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。\n依次从最优到最差分别为：**system > const > eq_ref > ref > range > index > ALL(全局)**\n一般来说，**得保证查询达到range级别，最好达到ref**。\n\n**NULL**：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。如下：\n```\n1 mysql> explain select min(id) from film;\n```\n![图片](/img/mysql_explain7.png)\n\n**const, system**：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。const通俗点就是说和查询一个常量一样很快。用于primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。**system是const的特例**，表里只有一条元组匹配时为system。\n```\n1 mysql> explain extended select * from (select * from film where id = 1) tmp;\n```\n![图片](/img/mysql_explain8.png)\n```\n1 mysql> show warnings;\n```\n![图片](/img/mysql_explain9.png)\n\n**eq_ref**：primary key(主键) 或 unique key(唯一键) 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。如下：\n```\n1 mysql> explain select * from film_actor left join film on film_actor.film_id = film.id;\n```\n![图片](/img/mysql_explain10.png)\n\n**ref**：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n1. 简单 select 查询，name是普通索引（非唯一索引）\n```\n1 mysql> explain select * from film where name = 'film1';\n```\n![图片](/img/mysql_explain11.png)\n\n2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。如下：\n```\n1 mysql> explain select film_id from film left join film_actor on film.id = film_actor.film_id;\n```\n![图片](/img/mysql_explain12.png)\n\n**range**：范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。\n\n```\n1 mysql> explain select * from actor where id > 1;\n```\n![图片](/img/mysql_explain13.png)\n\n\n**index**：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。如下：\n```\n1 mysql> explain select * from film;\n```\n![图片](/img/mysql_explain14.png)\n\n\n**ALL**：即全表扫描，扫描你的聚簇索引的所有叶子节点。**通常情况下这需要增加索引来进行优化了**。如下：\n```\n1 mysql> explain select * from actor;\n```\n![图片](/img/mysql_explain15.png)\n\n**5. possible_keys列**\n这一列显示查询**可能使用**哪些索引来查找。\nexplain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引\n对此查询帮助不大，选择了全表查询。\n如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提\n高查询性能，然后用 explain 查看效果。\n\n**6. key列**\n这一列显示mysql**实际采用**哪个索引来优化对该表的访问。\n如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，\n在查询中使用 force index、ignore index。\n\n**7. key_len列**\n这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。\n举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。\n\n\n```\n1 mysql> explain select * from film_actor where film_id = 2;\n```\n![图片](/img/mysql_explain16.png)\n**key_len计算规则如下：**\n- 字符串，char(n)和varchar(n)，5.0.3以后版本中，**n均代表字符数，而不是字节数**，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节。\n  -  char(n)：如果存汉字长度就是 3n 字节。\n  -  varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为\nvarchar是变长字符串。\n\n- 数值类型\n  -  tinyint：1字节\n  -  smallint：2字节\n  -  int：4字节\n  -  bigint：8字节\n  -  \n- 时间类型\n  -  date：3字节\n  -  timestamp：4字节\n  -  datetime：8字节\n\n- 如果字段允许为 NULL，需要1字节记录是否为 NULL\n\n索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。\n\n**8. ref列**\n这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）\n\n**9. rows列**\n这一列是mysql估计要读取并检测的行数，**注意**这个不是结果集里的行数。\n\n**10. Extra列**\n这一列展示的是额外信息。常见的重要值如下：\n**1）Using index**：使用覆盖索引。\n**覆盖索引定义**：覆盖索引并不是一种索引，它是一种查询的方式，表示所查询的字段在索引树里都包含了。mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。如下：film_id在索引树里包含了。\n```\n1 mysql> explain select film_id from film_actor where film_id = 1;\n```\n![图片](/img/mysql_explain17.png)\n\n**2）Using where**：使用 where 语句来处理结果，并且查询的列未被索引覆盖。\n```\n1 mysql> explain select * from film_actor where film_id > 1;\n```\n![图片](/img/mysql_explain18.png)\n\n**3）Using index condition**：查询的列不完全被索引覆盖，where条件中是一个前导列的范围。\n```\n1 mysql> explain select * from film_actor where film_id > 1;\n```\n![图片](/img/mysql_explain19.png)\n\n\n**4）Using temporary**：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。\n\n1. actor.name没有索引，此时创建了张临时表来distinct。\n```\n1 mysql> explain select distinct name from actor;\n```\n![图片](/img/mysql_explain20.png)\n\n2. film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表。\n```\n1 mysql> explain select distinct name from film;\n```\n![图片](/img/mysql_explain21.png)\n\n**5）Using filesort**：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。\n\n1. actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。\n```\n1 mysql> explain select * from actor order by name;\n```\n![图片](/img/mysql_explain22.png)\n\n2. film.name建立了idx_name索引,此时查询时extra是using index。\n```\n1 mysql> explain select * from film order by name;\n```\n![图片](/img/mysql_explain23.png)\n\n**6）Select tables optimized away**：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时。\n```\n1 mysql> explain select min(id) from film;\n```\n![图片](/img/mysql_explain24.png)\n\n\n### **索引最佳实践**\n```\n示例表：\n2 CREATE TABLE `employees` (\n3 `id` int(11) NOT NULL AUTO_INCREMENT,\n4 `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名',\n5 `age` int(11) NOT NULL DEFAULT '0' COMMENT '年龄',\n6 `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位',\n7 `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间',\n8 PRIMARY KEY (`id`),\n9 KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE\n10 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='员工记录表';\n11\n12 INSERT INTO employees(name,age,position,hire_time) VALUES('LiLei',22,'manager',NOW());\n13 INSERT INTO employees(name,age,position,hire_time) VALUES('HanMeimei',\n23,'dev',NOW());\n14 INSERT INTO employees(name,age,position,hire_time) VALUES('Lucy',23,'dev',NOW());\n```\n\n**1.全值匹配**\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei';\n```\n![图片](/img/mysql_explain25.png)\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22;\n```\n![图片](/img/mysql_explain26.png)\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22 AND position ='manager';\n```\n![图片](/img/mysql_explain27.png)\n\n**2.最左前缀法则**\n如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = 'Bill' and age = 31;\n2 EXPLAIN SELECT * FROM employees WHERE age = 30 AND position = 'dev';\n3 EXPLAIN SELECT * FROM employees WHERE position = 'manager';\n```\n![图片](/img/mysql_explain28.png)\n\n**3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = 'LiLei';\n2 EXPLAIN SELECT * FROM employees WHERE left(name,3) = 'LiLei';\n```\n**备注：**\n<1>. LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分。LEFT(Str,length); 接收两个参数: str:一个字符串; length:想要截取的长度,是一个正整数。\n<2>.Why聚合函数索引列不能走索引?\n答：聚合函数改变了这个列的值，不能在索引树里匹配上，所以不能走索引了。\n\n![图片](/img/mysql_explain29.png)\n给hire_time增加一个普通索引：\n```\n1 ALTER TABLE `employees` ADD INDEX `idx_hire_time` (`hire_time`) USING BTREE ;\n1 EXPLAIN select * from employees where date(hire_time) ='2018‐09‐30';\n```\n![图片](/img/mysql_explain30.png)\n转化为日期范围查询，有可能会走索引：\n```\n1 EXPLAIN select * from employees where hire_time >='2018‐09‐30 00:00:00' and hire_time <='2018‐09‐30 23:59:59';\n```\n![图片](/img/mysql_explain31.png)\n还原最初索引状态\n```\n1 ALTER TABLE `employees` DROP INDEX `idx_hire_time`;\n```\n\n\n\n**4.存储引擎不能使用索引中范围条件右边的列**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22 AND position ='manage\nr';\n2 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age > 22 AND position ='manage\nr';\n```\n![图片](/img/mysql_explain32.png)\n**现象解释**：第2个sql语句name和age走了索引，position没有走索引。\n为什么？\n答：联合索引中，在此语句中，name列的值是确定的，age是范围查询，按索引树的有序性可以得知是可以走索引了，但是此时age字段不相等，不能保证position的有序性，所以不走索引。\n\n**5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句**\n```\n1 EXPLAIN SELECT name,age FROM employees WHERE name= 'LiLei' AND age = 23 AND position ='manager';\n```\n![图片](/img/mysql_explain33.png)\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 23 AND position ='manager';\n```\n![图片](/img/mysql_explain34.png)\n\n**6.mysql在使用不等于（！=或者<>），not in ，not exists 的时候无法使用索引会导致全表扫描**\n< 小于、> 大于、<=、>= 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name != 'LiLei';\n```\n![图片](/img/mysql_explain35.png)\n\n**7. is null,is not null 一般情况下也无法使用索引**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name is null\n```\n![图片](/img/mysql_explain36.png)\n\n**8. like以通配符开头（'$abc...'）mysql索引失效会变成全表扫描操作**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name like '%Lei'\n```\n![图片](/img/mysql_explain37.png)\n上图没有走索引。\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name like 'Lei%'\n```\n![图片](/img/mysql_explain38.png)\n\n**问题**：解决like'%字符串%'索引不被使用的方法？\na）使用覆盖索引，查询字段必须是建立覆盖索引字段\n```\n1 EXPLAIN SELECT name,age,position FROM employees WHERE name like '%Lei%';\n```\n![图片](/img/mysql_explain39.png)\n查询字段少一点，最好是索引树内的。\n\nb）如果不能使用覆盖索引则可能需要借助搜索引擎\n\n**9.字符串不加单引号索引失效**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = '1000';\n2 EXPLAIN SELECT * FROM employees WHERE name = 1000;\n```\n![图片](/img/mysql_explain40.png)\n备注：被比较字段和要比较的值的类型最好相同。\n\n**10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = 'LiLei' or name = 'HanMeimei';\n```\n![图片](/img/mysql_explain41.png)\n\n**11.范围查询优化给年龄添加单值索引**\n```\n1 ALTER TABLE `employees` ADD INDEX `idx_age` (`age`) USING BTREE ;\n1 explain select * from employees where age >=1 and age <=2000;\n```\n![图片](/img/mysql_explain42.png)\n**没走索引原因**：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引。\n**优化方法**：可以将大的范围拆分成多个小范围。\n\n```\n1 explain select * from employees where age >=1 and age <=1000;\n2 explain select * from employees where age >=1001 and age <=2000;\n```\n![图片](/img/mysql_explain43.png)\n还原最初索引状态\n```\n1 ALTER TABLE `employees` DROP INDEX `idx_age`;\n```\n\n**索引使用总结**：\n![图片](/img/mysql_explain44.png)\nlike KK%相当于=常量，%KK和%KK% 相当于范围\n\n```\n1 ‐‐ mysql5.7关闭ONLY_FULL_GROUP_BY报错\n2 select version(), @@sql_mode;SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Explain详解与索引最佳实践.md","raw":"---\ntitle: Explain详解与索引最佳实践\ntags:\n  - Explain执行计划\n  - 索引\n  - mysql优化实践\n  - B+树索引\n  - SQL慢查询优化\ncategories:\n  - Explain执行计划\n  - 索引\n  - SQL慢查询优化\ntop_img: /img/slow-sql.jpg\ncover: /img/slow-sql.jpg\nkeywords: Explain执行计划\ndescription: SQL慢查询优化\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\nabbrlink: 9da9fd2\ndate: 2020-08-16 21:50:18\n---\n**1. Explain使用与详解**  \n**1. Explain介绍**\n使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈\n在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会\n返回执行计划的信息，而不是执行这条SQL。\n**注意**： 如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。\n\n**Explain分析示例**\n\n```\n示例表：\n2 DROP TABLE IF EXISTS `actor`;\n3 CREATE TABLE `actor` (\n4 `id` int(11) NOT NULL,\n5 `name` varchar(45) DEFAULT NULL,\n6 `update_time` datetime DEFAULT NULL,\n7 PRIMARY KEY (`id`)\n8 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n9\n10 INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (1,'a','2017‐12‐22\n15:27:18'), (2,'b','2017‐12‐22 15:27:18'), (3,'c','2017‐12‐22 15:27:18');\n11\n12 DROP TABLE IF EXISTS `film`;\n13 CREATE TABLE `film` (\n14 `id` int(11) NOT NULL AUTO_INCREMENT,\n15 `name` varchar(10) DEFAULT NULL,\n16 PRIMARY KEY (`id`),\n17 KEY `idx_name` (`name`)\n18 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n19\n20 INSERT INTO `film` (`id`, `name`) VALUES (3,'film0'),(1,'film1'),(2,'film2');\n21\n22 DROP TABLE IF EXISTS `film_actor`;\n23 CREATE TABLE `film_actor` (\n24 `id` int(11) NOT NULL,\n25 `film_id` int(11) NOT NULL,\n26 `actor_id` int(11) NOT NULL,\n27 `remark` varchar(255) DEFAULT NULL,\n28 PRIMARY KEY (`id`),\n29 KEY `idx_film_actor_id` (`film_id`,`actor_id`)\n30 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n31\n32 INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (1,1,1),(2,1,2),(3,2,1);\n```\n\n\n```\nmysql> explain select * from actor;\n```\n\n![图片](/img/mysql_explain1.png)\n在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。\n\n**explain 两个变种**\n**1）explain extended**：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。\n\n```\n1 mysql> explain extended select * from film where id = 1;\n```\n![图片](/img/mysql_explain2.png)\n\n```\n1 mysql> show warnings;\n```\n![图片](/img/mysql_explain3.png)\n\n\n**2）explain partitions**：相比 explain 多了个 partitions字段，如果查询是基于分区表\n的话，会显示查询将访问的分区。\n\n\n### **explain中的列**\n接下来我们将展示 explain 中每个列的信息。\n\n**1. id列**\nid列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。\nid列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。\n举例： id有1,2,3，则id为3的执行优先级最高。\n\n**2. select_type列**\nselect_type 表示对应行是简单还是复杂的查询。\n\n1）simple：简单查询。查询不包含子查询和union。\n\n```\n1 mysql> explain select * from film where id = 2;\n```\n![图片](/img/mysql_explain4.png)\n2）primary：复杂查询中最外层的 select。\n3）subquery：包含在 select 中的子查询（不在 from 子句中）。\n4）derived：衍生查询。包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）。\n用这个例子来了解 primary、subquery 和 derived 类型\n\n\n```\n1 mysql> set session optimizer_switch='derived_merge=off'; #关闭mysql5.7新特性对衍生表的合\n并优化\n2 mysql> explain select (select 1 from actor where id = 1) from (select * from film where\nid = 1) der;\n```\n![图片](/img/mysql_explain5.png)\n\n\n```\n1 mysql> set session optimizer_switch='derived_merge=on'; #还原默认配置\n```\n5）union：在 union 中的第二个和随后的 select\n\n```\n1 mysql> explain select 1 union all select 1;\n```\n![图片](/img/mysql_explain6.png)\n\n**3. table列**\n这一列表示 explain 的一行正在访问哪个表。\n当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。\n当有 union 时，UNION RESULT 的 table 列的值为<union1,2>，1和2表示参与 union 的 select 行id。\n\n**4. type列**\n这一列表示**关联类型或访问类型**，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。\n依次从最优到最差分别为：**system > const > eq_ref > ref > range > index > ALL(全局)**\n一般来说，**得保证查询达到range级别，最好达到ref**。\n\n**NULL**：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。如下：\n```\n1 mysql> explain select min(id) from film;\n```\n![图片](/img/mysql_explain7.png)\n\n**const, system**：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。const通俗点就是说和查询一个常量一样很快。用于primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。**system是const的特例**，表里只有一条元组匹配时为system。\n```\n1 mysql> explain extended select * from (select * from film where id = 1) tmp;\n```\n![图片](/img/mysql_explain8.png)\n```\n1 mysql> show warnings;\n```\n![图片](/img/mysql_explain9.png)\n\n**eq_ref**：primary key(主键) 或 unique key(唯一键) 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。如下：\n```\n1 mysql> explain select * from film_actor left join film on film_actor.film_id = film.id;\n```\n![图片](/img/mysql_explain10.png)\n\n**ref**：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n1. 简单 select 查询，name是普通索引（非唯一索引）\n```\n1 mysql> explain select * from film where name = 'film1';\n```\n![图片](/img/mysql_explain11.png)\n\n2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。如下：\n```\n1 mysql> explain select film_id from film left join film_actor on film.id = film_actor.film_id;\n```\n![图片](/img/mysql_explain12.png)\n\n**range**：范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。\n\n```\n1 mysql> explain select * from actor where id > 1;\n```\n![图片](/img/mysql_explain13.png)\n\n\n**index**：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。如下：\n```\n1 mysql> explain select * from film;\n```\n![图片](/img/mysql_explain14.png)\n\n\n**ALL**：即全表扫描，扫描你的聚簇索引的所有叶子节点。**通常情况下这需要增加索引来进行优化了**。如下：\n```\n1 mysql> explain select * from actor;\n```\n![图片](/img/mysql_explain15.png)\n\n**5. possible_keys列**\n这一列显示查询**可能使用**哪些索引来查找。\nexplain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引\n对此查询帮助不大，选择了全表查询。\n如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提\n高查询性能，然后用 explain 查看效果。\n\n**6. key列**\n这一列显示mysql**实际采用**哪个索引来优化对该表的访问。\n如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，\n在查询中使用 force index、ignore index。\n\n**7. key_len列**\n这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。\n举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。\n\n\n```\n1 mysql> explain select * from film_actor where film_id = 2;\n```\n![图片](/img/mysql_explain16.png)\n**key_len计算规则如下：**\n- 字符串，char(n)和varchar(n)，5.0.3以后版本中，**n均代表字符数，而不是字节数**，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节。\n  -  char(n)：如果存汉字长度就是 3n 字节。\n  -  varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为\nvarchar是变长字符串。\n\n- 数值类型\n  -  tinyint：1字节\n  -  smallint：2字节\n  -  int：4字节\n  -  bigint：8字节\n  -  \n- 时间类型\n  -  date：3字节\n  -  timestamp：4字节\n  -  datetime：8字节\n\n- 如果字段允许为 NULL，需要1字节记录是否为 NULL\n\n索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。\n\n**8. ref列**\n这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）\n\n**9. rows列**\n这一列是mysql估计要读取并检测的行数，**注意**这个不是结果集里的行数。\n\n**10. Extra列**\n这一列展示的是额外信息。常见的重要值如下：\n**1）Using index**：使用覆盖索引。\n**覆盖索引定义**：覆盖索引并不是一种索引，它是一种查询的方式，表示所查询的字段在索引树里都包含了。mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。如下：film_id在索引树里包含了。\n```\n1 mysql> explain select film_id from film_actor where film_id = 1;\n```\n![图片](/img/mysql_explain17.png)\n\n**2）Using where**：使用 where 语句来处理结果，并且查询的列未被索引覆盖。\n```\n1 mysql> explain select * from film_actor where film_id > 1;\n```\n![图片](/img/mysql_explain18.png)\n\n**3）Using index condition**：查询的列不完全被索引覆盖，where条件中是一个前导列的范围。\n```\n1 mysql> explain select * from film_actor where film_id > 1;\n```\n![图片](/img/mysql_explain19.png)\n\n\n**4）Using temporary**：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。\n\n1. actor.name没有索引，此时创建了张临时表来distinct。\n```\n1 mysql> explain select distinct name from actor;\n```\n![图片](/img/mysql_explain20.png)\n\n2. film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表。\n```\n1 mysql> explain select distinct name from film;\n```\n![图片](/img/mysql_explain21.png)\n\n**5）Using filesort**：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。\n\n1. actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。\n```\n1 mysql> explain select * from actor order by name;\n```\n![图片](/img/mysql_explain22.png)\n\n2. film.name建立了idx_name索引,此时查询时extra是using index。\n```\n1 mysql> explain select * from film order by name;\n```\n![图片](/img/mysql_explain23.png)\n\n**6）Select tables optimized away**：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时。\n```\n1 mysql> explain select min(id) from film;\n```\n![图片](/img/mysql_explain24.png)\n\n\n### **索引最佳实践**\n```\n示例表：\n2 CREATE TABLE `employees` (\n3 `id` int(11) NOT NULL AUTO_INCREMENT,\n4 `name` varchar(24) NOT NULL DEFAULT '' COMMENT '姓名',\n5 `age` int(11) NOT NULL DEFAULT '0' COMMENT '年龄',\n6 `position` varchar(20) NOT NULL DEFAULT '' COMMENT '职位',\n7 `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '入职时间',\n8 PRIMARY KEY (`id`),\n9 KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE\n10 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='员工记录表';\n11\n12 INSERT INTO employees(name,age,position,hire_time) VALUES('LiLei',22,'manager',NOW());\n13 INSERT INTO employees(name,age,position,hire_time) VALUES('HanMeimei',\n23,'dev',NOW());\n14 INSERT INTO employees(name,age,position,hire_time) VALUES('Lucy',23,'dev',NOW());\n```\n\n**1.全值匹配**\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei';\n```\n![图片](/img/mysql_explain25.png)\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22;\n```\n![图片](/img/mysql_explain26.png)\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22 AND position ='manager';\n```\n![图片](/img/mysql_explain27.png)\n\n**2.最左前缀法则**\n如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = 'Bill' and age = 31;\n2 EXPLAIN SELECT * FROM employees WHERE age = 30 AND position = 'dev';\n3 EXPLAIN SELECT * FROM employees WHERE position = 'manager';\n```\n![图片](/img/mysql_explain28.png)\n\n**3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = 'LiLei';\n2 EXPLAIN SELECT * FROM employees WHERE left(name,3) = 'LiLei';\n```\n**备注：**\n<1>. LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分。LEFT(Str,length); 接收两个参数: str:一个字符串; length:想要截取的长度,是一个正整数。\n<2>.Why聚合函数索引列不能走索引?\n答：聚合函数改变了这个列的值，不能在索引树里匹配上，所以不能走索引了。\n\n![图片](/img/mysql_explain29.png)\n给hire_time增加一个普通索引：\n```\n1 ALTER TABLE `employees` ADD INDEX `idx_hire_time` (`hire_time`) USING BTREE ;\n1 EXPLAIN select * from employees where date(hire_time) ='2018‐09‐30';\n```\n![图片](/img/mysql_explain30.png)\n转化为日期范围查询，有可能会走索引：\n```\n1 EXPLAIN select * from employees where hire_time >='2018‐09‐30 00:00:00' and hire_time <='2018‐09‐30 23:59:59';\n```\n![图片](/img/mysql_explain31.png)\n还原最初索引状态\n```\n1 ALTER TABLE `employees` DROP INDEX `idx_hire_time`;\n```\n\n\n\n**4.存储引擎不能使用索引中范围条件右边的列**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 22 AND position ='manage\nr';\n2 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age > 22 AND position ='manage\nr';\n```\n![图片](/img/mysql_explain32.png)\n**现象解释**：第2个sql语句name和age走了索引，position没有走索引。\n为什么？\n答：联合索引中，在此语句中，name列的值是确定的，age是范围查询，按索引树的有序性可以得知是可以走索引了，但是此时age字段不相等，不能保证position的有序性，所以不走索引。\n\n**5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句**\n```\n1 EXPLAIN SELECT name,age FROM employees WHERE name= 'LiLei' AND age = 23 AND position ='manager';\n```\n![图片](/img/mysql_explain33.png)\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name= 'LiLei' AND age = 23 AND position ='manager';\n```\n![图片](/img/mysql_explain34.png)\n\n**6.mysql在使用不等于（！=或者<>），not in ，not exists 的时候无法使用索引会导致全表扫描**\n< 小于、> 大于、<=、>= 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name != 'LiLei';\n```\n![图片](/img/mysql_explain35.png)\n\n**7. is null,is not null 一般情况下也无法使用索引**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name is null\n```\n![图片](/img/mysql_explain36.png)\n\n**8. like以通配符开头（'$abc...'）mysql索引失效会变成全表扫描操作**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name like '%Lei'\n```\n![图片](/img/mysql_explain37.png)\n上图没有走索引。\n\n```\n1 EXPLAIN SELECT * FROM employees WHERE name like 'Lei%'\n```\n![图片](/img/mysql_explain38.png)\n\n**问题**：解决like'%字符串%'索引不被使用的方法？\na）使用覆盖索引，查询字段必须是建立覆盖索引字段\n```\n1 EXPLAIN SELECT name,age,position FROM employees WHERE name like '%Lei%';\n```\n![图片](/img/mysql_explain39.png)\n查询字段少一点，最好是索引树内的。\n\nb）如果不能使用覆盖索引则可能需要借助搜索引擎\n\n**9.字符串不加单引号索引失效**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = '1000';\n2 EXPLAIN SELECT * FROM employees WHERE name = 1000;\n```\n![图片](/img/mysql_explain40.png)\n备注：被比较字段和要比较的值的类型最好相同。\n\n**10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化**\n```\n1 EXPLAIN SELECT * FROM employees WHERE name = 'LiLei' or name = 'HanMeimei';\n```\n![图片](/img/mysql_explain41.png)\n\n**11.范围查询优化给年龄添加单值索引**\n```\n1 ALTER TABLE `employees` ADD INDEX `idx_age` (`age`) USING BTREE ;\n1 explain select * from employees where age >=1 and age <=2000;\n```\n![图片](/img/mysql_explain42.png)\n**没走索引原因**：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引。\n**优化方法**：可以将大的范围拆分成多个小范围。\n\n```\n1 explain select * from employees where age >=1 and age <=1000;\n2 explain select * from employees where age >=1001 and age <=2000;\n```\n![图片](/img/mysql_explain43.png)\n还原最初索引状态\n```\n1 ALTER TABLE `employees` DROP INDEX `idx_age`;\n```\n\n**索引使用总结**：\n![图片](/img/mysql_explain44.png)\nlike KK%相当于=常量，%KK和%KK% 相当于范围\n\n```\n1 ‐‐ mysql5.7关闭ONLY_FULL_GROUP_BY报错\n2 select version(), @@sql_mode;SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Explain详解与索引最佳实践","published":1,"updated":"2023-09-02T16:50:34.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm29i99s000s88th11sj2a0g","content":"<p><strong>1. Explain使用与详解</strong><br><strong>1. Explain介绍</strong><br>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈<br>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会<br>返回执行计划的信息，而不是执行这条SQL。<br><strong>注意</strong>： 如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。</p>\n<p><strong>Explain分析示例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例表：</span><br><span class=\"line\">2 DROP TABLE IF EXISTS `actor`;</span><br><span class=\"line\">3 CREATE TABLE `actor` (</span><br><span class=\"line\">4 `id` int(11) NOT NULL,</span><br><span class=\"line\">5 `name` varchar(45) DEFAULT NULL,</span><br><span class=\"line\">6 `update_time` datetime DEFAULT NULL,</span><br><span class=\"line\">7 PRIMARY KEY (`id`)</span><br><span class=\"line\">8 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\">9</span><br><span class=\"line\">10 INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (1,&#x27;a&#x27;,&#x27;2017‐12‐22</span><br><span class=\"line\">15:27:18&#x27;), (2,&#x27;b&#x27;,&#x27;2017‐12‐22 15:27:18&#x27;), (3,&#x27;c&#x27;,&#x27;2017‐12‐22 15:27:18&#x27;);</span><br><span class=\"line\">11</span><br><span class=\"line\">12 DROP TABLE IF EXISTS `film`;</span><br><span class=\"line\">13 CREATE TABLE `film` (</span><br><span class=\"line\">14 `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">15 `name` varchar(10) DEFAULT NULL,</span><br><span class=\"line\">16 PRIMARY KEY (`id`),</span><br><span class=\"line\">17 KEY `idx_name` (`name`)</span><br><span class=\"line\">18 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\">19</span><br><span class=\"line\">20 INSERT INTO `film` (`id`, `name`) VALUES (3,&#x27;film0&#x27;),(1,&#x27;film1&#x27;),(2,&#x27;film2&#x27;);</span><br><span class=\"line\">21</span><br><span class=\"line\">22 DROP TABLE IF EXISTS `film_actor`;</span><br><span class=\"line\">23 CREATE TABLE `film_actor` (</span><br><span class=\"line\">24 `id` int(11) NOT NULL,</span><br><span class=\"line\">25 `film_id` int(11) NOT NULL,</span><br><span class=\"line\">26 `actor_id` int(11) NOT NULL,</span><br><span class=\"line\">27 `remark` varchar(255) DEFAULT NULL,</span><br><span class=\"line\">28 PRIMARY KEY (`id`),</span><br><span class=\"line\">29 KEY `idx_film_actor_id` (`film_id`,`actor_id`)</span><br><span class=\"line\">30 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\">31</span><br><span class=\"line\">32 INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (1,1,1),(2,1,2),(3,2,1);</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from actor;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/mysql_explain1.png\" alt=\"图片\"><br>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。</p>\n<p><strong>explain 两个变种</strong><br><strong>1）explain extended</strong>：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered&#x2F;100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain extended select * from film where id = 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain2.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; show warnings;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain3.png\" alt=\"图片\"></p>\n<p><strong>2）explain partitions</strong>：相比 explain 多了个 partitions字段，如果查询是基于分区表<br>的话，会显示查询将访问的分区。</p>\n<h3 id=\"explain中的列\"><a href=\"#explain中的列\" class=\"headerlink\" title=\"explain中的列\"></a><strong>explain中的列</strong></h3><p>接下来我们将展示 explain 中每个列的信息。</p>\n<p><strong>1. id列</strong><br>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。<br>举例： id有1,2,3，则id为3的执行优先级最高。</p>\n<p><strong>2. select_type列</strong><br>select_type 表示对应行是简单还是复杂的查询。</p>\n<p>1）simple：简单查询。查询不包含子查询和union。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film where id = 2;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain4.png\" alt=\"图片\"><br>2）primary：复杂查询中最外层的 select。<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）。<br>4）derived：衍生查询。包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）。<br>用这个例子来了解 primary、subquery 和 derived 类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合</span><br><span class=\"line\">并优化</span><br><span class=\"line\">2 mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where</span><br><span class=\"line\">id = 1) der;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain5.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置</span><br></pre></td></tr></table></figure>\n<p>5）union：在 union 中的第二个和随后的 select</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select 1 union all select 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain6.png\" alt=\"图片\"></p>\n<p><strong>3. table列</strong><br>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>\n<p><strong>4. type列</strong><br>这一列表示<strong>关联类型或访问类型</strong>，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL(全局)</strong><br>一般来说，<strong>得保证查询达到range级别，最好达到ref</strong>。</p>\n<p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain7.png\" alt=\"图片\"></p>\n<p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。const通俗点就是说和查询一个常量一样很快。用于primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<strong>system是const的特例</strong>，表里只有一条元组匹配时为system。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain8.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; show warnings;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain9.png\" alt=\"图片\"></p>\n<p><strong>eq_ref</strong>：primary key(主键) 或 unique key(唯一键) 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain10.png\" alt=\"图片\"></p>\n<p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>\n<ol>\n<li>简单 select 查询，name是普通索引（非唯一索引）<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film where name = &#x27;film1&#x27;;</span><br></pre></td></tr></table></figure>\n<img src=\"/img/mysql_explain11.png\" alt=\"图片\"></li>\n</ol>\n<p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain12.png\" alt=\"图片\"></p>\n<p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from actor where id &gt; 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain13.png\" alt=\"图片\"></p>\n<p><strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain14.png\" alt=\"图片\"></p>\n<p><strong>ALL</strong>：即全表扫描，扫描你的聚簇索引的所有叶子节点。<strong>通常情况下这需要增加索引来进行优化了</strong>。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from actor;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain15.png\" alt=\"图片\"></p>\n<p><strong>5. possible_keys列</strong><br>这一列显示查询<strong>可能使用</strong>哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引<br>对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提<br>高查询性能，然后用 explain 查看效果。</p>\n<p><strong>6. key列</strong><br>这一列显示mysql<strong>实际采用</strong>哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，<br>在查询中使用 force index、ignore index。</p>\n<p><strong>7. key_len列</strong><br>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor where film_id = 2;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain16.png\" alt=\"图片\"><br><strong>key_len计算规则如下：</strong></p>\n<ul>\n<li><p>字符串，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数</strong>，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节。</p>\n<ul>\n<li>char(n)：如果存汉字长度就是 3n 字节。</li>\n<li>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为<br>varchar是变长字符串。</li>\n</ul>\n</li>\n<li><h2 id=\"数值类型-tinyint：1字节-smallint：2字节-int：4字节-bigint：8字节\"><a href=\"#数值类型-tinyint：1字节-smallint：2字节-int：4字节-bigint：8字节\" class=\"headerlink\" title=\"数值类型-  tinyint：1字节-  smallint：2字节-  int：4字节-  bigint：8字节\"></a>数值类型<br>-  tinyint：1字节<br>-  smallint：2字节<br>-  int：4字节<br>-  bigint：8字节</h2></li>\n<li><p>时间类型</p>\n<ul>\n<li>date：3字节</li>\n<li>timestamp：4字节</li>\n<li>datetime：8字节</li>\n</ul>\n</li>\n<li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p>\n</li>\n</ul>\n<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>\n<p><strong>8. ref列</strong><br>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>\n<p><strong>9. rows列</strong><br>这一列是mysql估计要读取并检测的行数，<strong>注意</strong>这个不是结果集里的行数。</p>\n<p><strong>10. Extra列</strong><br>这一列展示的是额外信息。常见的重要值如下：<br><strong>1）Using index</strong>：使用覆盖索引。<br><strong>覆盖索引定义</strong>：覆盖索引并不是一种索引，它是一种查询的方式，表示所查询的字段在索引树里都包含了。mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。如下：film_id在索引树里包含了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select film_id from film_actor where film_id = 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain17.png\" alt=\"图片\"></p>\n<p><strong>2）Using where</strong>：使用 where 语句来处理结果，并且查询的列未被索引覆盖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor where film_id &gt; 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain18.png\" alt=\"图片\"></p>\n<p><strong>3）Using index condition</strong>：查询的列不完全被索引覆盖，where条件中是一个前导列的范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor where film_id &gt; 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain19.png\" alt=\"图片\"></p>\n<p><strong>4）Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>\n<ol>\n<li><p>actor.name没有索引，此时创建了张临时表来distinct。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select distinct name from actor;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain20.png\" alt=\"图片\"></p>\n</li>\n<li><p>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select distinct name from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain21.png\" alt=\"图片\"></p>\n</li>\n</ol>\n<p><strong>5）Using filesort</strong>：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p>\n<ol>\n<li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from actor order by name;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain22.png\" alt=\"图片\"></p>\n</li>\n<li><p>film.name建立了idx_name索引,此时查询时extra是using index。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film order by name;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain23.png\" alt=\"图片\"></p>\n</li>\n</ol>\n<p><strong>6）Select tables optimized away</strong>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain24.png\" alt=\"图片\"></p>\n<h3 id=\"索引最佳实践\"><a href=\"#索引最佳实践\" class=\"headerlink\" title=\"索引最佳实践\"></a><strong>索引最佳实践</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例表：</span><br><span class=\"line\">2 CREATE TABLE `employees` (</span><br><span class=\"line\">3 `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">4 `name` varchar(24) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class=\"line\">5 `age` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,</span><br><span class=\"line\">6 `position` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class=\"line\">7 `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;,</span><br><span class=\"line\">8 PRIMARY KEY (`id`),</span><br><span class=\"line\">9 KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE</span><br><span class=\"line\">10 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工记录表&#x27;;</span><br><span class=\"line\">11</span><br><span class=\"line\">12 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;LiLei&#x27;,22,&#x27;manager&#x27;,NOW());</span><br><span class=\"line\">13 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;HanMeimei&#x27;,</span><br><span class=\"line\">23,&#x27;dev&#x27;,NOW());</span><br><span class=\"line\">14 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;Lucy&#x27;,23,&#x27;dev&#x27;,NOW());</span><br></pre></td></tr></table></figure>\n\n<p><strong>1.全值匹配</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain25.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain26.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain27.png\" alt=\"图片\"></p>\n<p><strong>2.最左前缀法则</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;Bill&#x27; and age = 31;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE age = 30 AND position = &#x27;dev&#x27;;</span><br><span class=\"line\">3 EXPLAIN SELECT * FROM employees WHERE position = &#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain28.png\" alt=\"图片\"></p>\n<p><strong>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27;;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE left(name,3) = &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><strong>备注：</strong><br>&lt;1&gt;. LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分。LEFT(Str,length); 接收两个参数: str:一个字符串; length:想要截取的长度,是一个正整数。<br>&lt;2&gt;.Why聚合函数索引列不能走索引?<br>答：聚合函数改变了这个列的值，不能在索引树里匹配上，所以不能走索引了。</p>\n<p><img src=\"/img/mysql_explain29.png\" alt=\"图片\"><br>给hire_time增加一个普通索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` ADD INDEX `idx_hire_time` (`hire_time`) USING BTREE ;</span><br><span class=\"line\">1 EXPLAIN select * from employees where date(hire_time) =&#x27;2018‐09‐30&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain30.png\" alt=\"图片\"><br>转化为日期范围查询，有可能会走索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN select * from employees where hire_time &gt;=&#x27;2018‐09‐30 00:00:00&#x27; and hire_time &lt;=&#x27;2018‐09‐30 23:59:59&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain31.png\" alt=\"图片\"><br>还原最初索引状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` DROP INDEX `idx_hire_time`;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>4.存储引擎不能使用索引中范围条件右边的列</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manage</span><br><span class=\"line\">r&#x27;;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age &gt; 22 AND position =&#x27;manage</span><br><span class=\"line\">r&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain32.png\" alt=\"图片\"><br><strong>现象解释</strong>：第2个sql语句name和age走了索引，position没有走索引。<br>为什么？<br>答：联合索引中，在此语句中，name列的值是确定的，age是范围查询，按索引树的有序性可以得知是可以走索引了，但是此时age字段不相等，不能保证position的有序性，所以不走索引。</p>\n<p><strong>5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT name,age FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain33.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain34.png\" alt=\"图片\"></p>\n<p><strong>6.mysql在使用不等于（！&#x3D;或者&lt;&gt;），not in ，not exists 的时候无法使用索引会导致全表扫描</strong><br>&lt; 小于、&gt; 大于、&lt;&#x3D;、&gt;&#x3D; 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name != &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain35.png\" alt=\"图片\"></p>\n<p><strong>7. is null,is not null 一般情况下也无法使用索引</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name is null</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain36.png\" alt=\"图片\"></p>\n<p><strong>8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name like &#x27;%Lei&#x27;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain37.png\" alt=\"图片\"><br>上图没有走索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name like &#x27;Lei%&#x27;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain38.png\" alt=\"图片\"></p>\n<p><strong>问题</strong>：解决like’%字符串%’索引不被使用的方法？<br>a）使用覆盖索引，查询字段必须是建立覆盖索引字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT name,age,position FROM employees WHERE name like &#x27;%Lei%&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain39.png\" alt=\"图片\"><br>查询字段少一点，最好是索引树内的。</p>\n<p>b）如果不能使用覆盖索引则可能需要借助搜索引擎</p>\n<p><strong>9.字符串不加单引号索引失效</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;1000&#x27;;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE name = 1000;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain40.png\" alt=\"图片\"><br>备注：被比较字段和要比较的值的类型最好相同。</p>\n<p><strong>10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27; or name = &#x27;HanMeimei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain41.png\" alt=\"图片\"></p>\n<p><strong>11.范围查询优化给年龄添加单值索引</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` ADD INDEX `idx_age` (`age`) USING BTREE ;</span><br><span class=\"line\">1 explain select * from employees where age &gt;=1 and age &lt;=2000;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain42.png\" alt=\"图片\"><br><strong>没走索引原因</strong>：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引。<br><strong>优化方法</strong>：可以将大的范围拆分成多个小范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 explain select * from employees where age &gt;=1 and age &lt;=1000;</span><br><span class=\"line\">2 explain select * from employees where age &gt;=1001 and age &lt;=2000;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain43.png\" alt=\"图片\"><br>还原最初索引状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` DROP INDEX `idx_age`;</span><br></pre></td></tr></table></figure>\n\n<p><strong>索引使用总结</strong>：<br><img src=\"/img/mysql_explain44.png\" alt=\"图片\"><br>like KK%相当于&#x3D;常量，%KK和%KK% 相当于范围</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ‐‐ mysql5.7关闭ONLY_FULL_GROUP_BY报错</span><br><span class=\"line\">2 select version(), @@sql_mode;SET sql_mode=(SELECT REPLACE(@@sql_mode,&#x27;ONLY_FULL_GROUP_BY&#x27;,&#x27;&#x27;));</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover_type":"img","excerpt":"","more":"<p><strong>1. Explain使用与详解</strong><br><strong>1. Explain介绍</strong><br>使用EXPLAIN关键字可以模拟优化器执行SQL语句，分析你的查询语句或是结构的性能瓶颈<br>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询会<br>返回执行计划的信息，而不是执行这条SQL。<br><strong>注意</strong>： 如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中。</p>\n<p><strong>Explain分析示例</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例表：</span><br><span class=\"line\">2 DROP TABLE IF EXISTS `actor`;</span><br><span class=\"line\">3 CREATE TABLE `actor` (</span><br><span class=\"line\">4 `id` int(11) NOT NULL,</span><br><span class=\"line\">5 `name` varchar(45) DEFAULT NULL,</span><br><span class=\"line\">6 `update_time` datetime DEFAULT NULL,</span><br><span class=\"line\">7 PRIMARY KEY (`id`)</span><br><span class=\"line\">8 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\">9</span><br><span class=\"line\">10 INSERT INTO `actor` (`id`, `name`, `update_time`) VALUES (1,&#x27;a&#x27;,&#x27;2017‐12‐22</span><br><span class=\"line\">15:27:18&#x27;), (2,&#x27;b&#x27;,&#x27;2017‐12‐22 15:27:18&#x27;), (3,&#x27;c&#x27;,&#x27;2017‐12‐22 15:27:18&#x27;);</span><br><span class=\"line\">11</span><br><span class=\"line\">12 DROP TABLE IF EXISTS `film`;</span><br><span class=\"line\">13 CREATE TABLE `film` (</span><br><span class=\"line\">14 `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">15 `name` varchar(10) DEFAULT NULL,</span><br><span class=\"line\">16 PRIMARY KEY (`id`),</span><br><span class=\"line\">17 KEY `idx_name` (`name`)</span><br><span class=\"line\">18 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\">19</span><br><span class=\"line\">20 INSERT INTO `film` (`id`, `name`) VALUES (3,&#x27;film0&#x27;),(1,&#x27;film1&#x27;),(2,&#x27;film2&#x27;);</span><br><span class=\"line\">21</span><br><span class=\"line\">22 DROP TABLE IF EXISTS `film_actor`;</span><br><span class=\"line\">23 CREATE TABLE `film_actor` (</span><br><span class=\"line\">24 `id` int(11) NOT NULL,</span><br><span class=\"line\">25 `film_id` int(11) NOT NULL,</span><br><span class=\"line\">26 `actor_id` int(11) NOT NULL,</span><br><span class=\"line\">27 `remark` varchar(255) DEFAULT NULL,</span><br><span class=\"line\">28 PRIMARY KEY (`id`),</span><br><span class=\"line\">29 KEY `idx_film_actor_id` (`film_id`,`actor_id`)</span><br><span class=\"line\">30 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class=\"line\">31</span><br><span class=\"line\">32 INSERT INTO `film_actor` (`id`, `film_id`, `actor_id`) VALUES (1,1,1),(2,1,2),(3,2,1);</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; explain select * from actor;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/mysql_explain1.png\" alt=\"图片\"><br>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行。</p>\n<p><strong>explain 两个变种</strong><br><strong>1）explain extended</strong>：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered&#x2F;100 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain extended select * from film where id = 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain2.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; show warnings;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain3.png\" alt=\"图片\"></p>\n<p><strong>2）explain partitions</strong>：相比 explain 多了个 partitions字段，如果查询是基于分区表<br>的话，会显示查询将访问的分区。</p>\n<h3 id=\"explain中的列\"><a href=\"#explain中的列\" class=\"headerlink\" title=\"explain中的列\"></a><strong>explain中的列</strong></h3><p>接下来我们将展示 explain 中每个列的信息。</p>\n<p><strong>1. id列</strong><br>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。<br>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。<br>举例： id有1,2,3，则id为3的执行优先级最高。</p>\n<p><strong>2. select_type列</strong><br>select_type 表示对应行是简单还是复杂的查询。</p>\n<p>1）simple：简单查询。查询不包含子查询和union。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film where id = 2;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain4.png\" alt=\"图片\"><br>2）primary：复杂查询中最外层的 select。<br>3）subquery：包含在 select 中的子查询（不在 from 子句中）。<br>4）derived：衍生查询。包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义）。<br>用这个例子来了解 primary、subquery 和 derived 类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=off&#x27;; #关闭mysql5.7新特性对衍生表的合</span><br><span class=\"line\">并优化</span><br><span class=\"line\">2 mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where</span><br><span class=\"line\">id = 1) der;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain5.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; set session optimizer_switch=&#x27;derived_merge=on&#x27;; #还原默认配置</span><br></pre></td></tr></table></figure>\n<p>5）union：在 union 中的第二个和随后的 select</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select 1 union all select 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain6.png\" alt=\"图片\"></p>\n<p><strong>3. table列</strong><br>这一列表示 explain 的一行正在访问哪个表。<br>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。<br>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>\n<p><strong>4. type列</strong><br>这一列表示<strong>关联类型或访问类型</strong>，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL(全局)</strong><br>一般来说，<strong>得保证查询达到range级别，最好达到ref</strong>。</p>\n<p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain7.png\" alt=\"图片\"></p>\n<p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。const通俗点就是说和查询一个常量一样很快。用于primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。<strong>system是const的特例</strong>，表里只有一条元组匹配时为system。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain extended select * from (select * from film where id = 1) tmp;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain8.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; show warnings;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain9.png\" alt=\"图片\"></p>\n<p><strong>eq_ref</strong>：primary key(主键) 或 unique key(唯一键) 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain10.png\" alt=\"图片\"></p>\n<p><strong>ref</strong>：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>\n<ol>\n<li>简单 select 查询，name是普通索引（非唯一索引）<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film where name = &#x27;film1&#x27;;</span><br></pre></td></tr></table></figure>\n<img src=\"/img/mysql_explain11.png\" alt=\"图片\"></li>\n</ol>\n<p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain12.png\" alt=\"图片\"></p>\n<p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from actor where id &gt; 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain13.png\" alt=\"图片\"></p>\n<p><strong>index</strong>：扫描全索引就能拿到结果，一般是扫描某个二级索引，这种扫描不会从索引树根节点开始快速查找，而是直接对二级索引的叶子节点遍历和扫描，速度还是比较慢的，这种查询一般为使用覆盖索引，二级索引一般比较小，所以这种通常比ALL快一些。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain14.png\" alt=\"图片\"></p>\n<p><strong>ALL</strong>：即全表扫描，扫描你的聚簇索引的所有叶子节点。<strong>通常情况下这需要增加索引来进行优化了</strong>。如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from actor;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain15.png\" alt=\"图片\"></p>\n<p><strong>5. possible_keys列</strong><br>这一列显示查询<strong>可能使用</strong>哪些索引来查找。<br>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引<br>对此查询帮助不大，选择了全表查询。<br>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提<br>高查询性能，然后用 explain 查看效果。</p>\n<p><strong>6. key列</strong><br>这一列显示mysql<strong>实际采用</strong>哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，<br>在查询中使用 force index、ignore index。</p>\n<p><strong>7. key_len列</strong><br>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。<br>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor where film_id = 2;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain16.png\" alt=\"图片\"><br><strong>key_len计算规则如下：</strong></p>\n<ul>\n<li><p>字符串，char(n)和varchar(n)，5.0.3以后版本中，<strong>n均代表字符数，而不是字节数</strong>，如果是utf-8，一个数字或字母占1个字节，一个汉字占3个字节。</p>\n<ul>\n<li>char(n)：如果存汉字长度就是 3n 字节。</li>\n<li>varchar(n)：如果存汉字则长度是 3n + 2 字节，加的2字节用来存储字符串长度，因为<br>varchar是变长字符串。</li>\n</ul>\n</li>\n<li><h2 id=\"数值类型-tinyint：1字节-smallint：2字节-int：4字节-bigint：8字节\"><a href=\"#数值类型-tinyint：1字节-smallint：2字节-int：4字节-bigint：8字节\" class=\"headerlink\" title=\"数值类型-  tinyint：1字节-  smallint：2字节-  int：4字节-  bigint：8字节\"></a>数值类型<br>-  tinyint：1字节<br>-  smallint：2字节<br>-  int：4字节<br>-  bigint：8字节</h2></li>\n<li><p>时间类型</p>\n<ul>\n<li>date：3字节</li>\n<li>timestamp：4字节</li>\n<li>datetime：8字节</li>\n</ul>\n</li>\n<li><p>如果字段允许为 NULL，需要1字节记录是否为 NULL</p>\n</li>\n</ul>\n<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>\n<p><strong>8. ref列</strong><br>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>\n<p><strong>9. rows列</strong><br>这一列是mysql估计要读取并检测的行数，<strong>注意</strong>这个不是结果集里的行数。</p>\n<p><strong>10. Extra列</strong><br>这一列展示的是额外信息。常见的重要值如下：<br><strong>1）Using index</strong>：使用覆盖索引。<br><strong>覆盖索引定义</strong>：覆盖索引并不是一种索引，它是一种查询的方式，表示所查询的字段在索引树里都包含了。mysql执行计划explain结果里的key有使用索引，如果select后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra里一般都有using index；覆盖索引一般针对的是辅助索引，整个查询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。如下：film_id在索引树里包含了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select film_id from film_actor where film_id = 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain17.png\" alt=\"图片\"></p>\n<p><strong>2）Using where</strong>：使用 where 语句来处理结果，并且查询的列未被索引覆盖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor where film_id &gt; 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain18.png\" alt=\"图片\"></p>\n<p><strong>3）Using index condition</strong>：查询的列不完全被索引覆盖，where条件中是一个前导列的范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film_actor where film_id &gt; 1;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain19.png\" alt=\"图片\"></p>\n<p><strong>4）Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>\n<ol>\n<li><p>actor.name没有索引，此时创建了张临时表来distinct。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select distinct name from actor;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain20.png\" alt=\"图片\"></p>\n</li>\n<li><p>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select distinct name from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain21.png\" alt=\"图片\"></p>\n</li>\n</ol>\n<p><strong>5）Using filesort</strong>：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。</p>\n<ol>\n<li><p>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from actor order by name;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain22.png\" alt=\"图片\"></p>\n</li>\n<li><p>film.name建立了idx_name索引,此时查询时extra是using index。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select * from film order by name;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain23.png\" alt=\"图片\"></p>\n</li>\n</ol>\n<p><strong>6）Select tables optimized away</strong>：使用某些聚合函数（比如 max、min）来访问存在索引的某个字段时。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 mysql&gt; explain select min(id) from film;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain24.png\" alt=\"图片\"></p>\n<h3 id=\"索引最佳实践\"><a href=\"#索引最佳实践\" class=\"headerlink\" title=\"索引最佳实践\"></a><strong>索引最佳实践</strong></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例表：</span><br><span class=\"line\">2 CREATE TABLE `employees` (</span><br><span class=\"line\">3 `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">4 `name` varchar(24) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;姓名&#x27;,</span><br><span class=\"line\">5 `age` int(11) NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,</span><br><span class=\"line\">6 `position` varchar(20) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;职位&#x27;,</span><br><span class=\"line\">7 `hire_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;入职时间&#x27;,</span><br><span class=\"line\">8 PRIMARY KEY (`id`),</span><br><span class=\"line\">9 KEY `idx_name_age_position` (`name`,`age`,`position`) USING BTREE</span><br><span class=\"line\">10 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT=&#x27;员工记录表&#x27;;</span><br><span class=\"line\">11</span><br><span class=\"line\">12 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;LiLei&#x27;,22,&#x27;manager&#x27;,NOW());</span><br><span class=\"line\">13 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;HanMeimei&#x27;,</span><br><span class=\"line\">23,&#x27;dev&#x27;,NOW());</span><br><span class=\"line\">14 INSERT INTO employees(name,age,position,hire_time) VALUES(&#x27;Lucy&#x27;,23,&#x27;dev&#x27;,NOW());</span><br></pre></td></tr></table></figure>\n\n<p><strong>1.全值匹配</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain25.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain26.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain27.png\" alt=\"图片\"></p>\n<p><strong>2.最左前缀法则</strong><br>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;Bill&#x27; and age = 31;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE age = 30 AND position = &#x27;dev&#x27;;</span><br><span class=\"line\">3 EXPLAIN SELECT * FROM employees WHERE position = &#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain28.png\" alt=\"图片\"></p>\n<p><strong>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27;;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE left(name,3) = &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><strong>备注：</strong><br>&lt;1&gt;. LEFT()函数是一个字符串函数,它返回具有指定长度的字符串的左边部分。LEFT(Str,length); 接收两个参数: str:一个字符串; length:想要截取的长度,是一个正整数。<br>&lt;2&gt;.Why聚合函数索引列不能走索引?<br>答：聚合函数改变了这个列的值，不能在索引树里匹配上，所以不能走索引了。</p>\n<p><img src=\"/img/mysql_explain29.png\" alt=\"图片\"><br>给hire_time增加一个普通索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` ADD INDEX `idx_hire_time` (`hire_time`) USING BTREE ;</span><br><span class=\"line\">1 EXPLAIN select * from employees where date(hire_time) =&#x27;2018‐09‐30&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain30.png\" alt=\"图片\"><br>转化为日期范围查询，有可能会走索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN select * from employees where hire_time &gt;=&#x27;2018‐09‐30 00:00:00&#x27; and hire_time &lt;=&#x27;2018‐09‐30 23:59:59&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain31.png\" alt=\"图片\"><br>还原最初索引状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` DROP INDEX `idx_hire_time`;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>4.存储引擎不能使用索引中范围条件右边的列</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 22 AND position =&#x27;manage</span><br><span class=\"line\">r&#x27;;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age &gt; 22 AND position =&#x27;manage</span><br><span class=\"line\">r&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain32.png\" alt=\"图片\"><br><strong>现象解释</strong>：第2个sql语句name和age走了索引，position没有走索引。<br>为什么？<br>答：联合索引中，在此语句中，name列的值是确定的，age是范围查询，按索引树的有序性可以得知是可以走索引了，但是此时age字段不相等，不能保证position的有序性，所以不走索引。</p>\n<p><strong>5.尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少 select * 语句</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT name,age FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain33.png\" alt=\"图片\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name= &#x27;LiLei&#x27; AND age = 23 AND position =&#x27;manager&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain34.png\" alt=\"图片\"></p>\n<p><strong>6.mysql在使用不等于（！&#x3D;或者&lt;&gt;），not in ，not exists 的时候无法使用索引会导致全表扫描</strong><br>&lt; 小于、&gt; 大于、&lt;&#x3D;、&gt;&#x3D; 这些，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name != &#x27;LiLei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain35.png\" alt=\"图片\"></p>\n<p><strong>7. is null,is not null 一般情况下也无法使用索引</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name is null</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain36.png\" alt=\"图片\"></p>\n<p><strong>8. like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name like &#x27;%Lei&#x27;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain37.png\" alt=\"图片\"><br>上图没有走索引。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name like &#x27;Lei%&#x27;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain38.png\" alt=\"图片\"></p>\n<p><strong>问题</strong>：解决like’%字符串%’索引不被使用的方法？<br>a）使用覆盖索引，查询字段必须是建立覆盖索引字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT name,age,position FROM employees WHERE name like &#x27;%Lei%&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain39.png\" alt=\"图片\"><br>查询字段少一点，最好是索引树内的。</p>\n<p>b）如果不能使用覆盖索引则可能需要借助搜索引擎</p>\n<p><strong>9.字符串不加单引号索引失效</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;1000&#x27;;</span><br><span class=\"line\">2 EXPLAIN SELECT * FROM employees WHERE name = 1000;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain40.png\" alt=\"图片\"><br>备注：被比较字段和要比较的值的类型最好相同。</p>\n<p><strong>10.少用or或in，用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 EXPLAIN SELECT * FROM employees WHERE name = &#x27;LiLei&#x27; or name = &#x27;HanMeimei&#x27;;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain41.png\" alt=\"图片\"></p>\n<p><strong>11.范围查询优化给年龄添加单值索引</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` ADD INDEX `idx_age` (`age`) USING BTREE ;</span><br><span class=\"line\">1 explain select * from employees where age &gt;=1 and age &lt;=2000;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain42.png\" alt=\"图片\"><br><strong>没走索引原因</strong>：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引。<br><strong>优化方法</strong>：可以将大的范围拆分成多个小范围。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 explain select * from employees where age &gt;=1 and age &lt;=1000;</span><br><span class=\"line\">2 explain select * from employees where age &gt;=1001 and age &lt;=2000;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/mysql_explain43.png\" alt=\"图片\"><br>还原最初索引状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ALTER TABLE `employees` DROP INDEX `idx_age`;</span><br></pre></td></tr></table></figure>\n\n<p><strong>索引使用总结</strong>：<br><img src=\"/img/mysql_explain44.png\" alt=\"图片\"><br>like KK%相当于&#x3D;常量，%KK和%KK% 相当于范围</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 ‐‐ mysql5.7关闭ONLY_FULL_GROUP_BY报错</span><br><span class=\"line\">2 select version(), @@sql_mode;SET sql_mode=(SELECT REPLACE(@@sql_mode,&#x27;ONLY_FULL_GROUP_BY&#x27;,&#x27;&#x27;));</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"Algorithm","top_img":"/img/suanfa.png","cover":"/img/suanfa.png","keywords":"Algorithm","description":"算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"abbrlink":"17f44e1a","date":"2023-08-01T04:27:18.000Z","_content":"# 一、动态规划\n\n动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过**将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解**。==动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率==。\n\n动态规划适用于满足以下两个条件的问题：\n\n1. 重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。\n\n2. 最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。\n\n动态规划通常有两种常见的方法：\n\n1. 自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。\n\n2. 自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。\n\n动态规划广泛应用于许多领域，例如：\n\n- 背包问题（Knapsack Problem）\n- 最短路径问题（Shortest Path Problem）\n- 最长公共子序列问题（Longest Common Subsequence Problem）\n- 斐波那契数列问题（Fibonacci Sequence Problem）\n- 编辑距离问题（Edit Distance Problem）\n- 最大子数组和问题（Maximum Subarray Sum Problem）\n- …等等\n\n总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。\n\n\n**大致步骤：**\n1. **定义子问题：** 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。\n\n2. **找出状态转移方程：** 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。\n\n3. **初始化：** 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。\n\n4. **自底向上求解（或者记忆化递归）：** 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。\n\n5. **存储中间结果：** 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。\n\n6. **得到最终解：** 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。\n\n7. **可选的优化：** 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。\n\n## 最长递增子序列\n\n**题目：**\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n示例 1：\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n示例 2：\n输入：nums = [0,1,0,3,2,3]\n输出：4\n\n示例 3：\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n \n提示：\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104\n\n**注意**「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的\n\n\n**思想解释：**\n1. 我们使用一个数组 `dp` 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。\n2. 我们从数组的第二个元素开始遍历，对于每个元素 `nums[i]`，我们再遍历它之前的所有元素 `nums[j]`（`j < i`）。如果 `nums[i]` 大于 `nums[j]`，说明可以将 `nums[i]` 加入以 `nums[j]` 结尾的子序列，从而构成一个更长的递增子序列。我们更新 `dp[i]` 为 `dp[j] + 1`，表示以 `nums[i]` 结尾的最长递增子序列长度。\n3. 在内层循环中，我们不断更新 `dp[i]`，找到以当前元素 `nums[i]` 结尾的最长递增子序列长度。\n4. 在整个过程中，我们维护一个全局变量 `maxLen`，记录最长递增子序列的长度。\n5. 最终，遍历完整个数组后，`maxLen` 就是最长递增子序列的长度。\n\n\n```java\npublic class LongestIncreasingSubsequence {\n    public static int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int[] dp = new int[nums.length]; // dp[i] 表示以 nums[i] 结尾的最长递增子序列长度\n        dp[0] = 1; // 初始化，单个元素也构成递增子序列\n        \n        int maxLen = 1; // 最长递增子序列长度\n        for (int i = 1; i < nums.length; i++) {\n            dp[i] = 1; // 默认以当前元素为结尾的子序列长度为 1\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1); // 更新最长递增子序列长度\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]); // 更新全局最长长度\n        }\n        \n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};\n        int lisLength = lengthOfLIS(nums);\n        System.out.println(\"Length of Longest Increasing Subsequence: \" + lisLength);\n    }\n}\n```\n\n\n## 正则表达式匹配\n\n\n**题目：**\n请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\n\n示例 1:\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n示例 2:\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n示例 3:\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n\n示例 4:\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n示例 5:\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。\n\n**解题思路如下：**\n1. 我们可以使用动态规划来解决正则表达式匹配问题。\n2. 定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。\n3. 初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。\n4. 遍历字符串和正则表达式的每个字符，逐步填充dp数组。\n5. 如果s[i]和p[j]相等，或者p[j]为'.'，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。\n6. 如果p[j]为'*'，则需要考虑两种情况：\n\n```\n-  '*'表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。\n-  '*'表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为'.'。\n```\n\n7. 其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。\n8. 最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。\n\n\n```java\npublic class RegularExpressionMatching {\n    public static boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        \n        // dp[i][j]表示s的前i个字符和p的前j个字符是否匹配\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        \n        // 空字符串和空正则表达式匹配\n        dp[0][0] = true;\n        \n        // 处理空正则表达式可以匹配的情况\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n        \n        // 填充dp表格\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                char sc = s.charAt(i - 1);\n                char pc = p.charAt(j - 1);\n                \n                if (sc == pc || pc == '.') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (pc == '*') {\n                    char prevPc = p.charAt(j - 2);\n                    if (prevPc == sc || prevPc == '.') {\n                        // 匹配0次、1次或多次\n                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2];\n                    } else {\n                        // 匹配0次\n                        dp[i][j] = dp[i][j - 2];\n                    }\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String s = \"mississippi\";\n        String p = \"mis*is*p*.\";\n        \n        boolean result = isMatch(s, p);\n        System.out.println(\"Is match: \" + result);\n    }\n}\n```\n注释解释：\n1. `dp[i][j]`表示s的前i个字符和p的前j个字符是否匹配。\n2. 初始化：空字符串和空正则表达式匹配，`dp[0][0] = true`。\n3. 处理空正则表达式可以匹配的情况：如果p的某个字符是'*'，那么它可以匹配0次，将`dp[0][j]`设置为`dp[0][j-2]`。\n4. 填充dp表格：根据字符匹配和'*'的特性，更新`dp[i][j]`的值。\n5. 最终结：`dp[m][n]`表示s的全部字符和p的全部字符是否匹配。\n\n## 最长回文子串\n回文串是指正着读和倒着读都一样的字符串。例如，\"aba\"、\"abba\"和\"level\"都是回文串。\n\n**题目：**\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n\n示例 1：\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n\n示例 2：\n输入：s = \"cbbd\"\n输出：\"bb\"\n \n提示：\n1 <= s.length <= 1000\ns 仅由数字和英文字母组成\n\n**解题思路：**\n1. 我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。\n2. 初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] = true。\n3. 遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。\n4. 对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]。\n5. 如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。\n6. 最终得到的最长回文子串就是最长的回文串。\n\n**解法：**\n\n```java\npublic class LongestPalindromeSubstring {\n    public static String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        int start = 0; // 记录最长回文子串的起始位置\n        int maxLength = 1; // 记录最长回文子串的长度\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                start = i;\n                maxLength = 2;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    start = i;\n                    maxLength = len;\n                }\n            }\n        }\n        \n        return s.substring(start, start + maxLength);\n    }\n\n    public static void main(String[] args) {\n        String input = \"babad\";\n        String longestPalindrome = longestPalindrome(input);\n        System.out.println(\"Longest Palindrome Substring: \" + longestPalindrome);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。\n5. 最终结果：根据`dp`数组的信息，找到最长回文子串的起始位置和长度，然后通过`substring`方法获取最长回文子串。\n注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。\n\n## 回文子串个数\n**题目：**\n给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n\n示例 1：\n输入：s = \"abc\"\n输出：3\n解释：三个回文子串: \"a\", \"b\", \"c\"\n\n示例 2：\n输入：s = \"aaa\"\n输出：6\n解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n \n提示：\n1 <= s.length <= 1000\ns 由小写英文字母组成\n\n**解法**：\n\n```java\npublic class CountPalindromicSubstrings {\n    public static int countSubstrings(String s) {\n        int n = s.length();\n        int count = 0; // 记录回文子串的个数\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n            count++;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                count++;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        String input = \"abc\";\n        int palindromeCount = countSubstrings(input);\n        System.out.println(\"Palindrome Substrings Count: \" + palindromeCount);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`，并且`count`加1。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`，并且`count`加1。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则`dp[i][j]`为true，同时`count`加1。\n5. 最终结果：返回`count`，即回文子串的个数。\n\n\n## 背包问题\n背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示在前i个物品中选择总重量不超过j的情况下的最大价值。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。\n3. 遍历物品和背包承载重量，对于每个物品和背包承载重量：\n- 如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以`dp[i][j]`的最大价值和`dp[i-1][j]`一样。\n- 如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为`j - weights[i]`，所以最大价值为`values[i] + dp[i-1][j-weights[i]]`；如果不放入物品i，则最大价值为`dp[i-1][j]`。我们选择两者中较大的值作为`dp[i][j]`的最大价值。其中 `weight[i]` 为物品 i 的重量，`value[i]` 为物品 i 的价值。\n4. 最后`dp[n][W]`即为问题的解，其中n表示物品的个数，W表示背包的承载重量。\n\n\n\n```\npublic class KnapsackProblem {\n\n    /**\n     *\n     * @param weights    物品的重量数组\n     * @param values     价值数组\n     * @param capacity   背包容量\n     * @return 最大价值\n     */\n    public static int knapsack(int[] weights, int[] values, int capacity) {\n\n        int n = weights.length;\n\n        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值\n        int[][] dp = new int[n + 1][capacity + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= capacity; j++) {\n                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值\n                if (weights[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);\n                }\n            }\n        }\n\n        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值\n        return dp[n][capacity];\n    }\n\n    public static void main(String[] args) {\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3, 4, 5, 6};\n        int capacity = 5;\n        int result = knapsack(weights, values, capacity);\n        System.out.println(\"Maximum value: \" + result);\n    }\n}\n\n```\n\n```\n// 输出结果\nMaximum value: 7\n\nProcess finished with exit code 0\n```\n\n## 最长公共子序列（Longest Common Subsequence）问题\n\n最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。\n\n给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。\n\n**解题思路：**\n1. 我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。\n3. 遍历两个序列的元素，对于每个元素`A[i]`和`B[j]`：\n-  如果`A[i]`和`B[j]`相等，说明它们可以作为最长公共子序列的一部分，因此`dp[i][j]`的值应该是`dp[i-1][j-1] + 1`，即在之前的最长公共子序列长度上加1。\n-  如果`A[i]`和`B[j]`不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取`dp[i-1][j]`和`dp[i][j-1]`中的较大值作为`dp[i][j]`的值。\n4. 最后，`dp[n][m]`即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。\n\n\n```\npublic class LongestCommonSubsequence {\n\n    public static int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n\n        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度\n        int[][] dp = new int[m + 1][n + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        // 返回 text1 和 text2 的最长公共子序列长度\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String text1 = \"abcde\";\n        String text2 = \"ace\";\n        int result = longestCommonSubsequence(text1, text2);\n        System.out.println(\"Longest Common Subsequence: \" + result);\n    }\n}\n```\n\n```\nLongest Common Subsequence: 3\n\nProcess finished with exit code 0\n```\n\n\n## 打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\n**题目：**\n\n一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n\n输入：nums = [2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n \n\n提示：\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 400\n\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。\n2. 初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。\n3. 遍历数组，对于每个房屋i，考虑两种情况：\n- 偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。\n- 不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。\n- 取两种情况中的较大值作为dp[i]的值。\n4. 最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。\n\n\n\n```\npublic class HouseRobberI {\n\n    /**\n     * @param nums 一个代表每个房屋存放金额的非负整数数组\n     * @return\n     */\n    public static int rob(int[] nums) {\n\n        int n = nums.length;\n\n        if (n == 0) {\n            return 0;\n        }\n\n        if (n == 1) {\n            return nums[0];\n        }\n\n        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < n; i++) {\n            // 在当前房屋偷窃或不偷窃之间选择最大值\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n\n        // 返回最后一个房屋偷窃或不偷窃的最大金额\n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {2, 7, 9, 3, 1};\n        int result = rob(nums);\n        System.out.println(\"Maximum amount: \" + result);\n    }\n}\n```\n\n```\nMaximum amount: 12\n\nProcess finished with exit code 0\n```\n\n\n# 二、回溯算法\n回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。\n\n回溯算法的基本步骤如下：\n- 确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。\n- 递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。\n- 剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。\n \n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n一些常见的回溯算法问题包括：\n- 全排列（Permutations）\n- 组合求和（Combination Sum）\n- 子集（Subsets）\n- N皇后问题（N-Queens）\n- 单词搜索（Word Search）\n- 正则表达式匹配（Regular Expression Matching）等。\n\n回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。\n\n**回溯算法框架：**\n```\nList<Value> result;\nvoid backtrack(路径， 选择列表) {\n    if (满足结束条件) {\n        result.add(路径);\n        return;\n    }\n    for (选择 ： 选择列表) {\n        做选择;\n        backtrack(路径， 选择列表);\n        撤销选择;\n    }\n}\n```\n\n## 全排列\n全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。\n\n**解题思路如下：**\n1. 首先，我们可以使用递归来实现回溯算法。\n1. 使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。\n1. 递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。\n1. 在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。\n1. 在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。\n\n**题目：**\n\n给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。\n\n \n示例 1：\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例 2：\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n\n示例 3：\n输入：nums = [1]\n输出：[[1]]\n \n提示：\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nnums 中的所有整数 互不相同\n\n\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PermutationsBacktracking {\n\n    public static void main(String[] args) {\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> permutations = permute(nums);\n        for (List<Integer> permutation : permutations) {\n            System.out.println(permutation);\n        }\n    }\n\n    // 初始化了一个空的结果列表\n    public static List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        // 全排列\n        backtrack(nums, new ArrayList<>(), result);\n        return result;\n    }\n\n\n    /**\n     * 回溯函数，用于生成全排列\n     * @param nums      数组 【1，2，3】\n     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素\n     * @param result    存储全排列结果\n     */\n    private static void backtrack(int[] nums, List<Integer> track, List<List<Integer>> result) {\n        // 到达叶子节点，将路径装入结果列表\n        if (track.size() == nums.length) {\n            result.add(new ArrayList<>(track));\n            return;\n        }\n\n        // 尝试每个未使用的元素\n        for (int num : nums) {\n            if (track.contains(num)) {\n                // 如果当前数字已经在排列中，跳过\n                continue;\n            }\n            track.add(num);\n            // 递归调用\n            backtrack(nums, track, result);\n            // 回溯，移除最后一个元素\n            track.remove(track.size() - 1);\n        }\n    }\n```\n\n```\n[1, 2, 3]\n[1, 3, 2]\n[2, 1, 3]\n[2, 3, 1]\n[3, 1, 2]\n[3, 2, 1]\n\nProcess finished with exit code 0\n```\n\n# 三、贪心算法\n\n**核心思想：**\n贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。\n\n贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。\n\n**贪心算法的一般步骤如下**：\n\n1. 定义问题的解空间，即所有可能的解组成的集合。\n1. 制定选择策略，即在每一步都选择一个局部最优解。\n1. 确定是否满足问题的约束条件，即该解是否可行。\n1. 判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。\n\n需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。\n\n**常见算法题：**\n\n1. 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n1. 区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。\n1. 分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。\n1. 买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。\n1. 跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。\n1. 柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。\n1. 汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。\n1. 分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。\n1. 非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。\n1. 跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。\n\n\n## 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n\n在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。\n\n贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。\n\n**解：**\n```\npublic class CoinChangeGreedy {\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 5}; // 零钱的面额\n        int amount = 11; // 要兑换的金额\n        int numCoins = coinChange(coins, amount);\n        System.out.println(\"最少需要的硬币数：\" + numCoins);\n    }\n\n    /**\n     *\n     * @param coins    硬币面额\n     * @param amount   要兑换的金额\n     * @return 最少使用硬币数目\n     */\n    public static int coinChange(int[] coins, int amount) {\n        // 面额按从小到大排序\n        Arrays.sort(coins);\n\n        // 记录硬币数量\n        int count = 0;\n        // 从最大面额的硬币开始尝试\n        int index = coins.length - 1;\n\n        while (amount > 0 && index >= 0) {\n\n            if (coins[index] <= amount) {\n                // 尝试使用当前面额的硬币数量\n                int numCoins = amount / coins[index];\n                count += numCoins;\n                amount -= numCoins * coins[index];\n            }\n            // 尝试下一个面额的硬币\n            index--;\n        }\n\n        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换\n        return amount == 0 ? count : -1;\n    }\n}\n```\n\n```\n最少需要的硬币数：3\n\nProcess finished with exit code 0\n```\n\n在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。==注意==，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。\n\n在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。\n\n","source":"_posts/Algorithm.md","raw":"---\ntitle: Algorithm\ntags:\n  - 算法\n  - 动态规划\n  - 贪心算法\n  - 回溯算法\ncategories:\n  - 算法\n  - 动态规划\n  - 回溯算法\ntop_img: /img/suanfa.png\ncover: /img/suanfa.png\nkeywords: Algorithm\ndescription: >-\n  算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\nabbrlink: 17f44e1a\ndate: 2023-08-01 12:27:18\n---\n# 一、动态规划\n\n动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过**将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解**。==动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率==。\n\n动态规划适用于满足以下两个条件的问题：\n\n1. 重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。\n\n2. 最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。\n\n动态规划通常有两种常见的方法：\n\n1. 自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。\n\n2. 自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。\n\n动态规划广泛应用于许多领域，例如：\n\n- 背包问题（Knapsack Problem）\n- 最短路径问题（Shortest Path Problem）\n- 最长公共子序列问题（Longest Common Subsequence Problem）\n- 斐波那契数列问题（Fibonacci Sequence Problem）\n- 编辑距离问题（Edit Distance Problem）\n- 最大子数组和问题（Maximum Subarray Sum Problem）\n- …等等\n\n总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。\n\n\n**大致步骤：**\n1. **定义子问题：** 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。\n\n2. **找出状态转移方程：** 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。\n\n3. **初始化：** 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。\n\n4. **自底向上求解（或者记忆化递归）：** 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。\n\n5. **存储中间结果：** 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。\n\n6. **得到最终解：** 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。\n\n7. **可选的优化：** 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。\n\n## 最长递增子序列\n\n**题目：**\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n示例 1：\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n示例 2：\n输入：nums = [0,1,0,3,2,3]\n输出：4\n\n示例 3：\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n \n提示：\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104\n\n**注意**「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的\n\n\n**思想解释：**\n1. 我们使用一个数组 `dp` 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。\n2. 我们从数组的第二个元素开始遍历，对于每个元素 `nums[i]`，我们再遍历它之前的所有元素 `nums[j]`（`j < i`）。如果 `nums[i]` 大于 `nums[j]`，说明可以将 `nums[i]` 加入以 `nums[j]` 结尾的子序列，从而构成一个更长的递增子序列。我们更新 `dp[i]` 为 `dp[j] + 1`，表示以 `nums[i]` 结尾的最长递增子序列长度。\n3. 在内层循环中，我们不断更新 `dp[i]`，找到以当前元素 `nums[i]` 结尾的最长递增子序列长度。\n4. 在整个过程中，我们维护一个全局变量 `maxLen`，记录最长递增子序列的长度。\n5. 最终，遍历完整个数组后，`maxLen` 就是最长递增子序列的长度。\n\n\n```java\npublic class LongestIncreasingSubsequence {\n    public static int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int[] dp = new int[nums.length]; // dp[i] 表示以 nums[i] 结尾的最长递增子序列长度\n        dp[0] = 1; // 初始化，单个元素也构成递增子序列\n        \n        int maxLen = 1; // 最长递增子序列长度\n        for (int i = 1; i < nums.length; i++) {\n            dp[i] = 1; // 默认以当前元素为结尾的子序列长度为 1\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1); // 更新最长递增子序列长度\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]); // 更新全局最长长度\n        }\n        \n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};\n        int lisLength = lengthOfLIS(nums);\n        System.out.println(\"Length of Longest Increasing Subsequence: \" + lisLength);\n    }\n}\n```\n\n\n## 正则表达式匹配\n\n\n**题目：**\n请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\n\n示例 1:\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n示例 2:\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n示例 3:\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n\n示例 4:\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n示例 5:\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。\n\n**解题思路如下：**\n1. 我们可以使用动态规划来解决正则表达式匹配问题。\n2. 定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。\n3. 初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。\n4. 遍历字符串和正则表达式的每个字符，逐步填充dp数组。\n5. 如果s[i]和p[j]相等，或者p[j]为'.'，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。\n6. 如果p[j]为'*'，则需要考虑两种情况：\n\n```\n-  '*'表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。\n-  '*'表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为'.'。\n```\n\n7. 其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。\n8. 最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。\n\n\n```java\npublic class RegularExpressionMatching {\n    public static boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        \n        // dp[i][j]表示s的前i个字符和p的前j个字符是否匹配\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        \n        // 空字符串和空正则表达式匹配\n        dp[0][0] = true;\n        \n        // 处理空正则表达式可以匹配的情况\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n        \n        // 填充dp表格\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                char sc = s.charAt(i - 1);\n                char pc = p.charAt(j - 1);\n                \n                if (sc == pc || pc == '.') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (pc == '*') {\n                    char prevPc = p.charAt(j - 2);\n                    if (prevPc == sc || prevPc == '.') {\n                        // 匹配0次、1次或多次\n                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2];\n                    } else {\n                        // 匹配0次\n                        dp[i][j] = dp[i][j - 2];\n                    }\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String s = \"mississippi\";\n        String p = \"mis*is*p*.\";\n        \n        boolean result = isMatch(s, p);\n        System.out.println(\"Is match: \" + result);\n    }\n}\n```\n注释解释：\n1. `dp[i][j]`表示s的前i个字符和p的前j个字符是否匹配。\n2. 初始化：空字符串和空正则表达式匹配，`dp[0][0] = true`。\n3. 处理空正则表达式可以匹配的情况：如果p的某个字符是'*'，那么它可以匹配0次，将`dp[0][j]`设置为`dp[0][j-2]`。\n4. 填充dp表格：根据字符匹配和'*'的特性，更新`dp[i][j]`的值。\n5. 最终结：`dp[m][n]`表示s的全部字符和p的全部字符是否匹配。\n\n## 最长回文子串\n回文串是指正着读和倒着读都一样的字符串。例如，\"aba\"、\"abba\"和\"level\"都是回文串。\n\n**题目：**\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n\n示例 1：\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n\n示例 2：\n输入：s = \"cbbd\"\n输出：\"bb\"\n \n提示：\n1 <= s.length <= 1000\ns 仅由数字和英文字母组成\n\n**解题思路：**\n1. 我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。\n2. 初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] = true。\n3. 遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。\n4. 对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]。\n5. 如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。\n6. 最终得到的最长回文子串就是最长的回文串。\n\n**解法：**\n\n```java\npublic class LongestPalindromeSubstring {\n    public static String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        int start = 0; // 记录最长回文子串的起始位置\n        int maxLength = 1; // 记录最长回文子串的长度\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                start = i;\n                maxLength = 2;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    start = i;\n                    maxLength = len;\n                }\n            }\n        }\n        \n        return s.substring(start, start + maxLength);\n    }\n\n    public static void main(String[] args) {\n        String input = \"babad\";\n        String longestPalindrome = longestPalindrome(input);\n        System.out.println(\"Longest Palindrome Substring: \" + longestPalindrome);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。\n5. 最终结果：根据`dp`数组的信息，找到最长回文子串的起始位置和长度，然后通过`substring`方法获取最长回文子串。\n注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。\n\n## 回文子串个数\n**题目：**\n给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n\n示例 1：\n输入：s = \"abc\"\n输出：3\n解释：三个回文子串: \"a\", \"b\", \"c\"\n\n示例 2：\n输入：s = \"aaa\"\n输出：6\n解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n \n提示：\n1 <= s.length <= 1000\ns 由小写英文字母组成\n\n**解法**：\n\n```java\npublic class CountPalindromicSubstrings {\n    public static int countSubstrings(String s) {\n        int n = s.length();\n        int count = 0; // 记录回文子串的个数\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n            count++;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                count++;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        String input = \"abc\";\n        int palindromeCount = countSubstrings(input);\n        System.out.println(\"Palindrome Substrings Count: \" + palindromeCount);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`，并且`count`加1。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`，并且`count`加1。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则`dp[i][j]`为true，同时`count`加1。\n5. 最终结果：返回`count`，即回文子串的个数。\n\n\n## 背包问题\n背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示在前i个物品中选择总重量不超过j的情况下的最大价值。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。\n3. 遍历物品和背包承载重量，对于每个物品和背包承载重量：\n- 如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以`dp[i][j]`的最大价值和`dp[i-1][j]`一样。\n- 如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为`j - weights[i]`，所以最大价值为`values[i] + dp[i-1][j-weights[i]]`；如果不放入物品i，则最大价值为`dp[i-1][j]`。我们选择两者中较大的值作为`dp[i][j]`的最大价值。其中 `weight[i]` 为物品 i 的重量，`value[i]` 为物品 i 的价值。\n4. 最后`dp[n][W]`即为问题的解，其中n表示物品的个数，W表示背包的承载重量。\n\n\n\n```\npublic class KnapsackProblem {\n\n    /**\n     *\n     * @param weights    物品的重量数组\n     * @param values     价值数组\n     * @param capacity   背包容量\n     * @return 最大价值\n     */\n    public static int knapsack(int[] weights, int[] values, int capacity) {\n\n        int n = weights.length;\n\n        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值\n        int[][] dp = new int[n + 1][capacity + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= capacity; j++) {\n                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值\n                if (weights[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);\n                }\n            }\n        }\n\n        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值\n        return dp[n][capacity];\n    }\n\n    public static void main(String[] args) {\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3, 4, 5, 6};\n        int capacity = 5;\n        int result = knapsack(weights, values, capacity);\n        System.out.println(\"Maximum value: \" + result);\n    }\n}\n\n```\n\n```\n// 输出结果\nMaximum value: 7\n\nProcess finished with exit code 0\n```\n\n## 最长公共子序列（Longest Common Subsequence）问题\n\n最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。\n\n给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。\n\n**解题思路：**\n1. 我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。\n3. 遍历两个序列的元素，对于每个元素`A[i]`和`B[j]`：\n-  如果`A[i]`和`B[j]`相等，说明它们可以作为最长公共子序列的一部分，因此`dp[i][j]`的值应该是`dp[i-1][j-1] + 1`，即在之前的最长公共子序列长度上加1。\n-  如果`A[i]`和`B[j]`不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取`dp[i-1][j]`和`dp[i][j-1]`中的较大值作为`dp[i][j]`的值。\n4. 最后，`dp[n][m]`即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。\n\n\n```\npublic class LongestCommonSubsequence {\n\n    public static int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n\n        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度\n        int[][] dp = new int[m + 1][n + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        // 返回 text1 和 text2 的最长公共子序列长度\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String text1 = \"abcde\";\n        String text2 = \"ace\";\n        int result = longestCommonSubsequence(text1, text2);\n        System.out.println(\"Longest Common Subsequence: \" + result);\n    }\n}\n```\n\n```\nLongest Common Subsequence: 3\n\nProcess finished with exit code 0\n```\n\n\n## 打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\n**题目：**\n\n一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n\n输入：nums = [2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n \n\n提示：\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 400\n\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。\n2. 初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。\n3. 遍历数组，对于每个房屋i，考虑两种情况：\n- 偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。\n- 不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。\n- 取两种情况中的较大值作为dp[i]的值。\n4. 最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。\n\n\n\n```\npublic class HouseRobberI {\n\n    /**\n     * @param nums 一个代表每个房屋存放金额的非负整数数组\n     * @return\n     */\n    public static int rob(int[] nums) {\n\n        int n = nums.length;\n\n        if (n == 0) {\n            return 0;\n        }\n\n        if (n == 1) {\n            return nums[0];\n        }\n\n        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < n; i++) {\n            // 在当前房屋偷窃或不偷窃之间选择最大值\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n\n        // 返回最后一个房屋偷窃或不偷窃的最大金额\n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {2, 7, 9, 3, 1};\n        int result = rob(nums);\n        System.out.println(\"Maximum amount: \" + result);\n    }\n}\n```\n\n```\nMaximum amount: 12\n\nProcess finished with exit code 0\n```\n\n\n# 二、回溯算法\n回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。\n\n回溯算法的基本步骤如下：\n- 确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。\n- 递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。\n- 剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。\n \n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n一些常见的回溯算法问题包括：\n- 全排列（Permutations）\n- 组合求和（Combination Sum）\n- 子集（Subsets）\n- N皇后问题（N-Queens）\n- 单词搜索（Word Search）\n- 正则表达式匹配（Regular Expression Matching）等。\n\n回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。\n\n**回溯算法框架：**\n```\nList<Value> result;\nvoid backtrack(路径， 选择列表) {\n    if (满足结束条件) {\n        result.add(路径);\n        return;\n    }\n    for (选择 ： 选择列表) {\n        做选择;\n        backtrack(路径， 选择列表);\n        撤销选择;\n    }\n}\n```\n\n## 全排列\n全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。\n\n**解题思路如下：**\n1. 首先，我们可以使用递归来实现回溯算法。\n1. 使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。\n1. 递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。\n1. 在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。\n1. 在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。\n\n**题目：**\n\n给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。\n\n \n示例 1：\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例 2：\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n\n示例 3：\n输入：nums = [1]\n输出：[[1]]\n \n提示：\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nnums 中的所有整数 互不相同\n\n\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PermutationsBacktracking {\n\n    public static void main(String[] args) {\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> permutations = permute(nums);\n        for (List<Integer> permutation : permutations) {\n            System.out.println(permutation);\n        }\n    }\n\n    // 初始化了一个空的结果列表\n    public static List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        // 全排列\n        backtrack(nums, new ArrayList<>(), result);\n        return result;\n    }\n\n\n    /**\n     * 回溯函数，用于生成全排列\n     * @param nums      数组 【1，2，3】\n     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素\n     * @param result    存储全排列结果\n     */\n    private static void backtrack(int[] nums, List<Integer> track, List<List<Integer>> result) {\n        // 到达叶子节点，将路径装入结果列表\n        if (track.size() == nums.length) {\n            result.add(new ArrayList<>(track));\n            return;\n        }\n\n        // 尝试每个未使用的元素\n        for (int num : nums) {\n            if (track.contains(num)) {\n                // 如果当前数字已经在排列中，跳过\n                continue;\n            }\n            track.add(num);\n            // 递归调用\n            backtrack(nums, track, result);\n            // 回溯，移除最后一个元素\n            track.remove(track.size() - 1);\n        }\n    }\n```\n\n```\n[1, 2, 3]\n[1, 3, 2]\n[2, 1, 3]\n[2, 3, 1]\n[3, 1, 2]\n[3, 2, 1]\n\nProcess finished with exit code 0\n```\n\n# 三、贪心算法\n\n**核心思想：**\n贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。\n\n贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。\n\n**贪心算法的一般步骤如下**：\n\n1. 定义问题的解空间，即所有可能的解组成的集合。\n1. 制定选择策略，即在每一步都选择一个局部最优解。\n1. 确定是否满足问题的约束条件，即该解是否可行。\n1. 判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。\n\n需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。\n\n**常见算法题：**\n\n1. 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n1. 区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。\n1. 分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。\n1. 买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。\n1. 跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。\n1. 柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。\n1. 汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。\n1. 分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。\n1. 非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。\n1. 跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。\n\n\n## 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n\n在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。\n\n贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。\n\n**解：**\n```\npublic class CoinChangeGreedy {\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 5}; // 零钱的面额\n        int amount = 11; // 要兑换的金额\n        int numCoins = coinChange(coins, amount);\n        System.out.println(\"最少需要的硬币数：\" + numCoins);\n    }\n\n    /**\n     *\n     * @param coins    硬币面额\n     * @param amount   要兑换的金额\n     * @return 最少使用硬币数目\n     */\n    public static int coinChange(int[] coins, int amount) {\n        // 面额按从小到大排序\n        Arrays.sort(coins);\n\n        // 记录硬币数量\n        int count = 0;\n        // 从最大面额的硬币开始尝试\n        int index = coins.length - 1;\n\n        while (amount > 0 && index >= 0) {\n\n            if (coins[index] <= amount) {\n                // 尝试使用当前面额的硬币数量\n                int numCoins = amount / coins[index];\n                count += numCoins;\n                amount -= numCoins * coins[index];\n            }\n            // 尝试下一个面额的硬币\n            index--;\n        }\n\n        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换\n        return amount == 0 ? count : -1;\n    }\n}\n```\n\n```\n最少需要的硬币数：3\n\nProcess finished with exit code 0\n```\n\n在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。==注意==，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。\n\n在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。\n\n","slug":"Algorithm","published":1,"updated":"2023-09-02T16:52:40.736Z","_id":"clm29i9a6001h88thf2qx0lt0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"一、动态规划\"><a href=\"#一、动态规划\" class=\"headerlink\" title=\"一、动态规划\"></a>一、动态规划</h1><p>动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过<strong>将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解</strong>。&#x3D;&#x3D;动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率&#x3D;&#x3D;。</p>\n<p>动态规划适用于满足以下两个条件的问题：</p>\n<ol>\n<li><p>重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。</p>\n</li>\n<li><p>最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。</p>\n</li>\n</ol>\n<p>动态规划通常有两种常见的方法：</p>\n<ol>\n<li><p>自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。</p>\n</li>\n<li><p>自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。</p>\n</li>\n</ol>\n<p>动态规划广泛应用于许多领域，例如：</p>\n<ul>\n<li>背包问题（Knapsack Problem）</li>\n<li>最短路径问题（Shortest Path Problem）</li>\n<li>最长公共子序列问题（Longest Common Subsequence Problem）</li>\n<li>斐波那契数列问题（Fibonacci Sequence Problem）</li>\n<li>编辑距离问题（Edit Distance Problem）</li>\n<li>最大子数组和问题（Maximum Subarray Sum Problem）</li>\n<li>…等等</li>\n</ul>\n<p>总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。</p>\n<p><strong>大致步骤：</strong></p>\n<ol>\n<li><p><strong>定义子问题：</strong> 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。</p>\n</li>\n<li><p><strong>找出状态转移方程：</strong> 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。</p>\n</li>\n<li><p><strong>初始化：</strong> 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。</p>\n</li>\n<li><p><strong>自底向上求解（或者记忆化递归）：</strong> 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。</p>\n</li>\n<li><p><strong>存储中间结果：</strong> 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。</p>\n</li>\n<li><p><strong>得到最终解：</strong> 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。</p>\n</li>\n<li><p><strong>可选的优化：</strong> 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。</p>\n</li>\n</ol>\n<h2 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列\"></a>最长递增子序列</h2><p><strong>题目：</strong><br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>\n<p>示例 1：<br>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4</p>\n<p>示例 3：<br>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>\n<p><strong>注意</strong>「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的</p>\n<p><strong>思想解释：</strong></p>\n<ol>\n<li>我们使用一个数组 <code>dp</code> 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。</li>\n<li>我们从数组的第二个元素开始遍历，对于每个元素 <code>nums[i]</code>，我们再遍历它之前的所有元素 <code>nums[j]</code>（<code>j &lt; i</code>）。如果 <code>nums[i]</code> 大于 <code>nums[j]</code>，说明可以将 <code>nums[i]</code> 加入以 <code>nums[j]</code> 结尾的子序列，从而构成一个更长的递增子序列。我们更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code>，表示以 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在内层循环中，我们不断更新 <code>dp[i]</code>，找到以当前元素 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在整个过程中，我们维护一个全局变量 <code>maxLen</code>，记录最长递增子序列的长度。</li>\n<li>最终，遍历完整个数组后，<code>maxLen</code> 就是最长递增子序列的长度。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestIncreasingSubsequence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length]; <span class=\"comment\">// dp[i] 表示以 nums[i] 结尾的最长递增子序列长度</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化，单个元素也构成递增子序列</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 最长递增子序列长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">1</span>; <span class=\"comment\">// 默认以当前元素为结尾的子序列长度为 1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    dp[i] = Math.max(dp[i], dp[j] + <span class=\"number\">1</span>); <span class=\"comment\">// 更新最长递增子序列长度</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxLen = Math.max(maxLen, dp[i]); <span class=\"comment\">// 更新全局最长长度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">101</span>, <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lisLength</span> <span class=\"operator\">=</span> lengthOfLIS(nums);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Length of Longest Increasing Subsequence: &quot;</span> + lisLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"正则表达式匹配\"><a href=\"#正则表达式匹配\" class=\"headerlink\" title=\"正则表达式匹配\"></a>正则表达式匹配</h2><p><strong>题目：</strong><br>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>\n<p>示例 1:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>\n<p>示例 2:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>\n<p>示例 3:<br>输入:<br>s &#x3D; “ab”<br>p &#x3D; “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p>\n<p>示例 4:<br>输入:<br>s &#x3D; “aab”<br>p &#x3D; “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>\n<p>示例 5:<br>输入:<br>s &#x3D; “mississippi”<br>p &#x3D; “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决正则表达式匹配问题。</li>\n<li>定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。</li>\n<li>初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。</li>\n<li>遍历字符串和正则表达式的每个字符，逐步填充dp数组。</li>\n<li>如果s[i]和p[j]相等，或者p[j]为’.’，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。</li>\n<li>如果p[j]为’*’，则需要考虑两种情况：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。</span><br><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为&#x27;.&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。</li>\n<li>最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RegularExpressionMatching</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isMatch</span><span class=\"params\">(String s, String p)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> p.length();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j]表示s的前i个字符和p的前j个字符是否匹配</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 空字符串和空正则表达式匹配</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理空正则表达式可以匹配的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.charAt(j - <span class=\"number\">1</span>) == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 填充dp表格</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> s.charAt(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">pc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">1</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc == pc || pc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pc == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">char</span> <span class=\"variable\">prevPc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">2</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevPc == sc || prevPc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次、1次或多次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>] || dp[i - <span class=\"number\">1</span>][j] || dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mississippi&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mis*is*p*.&quot;</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> isMatch(s, p);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Is match: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的前i个字符和p的前j个字符是否匹配。</li>\n<li>初始化：空字符串和空正则表达式匹配，<code>dp[0][0] = true</code>。</li>\n<li>处理空正则表达式可以匹配的情况：如果p的某个字符是’*’，那么它可以匹配0次，将<code>dp[0][j]</code>设置为<code>dp[0][j-2]</code>。</li>\n<li>填充dp表格：根据字符匹配和’*’的特性，更新<code>dp[i][j]</code>的值。</li>\n<li>最终结：<code>dp[m][n]</code>表示s的全部字符和p的全部字符是否匹配。</li>\n</ol>\n<h2 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h2><p>回文串是指正着读和倒着读都一样的字符串。例如，”aba”、”abba”和”level”都是回文串。</p>\n<p><strong>题目：</strong><br>给你一个字符串 s，找到 s 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>\n<p>示例 1：<br>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>\n<p>示例 2：<br>输入：s &#x3D; “cbbd”<br>输出：”bb”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母组成</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。</li>\n<li>初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] &#x3D; true。</li>\n<li>遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。</li>\n<li>对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) &amp;&amp; dp[i+1][j-1]。</li>\n<li>如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。</li>\n<li>最终得到的最长回文子串就是最长的回文串。</li>\n</ol>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestPalindromeSubstring</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录最长回文子串的起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLength</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 记录最长回文子串的长度</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                start = i;</span><br><span class=\"line\">                maxLength = <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    start = i;</span><br><span class=\"line\">                    maxLength = len;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(start, start + maxLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;babad&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">longestPalindrome</span> <span class=\"operator\">=</span> longestPalindrome(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Longest Palindrome Substring: &quot;</span> + longestPalindrome);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。</li>\n<li>最终结果：根据<code>dp</code>数组的信息，找到最长回文子串的起始位置和长度，然后通过<code>substring</code>方法获取最长回文子串。<br>注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。</li>\n</ol>\n<h2 id=\"回文子串个数\"><a href=\"#回文子串个数\" class=\"headerlink\" title=\"回文子串个数\"></a>回文子串个数</h2><p><strong>题目：</strong><br>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n<p>示例 1：<br>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p>\n<p>示例 2：<br>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由小写英文字母组成</p>\n<p><strong>解法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountPalindromicSubstrings</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">countSubstrings</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录回文子串的个数</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">palindromeCount</span> <span class=\"operator\">=</span> countSubstrings(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Palindrome Substrings Count: &quot;</span> + palindromeCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则<code>dp[i][j]</code>为true，同时<code>count</code>加1。</li>\n<li>最终结果：返回<code>count</code>，即回文子串的个数。</li>\n</ol>\n<h2 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h2><p>背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示在前i个物品中选择总重量不超过j的情况下的最大价值。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。</li>\n<li>遍历物品和背包承载重量，对于每个物品和背包承载重量：</li>\n</ol>\n<ul>\n<li>如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以<code>dp[i][j]</code>的最大价值和<code>dp[i-1][j]</code>一样。</li>\n<li>如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为<code>j - weights[i]</code>，所以最大价值为<code>values[i] + dp[i-1][j-weights[i]]</code>；如果不放入物品i，则最大价值为<code>dp[i-1][j]</code>。我们选择两者中较大的值作为<code>dp[i][j]</code>的最大价值。其中 <code>weight[i]</code> 为物品 i 的重量，<code>value[i]</code> 为物品 i 的价值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后<code>dp[n][W]</code>即为问题的解，其中n表示物品的个数，W表示背包的承载重量。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class KnapsackProblem &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param weights    物品的重量数组</span><br><span class=\"line\">     * @param values     价值数组</span><br><span class=\"line\">     * @param capacity   背包容量</span><br><span class=\"line\">     * @return 最大价值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int knapsack(int[] weights, int[] values, int capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = weights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值</span><br><span class=\"line\">        int[][] dp = new int[n + 1][capacity + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= capacity; j++) &#123;</span><br><span class=\"line\">                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值</span><br><span class=\"line\">                if (weights[i - 1] &gt; j) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值</span><br><span class=\"line\">        return dp[n][capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] weights = &#123;2, 3, 4, 5&#125;;</span><br><span class=\"line\">        int[] values = &#123;3, 4, 5, 6&#125;;</span><br><span class=\"line\">        int capacity = 5;</span><br><span class=\"line\">        int result = knapsack(weights, values, capacity);</span><br><span class=\"line\">        System.out.println(&quot;Maximum value: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出结果</span><br><span class=\"line\">Maximum value: 7</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最长公共子序列（Longest-Common-Subsequence）问题\"><a href=\"#最长公共子序列（Longest-Common-Subsequence）问题\" class=\"headerlink\" title=\"最长公共子序列（Longest Common Subsequence）问题\"></a>最长公共子序列（Longest Common Subsequence）问题</h2><p>最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。</p>\n<p>给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。</li>\n<li>遍历两个序列的元素，对于每个元素<code>A[i]</code>和<code>B[j]</code>：</li>\n</ol>\n<ul>\n<li>如果<code>A[i]</code>和<code>B[j]</code>相等，说明它们可以作为最长公共子序列的一部分，因此<code>dp[i][j]</code>的值应该是<code>dp[i-1][j-1] + 1</code>，即在之前的最长公共子序列长度上加1。</li>\n<li>如果<code>A[i]</code>和<code>B[j]</code>不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>中的较大值作为<code>dp[i][j]</code>的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后，<code>dp[n][m]</code>即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LongestCommonSubsequence &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class=\"line\">        int m = text1.length();</span><br><span class=\"line\">        int n = text2.length();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class=\"line\">        int[][] dp = new int[m + 1][n + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一</span><br><span class=\"line\">                if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回 text1 和 text2 的最长公共子序列长度</span><br><span class=\"line\">        return dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String text1 = &quot;abcde&quot;;</span><br><span class=\"line\">        String text2 = &quot;ace&quot;;</span><br><span class=\"line\">        int result = longestCommonSubsequence(text1, text2);</span><br><span class=\"line\">        System.out.println(&quot;Longest Common Subsequence: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Longest Common Subsequence: 3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\"><a href=\"#打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\" class=\"headerlink\" title=\"打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\"></a>打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。</h2><p><strong>题目：</strong></p>\n<p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n<p>示例 1：</p>\n<p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n<p>示例 2：</p>\n<p>输入：nums &#x3D; [2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>\n<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>\n</ul>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。</li>\n<li>初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。</li>\n<li>遍历数组，对于每个房屋i，考虑两种情况：</li>\n</ol>\n<ul>\n<li>偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。</li>\n<li>不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。</li>\n<li>取两种情况中的较大值作为dp[i]的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HouseRobberI &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param nums 一个代表每个房屋存放金额的非负整数数组</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int rob(int[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 0) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 1) &#123;</span><br><span class=\"line\">            return nums[0];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额</span><br><span class=\"line\">        int[] dp = new int[n];</span><br><span class=\"line\">        dp[0] = nums[0];</span><br><span class=\"line\">        dp[1] = Math.max(nums[0], nums[1]);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 2; i &lt; n; i++) &#123;</span><br><span class=\"line\">            // 在当前房屋偷窃或不偷窃之间选择最大值</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最后一个房屋偷窃或不偷窃的最大金额</span><br><span class=\"line\">        return dp[n - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;2, 7, 9, 3, 1&#125;;</span><br><span class=\"line\">        int result = rob(nums);</span><br><span class=\"line\">        System.out.println(&quot;Maximum amount: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maximum amount: 12</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"二、回溯算法\"><a href=\"#二、回溯算法\" class=\"headerlink\" title=\"二、回溯算法\"></a>二、回溯算法</h1><p>回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。</p>\n<p>回溯算法的基本步骤如下：</p>\n<ul>\n<li>确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。</li>\n<li>递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。</li>\n<li>剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。</li>\n</ul>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>一些常见的回溯算法问题包括：</p>\n<ul>\n<li>全排列（Permutations）</li>\n<li>组合求和（Combination Sum）</li>\n<li>子集（Subsets）</li>\n<li>N皇后问题（N-Queens）</li>\n<li>单词搜索（Word Search）</li>\n<li>正则表达式匹配（Regular Expression Matching）等。</li>\n</ul>\n<p>回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。</p>\n<p><strong>回溯算法框架：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Value&gt; result;</span><br><span class=\"line\">void backtrack(路径， 选择列表) &#123;</span><br><span class=\"line\">    if (满足结束条件) &#123;</span><br><span class=\"line\">        result.add(路径);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (选择 ： 选择列表) &#123;</span><br><span class=\"line\">        做选择;</span><br><span class=\"line\">        backtrack(路径， 选择列表);</span><br><span class=\"line\">        撤销选择;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><p>全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>首先，我们可以使用递归来实现回溯算法。</li>\n<li>使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。</li>\n<li>递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。</li>\n<li>在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。</li>\n<li>在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。</li>\n</ol>\n<p><strong>题目：</strong></p>\n<p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p>\n<p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]</p>\n<p>示例 3：<br>输入：nums &#x3D; [1]<br>输出：[[1]]</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 6<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有整数 互不相同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PermutationsBacktracking &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; permutations = permute(nums);</span><br><span class=\"line\">        for (List&lt;Integer&gt; permutation : permutations) &#123;</span><br><span class=\"line\">            System.out.println(permutation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化了一个空的结果列表</span><br><span class=\"line\">    public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // 全排列</span><br><span class=\"line\">        backtrack(nums, new ArrayList&lt;&gt;(), result);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 回溯函数，用于生成全排列</span><br><span class=\"line\">     * @param nums      数组 【1，2，3】</span><br><span class=\"line\">     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素</span><br><span class=\"line\">     * @param result    存储全排列结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void backtrack(int[] nums, List&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class=\"line\">        // 到达叶子节点，将路径装入结果列表</span><br><span class=\"line\">        if (track.size() == nums.length) &#123;</span><br><span class=\"line\">            result.add(new ArrayList&lt;&gt;(track));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 尝试每个未使用的元素</span><br><span class=\"line\">        for (int num : nums) &#123;</span><br><span class=\"line\">            if (track.contains(num)) &#123;</span><br><span class=\"line\">                // 如果当前数字已经在排列中，跳过</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            track.add(num);</span><br><span class=\"line\">            // 递归调用</span><br><span class=\"line\">            backtrack(nums, track, result);</span><br><span class=\"line\">            // 回溯，移除最后一个元素</span><br><span class=\"line\">            track.remove(track.size() - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3]</span><br><span class=\"line\">[1, 3, 2]</span><br><span class=\"line\">[2, 1, 3]</span><br><span class=\"line\">[2, 3, 1]</span><br><span class=\"line\">[3, 1, 2]</span><br><span class=\"line\">[3, 2, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、贪心算法\"><a href=\"#三、贪心算法\" class=\"headerlink\" title=\"三、贪心算法\"></a>三、贪心算法</h1><p><strong>核心思想：</strong><br>贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。</p>\n<p>贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。</p>\n<p><strong>贪心算法的一般步骤如下</strong>：</p>\n<ol>\n<li>定义问题的解空间，即所有可能的解组成的集合。</li>\n<li>制定选择策略，即在每一步都选择一个局部最优解。</li>\n<li>确定是否满足问题的约束条件，即该解是否可行。</li>\n<li>判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。</li>\n</ol>\n<p>需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。</p>\n<p><strong>常见算法题：</strong></p>\n<ol>\n<li>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</li>\n<li>区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。</li>\n<li>分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。</li>\n<li>买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。</li>\n<li>跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。</li>\n<li>柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。</li>\n<li>汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。</li>\n<li>分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。</li>\n<li>非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。</li>\n<li>跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。</li>\n</ol>\n<h2 id=\"零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"><a href=\"#零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\" class=\"headerlink\" title=\"零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"></a>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</h2><p>在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。</p>\n<p>贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。</p>\n<p><strong>解：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CoinChangeGreedy &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] coins = &#123;1, 2, 5&#125;; // 零钱的面额</span><br><span class=\"line\">        int amount = 11; // 要兑换的金额</span><br><span class=\"line\">        int numCoins = coinChange(coins, amount);</span><br><span class=\"line\">        System.out.println(&quot;最少需要的硬币数：&quot; + numCoins);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param coins    硬币面额</span><br><span class=\"line\">     * @param amount   要兑换的金额</span><br><span class=\"line\">     * @return 最少使用硬币数目</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int coinChange(int[] coins, int amount) &#123;</span><br><span class=\"line\">        // 面额按从小到大排序</span><br><span class=\"line\">        Arrays.sort(coins);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 记录硬币数量</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        // 从最大面额的硬币开始尝试</span><br><span class=\"line\">        int index = coins.length - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        while (amount &gt; 0 &amp;&amp; index &gt;= 0) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (coins[index] &lt;= amount) &#123;</span><br><span class=\"line\">                // 尝试使用当前面额的硬币数量</span><br><span class=\"line\">                int numCoins = amount / coins[index];</span><br><span class=\"line\">                count += numCoins;</span><br><span class=\"line\">                amount -= numCoins * coins[index];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 尝试下一个面额的硬币</span><br><span class=\"line\">            index--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换</span><br><span class=\"line\">        return amount == 0 ? count : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最少需要的硬币数：3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。&#x3D;&#x3D;注意&#x3D;&#x3D;，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。</p>\n<p>在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}],"valine":{"妙":"bilibiliHotKey/1.jpg"}}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、动态规划\"><a href=\"#一、动态规划\" class=\"headerlink\" title=\"一、动态规划\"></a>一、动态规划</h1><p>动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过<strong>将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解</strong>。&#x3D;&#x3D;动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率&#x3D;&#x3D;。</p>\n<p>动态规划适用于满足以下两个条件的问题：</p>\n<ol>\n<li><p>重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。</p>\n</li>\n<li><p>最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。</p>\n</li>\n</ol>\n<p>动态规划通常有两种常见的方法：</p>\n<ol>\n<li><p>自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。</p>\n</li>\n<li><p>自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。</p>\n</li>\n</ol>\n<p>动态规划广泛应用于许多领域，例如：</p>\n<ul>\n<li>背包问题（Knapsack Problem）</li>\n<li>最短路径问题（Shortest Path Problem）</li>\n<li>最长公共子序列问题（Longest Common Subsequence Problem）</li>\n<li>斐波那契数列问题（Fibonacci Sequence Problem）</li>\n<li>编辑距离问题（Edit Distance Problem）</li>\n<li>最大子数组和问题（Maximum Subarray Sum Problem）</li>\n<li>…等等</li>\n</ul>\n<p>总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。</p>\n<p><strong>大致步骤：</strong></p>\n<ol>\n<li><p><strong>定义子问题：</strong> 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。</p>\n</li>\n<li><p><strong>找出状态转移方程：</strong> 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。</p>\n</li>\n<li><p><strong>初始化：</strong> 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。</p>\n</li>\n<li><p><strong>自底向上求解（或者记忆化递归）：</strong> 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。</p>\n</li>\n<li><p><strong>存储中间结果：</strong> 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。</p>\n</li>\n<li><p><strong>得到最终解：</strong> 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。</p>\n</li>\n<li><p><strong>可选的优化：</strong> 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。</p>\n</li>\n</ol>\n<h2 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列\"></a>最长递增子序列</h2><p><strong>题目：</strong><br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>\n<p>示例 1：<br>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4</p>\n<p>示例 3：<br>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>\n<p><strong>注意</strong>「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的</p>\n<p><strong>思想解释：</strong></p>\n<ol>\n<li>我们使用一个数组 <code>dp</code> 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。</li>\n<li>我们从数组的第二个元素开始遍历，对于每个元素 <code>nums[i]</code>，我们再遍历它之前的所有元素 <code>nums[j]</code>（<code>j &lt; i</code>）。如果 <code>nums[i]</code> 大于 <code>nums[j]</code>，说明可以将 <code>nums[i]</code> 加入以 <code>nums[j]</code> 结尾的子序列，从而构成一个更长的递增子序列。我们更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code>，表示以 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在内层循环中，我们不断更新 <code>dp[i]</code>，找到以当前元素 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在整个过程中，我们维护一个全局变量 <code>maxLen</code>，记录最长递增子序列的长度。</li>\n<li>最终，遍历完整个数组后，<code>maxLen</code> 就是最长递增子序列的长度。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestIncreasingSubsequence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length]; <span class=\"comment\">// dp[i] 表示以 nums[i] 结尾的最长递增子序列长度</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化，单个元素也构成递增子序列</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 最长递增子序列长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">1</span>; <span class=\"comment\">// 默认以当前元素为结尾的子序列长度为 1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    dp[i] = Math.max(dp[i], dp[j] + <span class=\"number\">1</span>); <span class=\"comment\">// 更新最长递增子序列长度</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxLen = Math.max(maxLen, dp[i]); <span class=\"comment\">// 更新全局最长长度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">101</span>, <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lisLength</span> <span class=\"operator\">=</span> lengthOfLIS(nums);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Length of Longest Increasing Subsequence: &quot;</span> + lisLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"正则表达式匹配\"><a href=\"#正则表达式匹配\" class=\"headerlink\" title=\"正则表达式匹配\"></a>正则表达式匹配</h2><p><strong>题目：</strong><br>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>\n<p>示例 1:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>\n<p>示例 2:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>\n<p>示例 3:<br>输入:<br>s &#x3D; “ab”<br>p &#x3D; “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p>\n<p>示例 4:<br>输入:<br>s &#x3D; “aab”<br>p &#x3D; “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>\n<p>示例 5:<br>输入:<br>s &#x3D; “mississippi”<br>p &#x3D; “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决正则表达式匹配问题。</li>\n<li>定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。</li>\n<li>初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。</li>\n<li>遍历字符串和正则表达式的每个字符，逐步填充dp数组。</li>\n<li>如果s[i]和p[j]相等，或者p[j]为’.’，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。</li>\n<li>如果p[j]为’*’，则需要考虑两种情况：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。</span><br><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为&#x27;.&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。</li>\n<li>最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RegularExpressionMatching</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isMatch</span><span class=\"params\">(String s, String p)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> p.length();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j]表示s的前i个字符和p的前j个字符是否匹配</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 空字符串和空正则表达式匹配</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理空正则表达式可以匹配的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.charAt(j - <span class=\"number\">1</span>) == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 填充dp表格</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> s.charAt(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">pc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">1</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc == pc || pc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pc == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">char</span> <span class=\"variable\">prevPc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">2</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevPc == sc || prevPc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次、1次或多次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>] || dp[i - <span class=\"number\">1</span>][j] || dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mississippi&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mis*is*p*.&quot;</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> isMatch(s, p);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Is match: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的前i个字符和p的前j个字符是否匹配。</li>\n<li>初始化：空字符串和空正则表达式匹配，<code>dp[0][0] = true</code>。</li>\n<li>处理空正则表达式可以匹配的情况：如果p的某个字符是’*’，那么它可以匹配0次，将<code>dp[0][j]</code>设置为<code>dp[0][j-2]</code>。</li>\n<li>填充dp表格：根据字符匹配和’*’的特性，更新<code>dp[i][j]</code>的值。</li>\n<li>最终结：<code>dp[m][n]</code>表示s的全部字符和p的全部字符是否匹配。</li>\n</ol>\n<h2 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h2><p>回文串是指正着读和倒着读都一样的字符串。例如，”aba”、”abba”和”level”都是回文串。</p>\n<p><strong>题目：</strong><br>给你一个字符串 s，找到 s 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>\n<p>示例 1：<br>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>\n<p>示例 2：<br>输入：s &#x3D; “cbbd”<br>输出：”bb”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母组成</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。</li>\n<li>初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] &#x3D; true。</li>\n<li>遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。</li>\n<li>对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) &amp;&amp; dp[i+1][j-1]。</li>\n<li>如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。</li>\n<li>最终得到的最长回文子串就是最长的回文串。</li>\n</ol>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestPalindromeSubstring</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录最长回文子串的起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLength</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 记录最长回文子串的长度</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                start = i;</span><br><span class=\"line\">                maxLength = <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    start = i;</span><br><span class=\"line\">                    maxLength = len;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(start, start + maxLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;babad&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">longestPalindrome</span> <span class=\"operator\">=</span> longestPalindrome(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Longest Palindrome Substring: &quot;</span> + longestPalindrome);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。</li>\n<li>最终结果：根据<code>dp</code>数组的信息，找到最长回文子串的起始位置和长度，然后通过<code>substring</code>方法获取最长回文子串。<br>注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。</li>\n</ol>\n<h2 id=\"回文子串个数\"><a href=\"#回文子串个数\" class=\"headerlink\" title=\"回文子串个数\"></a>回文子串个数</h2><p><strong>题目：</strong><br>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n<p>示例 1：<br>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p>\n<p>示例 2：<br>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由小写英文字母组成</p>\n<p><strong>解法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountPalindromicSubstrings</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">countSubstrings</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录回文子串的个数</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">palindromeCount</span> <span class=\"operator\">=</span> countSubstrings(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Palindrome Substrings Count: &quot;</span> + palindromeCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则<code>dp[i][j]</code>为true，同时<code>count</code>加1。</li>\n<li>最终结果：返回<code>count</code>，即回文子串的个数。</li>\n</ol>\n<h2 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h2><p>背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示在前i个物品中选择总重量不超过j的情况下的最大价值。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。</li>\n<li>遍历物品和背包承载重量，对于每个物品和背包承载重量：</li>\n</ol>\n<ul>\n<li>如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以<code>dp[i][j]</code>的最大价值和<code>dp[i-1][j]</code>一样。</li>\n<li>如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为<code>j - weights[i]</code>，所以最大价值为<code>values[i] + dp[i-1][j-weights[i]]</code>；如果不放入物品i，则最大价值为<code>dp[i-1][j]</code>。我们选择两者中较大的值作为<code>dp[i][j]</code>的最大价值。其中 <code>weight[i]</code> 为物品 i 的重量，<code>value[i]</code> 为物品 i 的价值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后<code>dp[n][W]</code>即为问题的解，其中n表示物品的个数，W表示背包的承载重量。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class KnapsackProblem &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param weights    物品的重量数组</span><br><span class=\"line\">     * @param values     价值数组</span><br><span class=\"line\">     * @param capacity   背包容量</span><br><span class=\"line\">     * @return 最大价值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int knapsack(int[] weights, int[] values, int capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = weights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值</span><br><span class=\"line\">        int[][] dp = new int[n + 1][capacity + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= capacity; j++) &#123;</span><br><span class=\"line\">                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值</span><br><span class=\"line\">                if (weights[i - 1] &gt; j) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值</span><br><span class=\"line\">        return dp[n][capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] weights = &#123;2, 3, 4, 5&#125;;</span><br><span class=\"line\">        int[] values = &#123;3, 4, 5, 6&#125;;</span><br><span class=\"line\">        int capacity = 5;</span><br><span class=\"line\">        int result = knapsack(weights, values, capacity);</span><br><span class=\"line\">        System.out.println(&quot;Maximum value: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出结果</span><br><span class=\"line\">Maximum value: 7</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最长公共子序列（Longest-Common-Subsequence）问题\"><a href=\"#最长公共子序列（Longest-Common-Subsequence）问题\" class=\"headerlink\" title=\"最长公共子序列（Longest Common Subsequence）问题\"></a>最长公共子序列（Longest Common Subsequence）问题</h2><p>最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。</p>\n<p>给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。</li>\n<li>遍历两个序列的元素，对于每个元素<code>A[i]</code>和<code>B[j]</code>：</li>\n</ol>\n<ul>\n<li>如果<code>A[i]</code>和<code>B[j]</code>相等，说明它们可以作为最长公共子序列的一部分，因此<code>dp[i][j]</code>的值应该是<code>dp[i-1][j-1] + 1</code>，即在之前的最长公共子序列长度上加1。</li>\n<li>如果<code>A[i]</code>和<code>B[j]</code>不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>中的较大值作为<code>dp[i][j]</code>的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后，<code>dp[n][m]</code>即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LongestCommonSubsequence &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class=\"line\">        int m = text1.length();</span><br><span class=\"line\">        int n = text2.length();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class=\"line\">        int[][] dp = new int[m + 1][n + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一</span><br><span class=\"line\">                if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回 text1 和 text2 的最长公共子序列长度</span><br><span class=\"line\">        return dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String text1 = &quot;abcde&quot;;</span><br><span class=\"line\">        String text2 = &quot;ace&quot;;</span><br><span class=\"line\">        int result = longestCommonSubsequence(text1, text2);</span><br><span class=\"line\">        System.out.println(&quot;Longest Common Subsequence: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Longest Common Subsequence: 3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\"><a href=\"#打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\" class=\"headerlink\" title=\"打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\"></a>打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。</h2><p><strong>题目：</strong></p>\n<p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n<p>示例 1：</p>\n<p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n<p>示例 2：</p>\n<p>输入：nums &#x3D; [2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>\n<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>\n</ul>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。</li>\n<li>初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。</li>\n<li>遍历数组，对于每个房屋i，考虑两种情况：</li>\n</ol>\n<ul>\n<li>偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。</li>\n<li>不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。</li>\n<li>取两种情况中的较大值作为dp[i]的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HouseRobberI &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param nums 一个代表每个房屋存放金额的非负整数数组</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int rob(int[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 0) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 1) &#123;</span><br><span class=\"line\">            return nums[0];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额</span><br><span class=\"line\">        int[] dp = new int[n];</span><br><span class=\"line\">        dp[0] = nums[0];</span><br><span class=\"line\">        dp[1] = Math.max(nums[0], nums[1]);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 2; i &lt; n; i++) &#123;</span><br><span class=\"line\">            // 在当前房屋偷窃或不偷窃之间选择最大值</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最后一个房屋偷窃或不偷窃的最大金额</span><br><span class=\"line\">        return dp[n - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;2, 7, 9, 3, 1&#125;;</span><br><span class=\"line\">        int result = rob(nums);</span><br><span class=\"line\">        System.out.println(&quot;Maximum amount: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maximum amount: 12</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"二、回溯算法\"><a href=\"#二、回溯算法\" class=\"headerlink\" title=\"二、回溯算法\"></a>二、回溯算法</h1><p>回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。</p>\n<p>回溯算法的基本步骤如下：</p>\n<ul>\n<li>确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。</li>\n<li>递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。</li>\n<li>剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。</li>\n</ul>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>一些常见的回溯算法问题包括：</p>\n<ul>\n<li>全排列（Permutations）</li>\n<li>组合求和（Combination Sum）</li>\n<li>子集（Subsets）</li>\n<li>N皇后问题（N-Queens）</li>\n<li>单词搜索（Word Search）</li>\n<li>正则表达式匹配（Regular Expression Matching）等。</li>\n</ul>\n<p>回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。</p>\n<p><strong>回溯算法框架：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Value&gt; result;</span><br><span class=\"line\">void backtrack(路径， 选择列表) &#123;</span><br><span class=\"line\">    if (满足结束条件) &#123;</span><br><span class=\"line\">        result.add(路径);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (选择 ： 选择列表) &#123;</span><br><span class=\"line\">        做选择;</span><br><span class=\"line\">        backtrack(路径， 选择列表);</span><br><span class=\"line\">        撤销选择;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><p>全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>首先，我们可以使用递归来实现回溯算法。</li>\n<li>使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。</li>\n<li>递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。</li>\n<li>在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。</li>\n<li>在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。</li>\n</ol>\n<p><strong>题目：</strong></p>\n<p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p>\n<p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]</p>\n<p>示例 3：<br>输入：nums &#x3D; [1]<br>输出：[[1]]</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 6<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有整数 互不相同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PermutationsBacktracking &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; permutations = permute(nums);</span><br><span class=\"line\">        for (List&lt;Integer&gt; permutation : permutations) &#123;</span><br><span class=\"line\">            System.out.println(permutation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化了一个空的结果列表</span><br><span class=\"line\">    public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // 全排列</span><br><span class=\"line\">        backtrack(nums, new ArrayList&lt;&gt;(), result);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 回溯函数，用于生成全排列</span><br><span class=\"line\">     * @param nums      数组 【1，2，3】</span><br><span class=\"line\">     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素</span><br><span class=\"line\">     * @param result    存储全排列结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void backtrack(int[] nums, List&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class=\"line\">        // 到达叶子节点，将路径装入结果列表</span><br><span class=\"line\">        if (track.size() == nums.length) &#123;</span><br><span class=\"line\">            result.add(new ArrayList&lt;&gt;(track));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 尝试每个未使用的元素</span><br><span class=\"line\">        for (int num : nums) &#123;</span><br><span class=\"line\">            if (track.contains(num)) &#123;</span><br><span class=\"line\">                // 如果当前数字已经在排列中，跳过</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            track.add(num);</span><br><span class=\"line\">            // 递归调用</span><br><span class=\"line\">            backtrack(nums, track, result);</span><br><span class=\"line\">            // 回溯，移除最后一个元素</span><br><span class=\"line\">            track.remove(track.size() - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3]</span><br><span class=\"line\">[1, 3, 2]</span><br><span class=\"line\">[2, 1, 3]</span><br><span class=\"line\">[2, 3, 1]</span><br><span class=\"line\">[3, 1, 2]</span><br><span class=\"line\">[3, 2, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、贪心算法\"><a href=\"#三、贪心算法\" class=\"headerlink\" title=\"三、贪心算法\"></a>三、贪心算法</h1><p><strong>核心思想：</strong><br>贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。</p>\n<p>贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。</p>\n<p><strong>贪心算法的一般步骤如下</strong>：</p>\n<ol>\n<li>定义问题的解空间，即所有可能的解组成的集合。</li>\n<li>制定选择策略，即在每一步都选择一个局部最优解。</li>\n<li>确定是否满足问题的约束条件，即该解是否可行。</li>\n<li>判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。</li>\n</ol>\n<p>需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。</p>\n<p><strong>常见算法题：</strong></p>\n<ol>\n<li>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</li>\n<li>区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。</li>\n<li>分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。</li>\n<li>买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。</li>\n<li>跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。</li>\n<li>柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。</li>\n<li>汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。</li>\n<li>分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。</li>\n<li>非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。</li>\n<li>跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。</li>\n</ol>\n<h2 id=\"零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"><a href=\"#零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\" class=\"headerlink\" title=\"零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"></a>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</h2><p>在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。</p>\n<p>贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。</p>\n<p><strong>解：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CoinChangeGreedy &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] coins = &#123;1, 2, 5&#125;; // 零钱的面额</span><br><span class=\"line\">        int amount = 11; // 要兑换的金额</span><br><span class=\"line\">        int numCoins = coinChange(coins, amount);</span><br><span class=\"line\">        System.out.println(&quot;最少需要的硬币数：&quot; + numCoins);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param coins    硬币面额</span><br><span class=\"line\">     * @param amount   要兑换的金额</span><br><span class=\"line\">     * @return 最少使用硬币数目</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int coinChange(int[] coins, int amount) &#123;</span><br><span class=\"line\">        // 面额按从小到大排序</span><br><span class=\"line\">        Arrays.sort(coins);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 记录硬币数量</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        // 从最大面额的硬币开始尝试</span><br><span class=\"line\">        int index = coins.length - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        while (amount &gt; 0 &amp;&amp; index &gt;= 0) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (coins[index] &lt;= amount) &#123;</span><br><span class=\"line\">                // 尝试使用当前面额的硬币数量</span><br><span class=\"line\">                int numCoins = amount / coins[index];</span><br><span class=\"line\">                count += numCoins;</span><br><span class=\"line\">                amount -= numCoins * coins[index];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 尝试下一个面额的硬币</span><br><span class=\"line\">            index--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换</span><br><span class=\"line\">        return amount == 0 ? count : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最少需要的硬币数：3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。&#x3D;&#x3D;注意&#x3D;&#x3D;，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。</p>\n<p>在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clm29i98y000188th1ad5f6lr","category_id":"clm29i994000488th6uur00oa","_id":"clm29i998000d88thghd96i9a"},{"post_id":"clm29i98y000188th1ad5f6lr","category_id":"clm29i997000988th2x4j8xvm","_id":"clm29i998000f88thbuxc9cq2"},{"post_id":"clm29i992000388thdon7blnr","category_id":"clm29i996000788thdgxb0s9c","_id":"clm29i999000i88th0st053i7"},{"post_id":"clm29i992000388thdon7blnr","category_id":"clm29i997000b88th6jjk7n76","_id":"clm29i999000l88th3fj5aem2"},{"post_id":"clm29i99r000r88th0f98chat","category_id":"clm29i99s000t88th311gezw7","_id":"clm29i99v001388th9x9i7068"},{"post_id":"clm29i99r000r88th0f98chat","category_id":"clm29i99t000x88thbt7eb2x9","_id":"clm29i99v001588th4gni3hky"},{"post_id":"clm29i99s000s88th11sj2a0g","category_id":"clm29i99t000v88th29ipe58z","_id":"clm29i99w001988th6vv990ia"},{"post_id":"clm29i99s000s88th11sj2a0g","category_id":"clm29i99u001188th2iecdwoe","_id":"clm29i99w001a88tha9vnhq4f"},{"post_id":"clm29i99s000s88th11sj2a0g","category_id":"clm29i99v001688th2u7v21le","_id":"clm29i99w001b88th3dc9eadv"},{"post_id":"clm29i9a6001h88thf2qx0lt0","category_id":"clm29i9a6001i88th07zy8nmy","_id":"clm29i9a8001q88thhsobh4n9"},{"post_id":"clm29i9a6001h88thf2qx0lt0","category_id":"clm29i9a7001l88thf99fbrkv","_id":"clm29i9a8001s88th1ge6hmvl"},{"post_id":"clm29i9a6001h88thf2qx0lt0","category_id":"clm29i9a8001n88theujgaprd","_id":"clm29i9a9001u88th5cr9hfoa"}],"PostTag":[{"post_id":"clm29i98y000188th1ad5f6lr","tag_id":"clm29i995000588thfzvmdg0v","_id":"clm29i998000g88thhhjocifi"},{"post_id":"clm29i98y000188th1ad5f6lr","tag_id":"clm29i996000888th52hibdzn","_id":"clm29i999000h88thaii40tew"},{"post_id":"clm29i98y000188th1ad5f6lr","tag_id":"clm29i997000a88th17zh48v3","_id":"clm29i999000k88th7g1fdc8j"},{"post_id":"clm29i98y000188th1ad5f6lr","tag_id":"clm29i998000c88th4sn0fn8s","_id":"clm29i999000m88th85ip0ln3"},{"post_id":"clm29i992000388thdon7blnr","tag_id":"clm29i998000e88thadv20fjo","_id":"clm29i99a000o88th4a0y8tyx"},{"post_id":"clm29i992000388thdon7blnr","tag_id":"clm29i999000j88th0msihua8","_id":"clm29i99a000p88th2nnnc47g"},{"post_id":"clm29i992000388thdon7blnr","tag_id":"clm29i999000n88th5rl49qfu","_id":"clm29i99a000q88th1lcb2891"},{"post_id":"clm29i99r000r88th0f98chat","tag_id":"clm29i99s000u88thb6cqgzv7","_id":"clm29i99u000z88th3jrafnxj"},{"post_id":"clm29i99r000r88th0f98chat","tag_id":"clm29i99t000w88th12qy2ea8","_id":"clm29i99u001088thcqlo19rt"},{"post_id":"clm29i99s000s88th11sj2a0g","tag_id":"clm29i99u000y88th4vza8uwy","_id":"clm29i99w001c88thcjq30adn"},{"post_id":"clm29i99s000s88th11sj2a0g","tag_id":"clm29i99u001288thfkl99o4y","_id":"clm29i99w001d88th5u3uc6jb"},{"post_id":"clm29i99s000s88th11sj2a0g","tag_id":"clm29i99v001488th49h5470u","_id":"clm29i99w001e88th2nxf9x8l"},{"post_id":"clm29i99s000s88th11sj2a0g","tag_id":"clm29i99v001788th9cf3h54d","_id":"clm29i99x001f88th20692ys8"},{"post_id":"clm29i99s000s88th11sj2a0g","tag_id":"clm29i99w001888th8fajgpmj","_id":"clm29i99x001g88th67zg1wjk"},{"post_id":"clm29i9a6001h88thf2qx0lt0","tag_id":"clm29i9a7001j88thggv24vvg","_id":"clm29i9a8001p88thajqe43g6"},{"post_id":"clm29i9a6001h88thf2qx0lt0","tag_id":"clm29i9a7001k88th79pl7t2z","_id":"clm29i9a8001r88th00ntedzn"},{"post_id":"clm29i9a6001h88thf2qx0lt0","tag_id":"clm29i9a7001m88thdo2ag49x","_id":"clm29i9a9001t88th2bco4p55"},{"post_id":"clm29i9a6001h88thf2qx0lt0","tag_id":"clm29i9a8001o88th7grh9w7j","_id":"clm29i9a9001v88th8af1bik3"}],"Tag":[{"name":"github仓库","_id":"clm29i995000588thfzvmdg0v"},{"name":"github","_id":"clm29i996000888th52hibdzn"},{"name":"git","_id":"clm29i997000a88th17zh48v3"},{"name":"本地代码","_id":"clm29i998000c88th4sn0fn8s"},{"name":"Stream流","_id":"clm29i998000e88thadv20fjo"},{"name":"JDK 1.8","_id":"clm29i999000j88th0msihua8"},{"name":"List转化为Map","_id":"clm29i999000n88th5rl49qfu"},{"name":"OOM","_id":"clm29i99s000u88thb6cqgzv7"},{"name":"内存溢出","_id":"clm29i99t000w88th12qy2ea8"},{"name":"Explain执行计划","_id":"clm29i99u000y88th4vza8uwy"},{"name":"索引","_id":"clm29i99u001288thfkl99o4y"},{"name":"mysql优化实践","_id":"clm29i99v001488th49h5470u"},{"name":"B+树索引","_id":"clm29i99v001788th9cf3h54d"},{"name":"SQL慢查询优化","_id":"clm29i99w001888th8fajgpmj"},{"name":"算法","_id":"clm29i9a7001j88thggv24vvg"},{"name":"动态规划","_id":"clm29i9a7001k88th79pl7t2z"},{"name":"贪心算法","_id":"clm29i9a7001m88thdo2ag49x"},{"name":"回溯算法","_id":"clm29i9a8001o88th7grh9w7j"}]}}