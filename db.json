{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/monkeyHand.jpg","path":"img/monkeyHand.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/suanfa.png","path":"img/suanfa.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/bg-cover.jpeg","path":"img/bg-cover.jpeg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/githubImage.jpg","path":"img/githubImage.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java_stream.jpg","path":"img/java_stream.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-1.png","path":"img/java-stream-1.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-2.png","path":"img/java-stream-2.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-3.png","path":"img/java-stream-3.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-4.png","path":"img/java-stream-4.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-5.png","path":"img/java-stream-5.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/java-stream-6.png","path":"img/java-stream-6.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/link.yml","hash":"90169648cc2f167f95f30f4d2ac6a56477ff9bf4","modified":1693566922043},{"_id":"source/_posts/Algorithm.md","hash":"beb6f4179149473e3afb19087f3f246d22289438","modified":1693569595328},{"_id":"source/link/index.md","hash":"77d6585cce9e319b6c4de9561d129568b9f281f3","modified":1693566741262},{"_id":"source/categories/index.md","hash":"18a5dc5b164c5ecedf3fc3fee35e6611a8860044","modified":1693566710275},{"_id":"source/tags/index.md","hash":"60231d8c5df2a77e9f4ae14c8f5b33a9cbefa3f6","modified":1693566625134},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1693501706455},{"_id":"themes/butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1693501706456},{"_id":"themes/butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1693501706456},{"_id":"themes/butterfly/_config.yml","hash":"475c6d706bdaa55420c536cdfdbf65ea8fa6d47b","modified":1693580716508},{"_id":"themes/butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1693501706500},{"_id":"themes/butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1693501706500},{"_id":"themes/butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1693501706457},{"_id":"themes/butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1693501706457},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1693501706458},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1693501706458},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1693501706459},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1693501706459},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1693501706499},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1693501706499},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1693501706499},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1693501706500},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"92683cb785a29e5a73701b33dba73d3afac268c3","modified":1693501706454},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1693501706454},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1693501706454},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1693501706455},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1693501706455},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1693501706459},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1693501706461},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1693501706461},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"b50b0afdc41c54279587410c3f82c8cb3c5ff46d","modified":1693501706461},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1693501706467},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1693501706471},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1693501706473},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1693501706473},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1693501706501},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1693501706501},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1693501706502},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1693501706502},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1693501706502},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1693501706503},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1693501706504},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1693501706504},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1693501706504},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1693501706505},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1693501706505},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1693501706506},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1693501706506},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1693501706507},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1693501706507},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1693501706508},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1693501706508},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1693501706508},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1693501706509},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1693501706509},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1693501706510},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1693501706511},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1693501706529},{"_id":"themes/butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1693501706529},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1693501706530},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1693501706530},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1693501706531},{"_id":"themes/butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1693501706532},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1693501706532},{"_id":"themes/butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1693501706533},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1693501706462},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1693501706462},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1693501706463},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1693501706463},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1693501706462},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1693501706463},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1693501706463},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1693501706464},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1693501706465},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1693501706465},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1693501706465},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1693501706466},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1693501706466},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1693501706466},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1693501706468},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1693501706468},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1693501706468},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1693501706469},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1693501706469},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1693501706470},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1693501706471},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1693501706471},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1693501706474},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1693501706485},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1693501706489},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1693501706490},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1693501706490},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1693501706494},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1693501706495},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1693501706496},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1693501706496},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1693501706496},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1693501706497},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1693501706497},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1693501706497},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1693501706498},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1693501706498},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1693501706512},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1693501706499},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1693501706512},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1693501706513},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1693501706514},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1693501706515},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1693501706515},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1693501706516},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1693501706516},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1693501706516},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1693501706517},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1693501706517},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1693501706518},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1693501706519},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1693501706519},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1693501706520},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1693501706521},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1693501706521},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1693501706522},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1693501706521},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1693501706522},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1693501706522},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1693501706523},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1693501706523},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1693501706524},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1693501706525},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1693501706524},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1693501706525},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1693501706526},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1693501706526},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1693501706527},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1693501706526},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1693501706527},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1693501706527},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1693501706528},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1693501706528},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1693501706528},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1693501706532},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1693501706532},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1693501706474},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1693501706474},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1693501706475},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1693501706475},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1693501706475},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1693501706476},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1693501706476},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1693501706476},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1693501706477},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1693501706477},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1693501706478},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1693501706478},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1693501706478},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1693501706479},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1693501706479},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1693501706479},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1693501706480},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1693501706480},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1693501706481},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1693501706481},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1693501706482},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1693501706483},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1693501706482},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1693501706482},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1693501706483},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1693501706483},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1693501706484},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1693501706484},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1693501706484},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1693501706485},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1693501706486},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1693501706487},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1693501706487},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1693501706488},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1693501706489},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1693501706489},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1693501706492},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1693501706492},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1693501706494},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1693501706494},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1693501706491},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1693501706491},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1693501706491},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1693501706492},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1693501706513},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1693501706513},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1693501706514},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1693501706514},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1693501706514},{"_id":"themes/butterfly/source/img/monkeyHand.jpg","hash":"ac095c9dbbdd9730534040696204e44f1bde995b","modified":1693503160780},{"_id":"themes/butterfly/source/img/bg.jpg","hash":"f22a82dbb773cc14ffc52113729f78fc3e21bc6a","modified":1693502010883},{"_id":"themes/butterfly/source/img/bg-cover.jpeg","hash":"af30216fc80a250f79550b0968a9891f3a2518a6","modified":1693503735685},{"_id":"public/search.xml","hash":"158af2d86a2e468fa2524f11939b132ac5f688a3","modified":1693587780329},{"_id":"public/link/index.html","hash":"bbba69e3384ced5de0c4dd619c2b539d7d78094b","modified":1693587780329},{"_id":"public/categories/index.html","hash":"8a6f7ec17fbd9f56bb0175985dda1f0bbc3305c3","modified":1693587780329},{"_id":"public/tags/index.html","hash":"81b5788feeedfb12c401697c545e3a7870c729eb","modified":1693587780329},{"_id":"public/2023/08/01/Algorithm/index.html","hash":"e8203ca2aefd800416ddf6333a195597c2926815","modified":1693587093119},{"_id":"public/categories/算法/index.html","hash":"797a1e4628df73755fb32f4e1ae5290089909eac","modified":1693587780329},{"_id":"public/categories/算法/动态规划/index.html","hash":"aadc8a3ebb985bb4bf66d097bd2fcfe6c20e3ea9","modified":1693587780329},{"_id":"public/categories/算法/动态规划/回溯算法/index.html","hash":"66f6ce590e51d436909d0e54ae0376f01a572e3b","modified":1693587780329},{"_id":"public/archives/2023/index.html","hash":"291182b1f96660ceda880310babce19ffdc50638","modified":1693587780329},{"_id":"public/index.html","hash":"fcb170d89f0e23c97b5acd30db92922439bc2610","modified":1693587780329},{"_id":"public/archives/index.html","hash":"0855c1b51a4aca4252da722ebe2cb73149a5d867","modified":1693587780329},{"_id":"public/archives/2023/08/index.html","hash":"7c597aa63bdc49017f1565091cf82db9ef7bcb47","modified":1693587780329},{"_id":"public/tags/算法/index.html","hash":"4454a1162dce73cf11e732977ad24245ca678c04","modified":1693587780329},{"_id":"public/tags/动态规划/index.html","hash":"bfea296b4de13ac7d6924cba0a252cf8a5ebf289","modified":1693587780329},{"_id":"public/tags/回溯算法/index.html","hash":"05371abe56b0ccd314ced9469d6ea8b5f11efad7","modified":1693587780329},{"_id":"public/tags/贪心算法/index.html","hash":"6279bbfd2624dbdebedd0e13717b8c927bcdebd3","modified":1693587780329},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1693572045807},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1693572045807},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1693572045807},{"_id":"public/img/monkeyHand.jpg","hash":"ac095c9dbbdd9730534040696204e44f1bde995b","modified":1693572045807},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1693572045807},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1693572045807},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1693572045807},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1693572045807},{"_id":"public/css/index.css","hash":"d0ae3b76e56e8b518f3b97fb24656fd845de38c5","modified":1693572045807},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1693572045807},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1693572045807},{"_id":"public/img/bg.jpg","hash":"f22a82dbb773cc14ffc52113729f78fc3e21bc6a","modified":1693572045807},{"_id":"public/img/bg-cover.jpeg","hash":"af30216fc80a250f79550b0968a9891f3a2518a6","modified":1693572045807},{"_id":"themes/butterfly/source/img/suanfa.png","hash":"90b516298ec51879146f807686aa55870c5b0519","modified":1693568587569},{"_id":"public/img/suanfa.png","hash":"90b516298ec51879146f807686aa55870c5b0519","modified":1693572112188},{"_id":"themes/butterfly/source/img/bg-cover.jpg","hash":"af30216fc80a250f79550b0968a9891f3a2518a6","modified":1693503735685},{"_id":"public/img/bg-cover.jpg","hash":"af30216fc80a250f79550b0968a9891f3a2518a6","modified":1693572490631},{"_id":"themes/butterfly/source/img/wechat.jpg","hash":"490cf3bfb19c8f7d019943b1910efdb03f6ad00b","modified":1693569915508},{"_id":"public/img/wechat.jpg","hash":"490cf3bfb19c8f7d019943b1910efdb03f6ad00b","modified":1693580666272},{"_id":"source/_posts/将本地代码提交至github仓库.md","hash":"ed4a2702963f46da3e504f54d3767466b6243797","modified":1693586003724},{"_id":"themes/butterfly/source/img/githubImage.jpg","hash":"762bc8312e83001222bdf28b4ca8b5c24de11745","modified":1693585801951},{"_id":"public/2018/01/01/将本地代码提交至github仓库/index.html","hash":"0c8e141e19484e77642708622e957c714df1939f","modified":1693587093119},{"_id":"public/archives/2018/index.html","hash":"b36a8545c64f3b52188d845d65e09bf3ca2324ce","modified":1693587780329},{"_id":"public/archives/2018/01/index.html","hash":"426463c80284079c374d6f696a455fd7bfeb2d40","modified":1693587780329},{"_id":"public/categories/github仓库/index.html","hash":"e3b64e962ea7679f77777cc9cad897151960a83f","modified":1693587780329},{"_id":"public/categories/github仓库/github/index.html","hash":"74517342567e545e39aec38fa2708badd0ea4a64","modified":1693587780329},{"_id":"public/tags/github仓库/index.html","hash":"4fbf7ab8164dd02ee95890df37a7afef13617619","modified":1693587780329},{"_id":"public/tags/github/index.html","hash":"45dbaf87f7c77aaba64b6f829ee892c93dededc9","modified":1693587780329},{"_id":"public/tags/git/index.html","hash":"eb00257b8206a908ce7421cfde05641304811608","modified":1693587780329},{"_id":"public/tags/本地代码/index.html","hash":"d4f12dceb3781856d58453ab4a48c17b19792ec6","modified":1693587780329},{"_id":"public/img/githubImage.jpg","hash":"762bc8312e83001222bdf28b4ca8b5c24de11745","modified":1693585905710},{"_id":"source/_posts/JAVA之用Stream流将List转化为Map.md","hash":"de7b25a149916fb258d1291fd157f15975548ed5","modified":1693587770289},{"_id":"themes/butterfly/source/img/java_stream.jpg","hash":"efafa2831e18bcc735df78003545507dc153dfd5","modified":1693587037612},{"_id":"public/2019/02/01/JAVA之用Stream流将List转化为Map/index.html","hash":"987246504a93acbb88726fda205316da8a9fffff","modified":1693587780329},{"_id":"public/categories/Stream流/index.html","hash":"12ba88efc85f094c6e38092423a60709f574c9c6","modified":1693587780329},{"_id":"public/categories/Stream流/List转化为Map/index.html","hash":"0ead9ae9732daea666d3b123c7d69bdd8e13df12","modified":1693587780329},{"_id":"public/archives/2019/index.html","hash":"81f44ca989330a50f8067b87c59b3f35db144c5c","modified":1693587780329},{"_id":"public/archives/2019/02/index.html","hash":"5dfba2010506d9b82ef0daa2273f8606bf354e7f","modified":1693587780329},{"_id":"public/tags/Stream流/index.html","hash":"65a3b43784e6a2cc6e91fc54d7162b2028a7307d","modified":1693587780329},{"_id":"public/tags/JDK-1-8/index.html","hash":"a648c980d3400be881931675666cfc46c5e5dcca","modified":1693587780329},{"_id":"public/tags/List转化为Map/index.html","hash":"7fd4cf28cde57881bc89b58f52947d06a1fc8d79","modified":1693587780329},{"_id":"public/img/java_stream.jpg","hash":"efafa2831e18bcc735df78003545507dc153dfd5","modified":1693587093119},{"_id":"themes/butterfly/source/img/java-stream-1.png","hash":"be068ed1d654e82010aac3bebae03ff38055b59a","modified":1693587268141},{"_id":"public/img/java-stream-1.png","hash":"be068ed1d654e82010aac3bebae03ff38055b59a","modified":1693587533600},{"_id":"themes/butterfly/source/img/java-stream-2.png","hash":"88b15cd36c8281e94f9cedbed1bb40e431155b16","modified":1693587586028},{"_id":"themes/butterfly/source/img/java-stream-3.png","hash":"1a2fce5a6b7e57c454464035c3c6a38296fedf9b","modified":1693587634336},{"_id":"themes/butterfly/source/img/java-stream-4.png","hash":"0cacfb4e34cbd5c017510a03a06605cad6d6715b","modified":1693587680951},{"_id":"themes/butterfly/source/img/java-stream-5.png","hash":"93476ef6eae523c7717f9ba8e57625c5602f2345","modified":1693587717842},{"_id":"themes/butterfly/source/img/java-stream-6.png","hash":"bcd658567df4d1ac34435c8949d1162bd350b568","modified":1693587753639},{"_id":"public/img/java-stream-4.png","hash":"0cacfb4e34cbd5c017510a03a06605cad6d6715b","modified":1693587780329},{"_id":"public/img/java-stream-2.png","hash":"88b15cd36c8281e94f9cedbed1bb40e431155b16","modified":1693587780329},{"_id":"public/img/java-stream-3.png","hash":"1a2fce5a6b7e57c454464035c3c6a38296fedf9b","modified":1693587780329},{"_id":"public/img/java-stream-5.png","hash":"93476ef6eae523c7717f9ba8e57625c5602f2345","modified":1693587780329},{"_id":"public/img/java-stream-6.png","hash":"bcd658567df4d1ac34435c8949d1162bd350b568","modified":1693587780329}],"Category":[{"name":"算法","_id":"clm0l2iae0004g4thfpvo52m7"},{"name":"动态规划","parent":"clm0l2iae0004g4thfpvo52m7","_id":"clm0l2iag0007g4thhzmt3dnb"},{"name":"回溯算法","parent":"clm0l2iag0007g4thhzmt3dnb","_id":"clm0l2iah0009g4th64wh4spg"},{"name":"github仓库","_id":"clm0tbkoh0001ssth3cjz74og"},{"name":"github","parent":"clm0tbkoh0001ssth3cjz74og","_id":"clm0tbkoj0004ssthc4qydvsl"},{"name":"Stream流","_id":"clm0u10wj0001ogth954e30ef"},{"name":"List转化为Map","parent":"clm0u10wj0001ogth954e30ef","_id":"clm0u10wl0004ogthfwjq0lvg"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"link","date":"2023-09-01T11:12:08.000Z","type":"link","_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-09-01 19:12:08\ntype: \"link\"\n---\n","updated":"2023-09-01T11:12:21.262Z","path":"link/index.html","comments":1,"layout":"page","_id":"clm0l2i9e0000g4th7wk1fudh","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":false,"excerpt":"","more":""},{"title":"categories","date":"2023-09-01T11:11:30.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-09-01 19:11:30\ntype: \"categories\"\n---\n","updated":"2023-09-01T11:11:50.275Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clm0l2i9h0001g4th09ag7t2x","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-09-01T11:09:22.000Z","type":"tags","orderby":"length","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-09-01 19:09:22\ntype: \"tags\"\norderby: length\norder: 1\n---\n","updated":"2023-09-01T11:10:25.134Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clm0l2i9i0002g4thdq1q63q2","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"Algorithm","date":"2023-08-01T04:27:18.000Z","top_img":"/img/suanfa.png","cover":"/img/suanfa.png","keywords":"Algorithm","description":"算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"_content":"# 一、动态规划\n\n动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过**将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解**。==动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率==。\n\n动态规划适用于满足以下两个条件的问题：\n\n1. 重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。\n\n2. 最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。\n\n动态规划通常有两种常见的方法：\n\n1. 自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。\n\n2. 自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。\n\n动态规划广泛应用于许多领域，例如：\n\n- 背包问题（Knapsack Problem）\n- 最短路径问题（Shortest Path Problem）\n- 最长公共子序列问题（Longest Common Subsequence Problem）\n- 斐波那契数列问题（Fibonacci Sequence Problem）\n- 编辑距离问题（Edit Distance Problem）\n- 最大子数组和问题（Maximum Subarray Sum Problem）\n- …等等\n\n总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。\n\n\n**大致步骤：**\n1. **定义子问题：** 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。\n\n2. **找出状态转移方程：** 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。\n\n3. **初始化：** 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。\n\n4. **自底向上求解（或者记忆化递归）：** 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。\n\n5. **存储中间结果：** 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。\n\n6. **得到最终解：** 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。\n\n7. **可选的优化：** 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。\n\n## 最长递增子序列\n\n**题目：**\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n示例 1：\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n示例 2：\n输入：nums = [0,1,0,3,2,3]\n输出：4\n\n示例 3：\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n \n提示：\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104\n\n**注意**「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的\n\n\n**思想解释：**\n1. 我们使用一个数组 `dp` 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。\n2. 我们从数组的第二个元素开始遍历，对于每个元素 `nums[i]`，我们再遍历它之前的所有元素 `nums[j]`（`j < i`）。如果 `nums[i]` 大于 `nums[j]`，说明可以将 `nums[i]` 加入以 `nums[j]` 结尾的子序列，从而构成一个更长的递增子序列。我们更新 `dp[i]` 为 `dp[j] + 1`，表示以 `nums[i]` 结尾的最长递增子序列长度。\n3. 在内层循环中，我们不断更新 `dp[i]`，找到以当前元素 `nums[i]` 结尾的最长递增子序列长度。\n4. 在整个过程中，我们维护一个全局变量 `maxLen`，记录最长递增子序列的长度。\n5. 最终，遍历完整个数组后，`maxLen` 就是最长递增子序列的长度。\n\n\n```java\npublic class LongestIncreasingSubsequence {\n    public static int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int[] dp = new int[nums.length]; // dp[i] 表示以 nums[i] 结尾的最长递增子序列长度\n        dp[0] = 1; // 初始化，单个元素也构成递增子序列\n        \n        int maxLen = 1; // 最长递增子序列长度\n        for (int i = 1; i < nums.length; i++) {\n            dp[i] = 1; // 默认以当前元素为结尾的子序列长度为 1\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1); // 更新最长递增子序列长度\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]); // 更新全局最长长度\n        }\n        \n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};\n        int lisLength = lengthOfLIS(nums);\n        System.out.println(\"Length of Longest Increasing Subsequence: \" + lisLength);\n    }\n}\n```\n\n\n## 正则表达式匹配\n\n\n**题目：**\n请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\n\n示例 1:\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n示例 2:\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n示例 3:\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n\n示例 4:\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n示例 5:\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。\n\n**解题思路如下：**\n1. 我们可以使用动态规划来解决正则表达式匹配问题。\n2. 定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。\n3. 初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。\n4. 遍历字符串和正则表达式的每个字符，逐步填充dp数组。\n5. 如果s[i]和p[j]相等，或者p[j]为'.'，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。\n6. 如果p[j]为'*'，则需要考虑两种情况：\n\n```\n-  '*'表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。\n-  '*'表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为'.'。\n```\n\n7. 其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。\n8. 最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。\n\n\n```java\npublic class RegularExpressionMatching {\n    public static boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        \n        // dp[i][j]表示s的前i个字符和p的前j个字符是否匹配\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        \n        // 空字符串和空正则表达式匹配\n        dp[0][0] = true;\n        \n        // 处理空正则表达式可以匹配的情况\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n        \n        // 填充dp表格\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                char sc = s.charAt(i - 1);\n                char pc = p.charAt(j - 1);\n                \n                if (sc == pc || pc == '.') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (pc == '*') {\n                    char prevPc = p.charAt(j - 2);\n                    if (prevPc == sc || prevPc == '.') {\n                        // 匹配0次、1次或多次\n                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2];\n                    } else {\n                        // 匹配0次\n                        dp[i][j] = dp[i][j - 2];\n                    }\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String s = \"mississippi\";\n        String p = \"mis*is*p*.\";\n        \n        boolean result = isMatch(s, p);\n        System.out.println(\"Is match: \" + result);\n    }\n}\n```\n注释解释：\n1. `dp[i][j]`表示s的前i个字符和p的前j个字符是否匹配。\n2. 初始化：空字符串和空正则表达式匹配，`dp[0][0] = true`。\n3. 处理空正则表达式可以匹配的情况：如果p的某个字符是'*'，那么它可以匹配0次，将`dp[0][j]`设置为`dp[0][j-2]`。\n4. 填充dp表格：根据字符匹配和'*'的特性，更新`dp[i][j]`的值。\n5. 最终结：`dp[m][n]`表示s的全部字符和p的全部字符是否匹配。\n\n## 最长回文子串\n回文串是指正着读和倒着读都一样的字符串。例如，\"aba\"、\"abba\"和\"level\"都是回文串。\n\n**题目：**\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n\n示例 1：\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n\n示例 2：\n输入：s = \"cbbd\"\n输出：\"bb\"\n \n提示：\n1 <= s.length <= 1000\ns 仅由数字和英文字母组成\n\n**解题思路：**\n1. 我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。\n2. 初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] = true。\n3. 遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。\n4. 对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]。\n5. 如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。\n6. 最终得到的最长回文子串就是最长的回文串。\n\n**解法：**\n\n```java\npublic class LongestPalindromeSubstring {\n    public static String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        int start = 0; // 记录最长回文子串的起始位置\n        int maxLength = 1; // 记录最长回文子串的长度\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                start = i;\n                maxLength = 2;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    start = i;\n                    maxLength = len;\n                }\n            }\n        }\n        \n        return s.substring(start, start + maxLength);\n    }\n\n    public static void main(String[] args) {\n        String input = \"babad\";\n        String longestPalindrome = longestPalindrome(input);\n        System.out.println(\"Longest Palindrome Substring: \" + longestPalindrome);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。\n5. 最终结果：根据`dp`数组的信息，找到最长回文子串的起始位置和长度，然后通过`substring`方法获取最长回文子串。\n注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。\n\n## 回文子串个数\n**题目：**\n给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n\n示例 1：\n输入：s = \"abc\"\n输出：3\n解释：三个回文子串: \"a\", \"b\", \"c\"\n\n示例 2：\n输入：s = \"aaa\"\n输出：6\n解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n \n提示：\n1 <= s.length <= 1000\ns 由小写英文字母组成\n\n**解法**：\n\n```java\npublic class CountPalindromicSubstrings {\n    public static int countSubstrings(String s) {\n        int n = s.length();\n        int count = 0; // 记录回文子串的个数\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n            count++;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                count++;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        String input = \"abc\";\n        int palindromeCount = countSubstrings(input);\n        System.out.println(\"Palindrome Substrings Count: \" + palindromeCount);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`，并且`count`加1。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`，并且`count`加1。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则`dp[i][j]`为true，同时`count`加1。\n5. 最终结果：返回`count`，即回文子串的个数。\n\n\n## 背包问题\n背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示在前i个物品中选择总重量不超过j的情况下的最大价值。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。\n3. 遍历物品和背包承载重量，对于每个物品和背包承载重量：\n- 如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以`dp[i][j]`的最大价值和`dp[i-1][j]`一样。\n- 如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为`j - weights[i]`，所以最大价值为`values[i] + dp[i-1][j-weights[i]]`；如果不放入物品i，则最大价值为`dp[i-1][j]`。我们选择两者中较大的值作为`dp[i][j]`的最大价值。其中 `weight[i]` 为物品 i 的重量，`value[i]` 为物品 i 的价值。\n4. 最后`dp[n][W]`即为问题的解，其中n表示物品的个数，W表示背包的承载重量。\n\n\n\n```\npublic class KnapsackProblem {\n\n    /**\n     *\n     * @param weights    物品的重量数组\n     * @param values     价值数组\n     * @param capacity   背包容量\n     * @return 最大价值\n     */\n    public static int knapsack(int[] weights, int[] values, int capacity) {\n\n        int n = weights.length;\n\n        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值\n        int[][] dp = new int[n + 1][capacity + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= capacity; j++) {\n                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值\n                if (weights[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);\n                }\n            }\n        }\n\n        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值\n        return dp[n][capacity];\n    }\n\n    public static void main(String[] args) {\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3, 4, 5, 6};\n        int capacity = 5;\n        int result = knapsack(weights, values, capacity);\n        System.out.println(\"Maximum value: \" + result);\n    }\n}\n\n```\n\n```\n// 输出结果\nMaximum value: 7\n\nProcess finished with exit code 0\n```\n\n## 最长公共子序列（Longest Common Subsequence）问题\n\n最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。\n\n给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。\n\n**解题思路：**\n1. 我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。\n3. 遍历两个序列的元素，对于每个元素`A[i]`和`B[j]`：\n-  如果`A[i]`和`B[j]`相等，说明它们可以作为最长公共子序列的一部分，因此`dp[i][j]`的值应该是`dp[i-1][j-1] + 1`，即在之前的最长公共子序列长度上加1。\n-  如果`A[i]`和`B[j]`不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取`dp[i-1][j]`和`dp[i][j-1]`中的较大值作为`dp[i][j]`的值。\n4. 最后，`dp[n][m]`即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。\n\n\n```\npublic class LongestCommonSubsequence {\n\n    public static int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n\n        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度\n        int[][] dp = new int[m + 1][n + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        // 返回 text1 和 text2 的最长公共子序列长度\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String text1 = \"abcde\";\n        String text2 = \"ace\";\n        int result = longestCommonSubsequence(text1, text2);\n        System.out.println(\"Longest Common Subsequence: \" + result);\n    }\n}\n```\n\n```\nLongest Common Subsequence: 3\n\nProcess finished with exit code 0\n```\n\n\n## 打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\n**题目：**\n\n一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n\n输入：nums = [2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n \n\n提示：\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 400\n\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。\n2. 初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。\n3. 遍历数组，对于每个房屋i，考虑两种情况：\n- 偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。\n- 不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。\n- 取两种情况中的较大值作为dp[i]的值。\n4. 最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。\n\n\n\n```\npublic class HouseRobberI {\n\n    /**\n     * @param nums 一个代表每个房屋存放金额的非负整数数组\n     * @return\n     */\n    public static int rob(int[] nums) {\n\n        int n = nums.length;\n\n        if (n == 0) {\n            return 0;\n        }\n\n        if (n == 1) {\n            return nums[0];\n        }\n\n        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < n; i++) {\n            // 在当前房屋偷窃或不偷窃之间选择最大值\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n\n        // 返回最后一个房屋偷窃或不偷窃的最大金额\n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {2, 7, 9, 3, 1};\n        int result = rob(nums);\n        System.out.println(\"Maximum amount: \" + result);\n    }\n}\n```\n\n```\nMaximum amount: 12\n\nProcess finished with exit code 0\n```\n\n\n# 二、回溯算法\n回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。\n\n回溯算法的基本步骤如下：\n- 确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。\n- 递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。\n- 剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。\n \n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n一些常见的回溯算法问题包括：\n- 全排列（Permutations）\n- 组合求和（Combination Sum）\n- 子集（Subsets）\n- N皇后问题（N-Queens）\n- 单词搜索（Word Search）\n- 正则表达式匹配（Regular Expression Matching）等。\n\n回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。\n\n**回溯算法框架：**\n```\nList<Value> result;\nvoid backtrack(路径， 选择列表) {\n    if (满足结束条件) {\n        result.add(路径);\n        return;\n    }\n    for (选择 ： 选择列表) {\n        做选择;\n        backtrack(路径， 选择列表);\n        撤销选择;\n    }\n}\n```\n\n## 全排列\n全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。\n\n**解题思路如下：**\n1. 首先，我们可以使用递归来实现回溯算法。\n1. 使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。\n1. 递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。\n1. 在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。\n1. 在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。\n\n**题目：**\n\n给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。\n\n \n示例 1：\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例 2：\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n\n示例 3：\n输入：nums = [1]\n输出：[[1]]\n \n提示：\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nnums 中的所有整数 互不相同\n\n\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PermutationsBacktracking {\n\n    public static void main(String[] args) {\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> permutations = permute(nums);\n        for (List<Integer> permutation : permutations) {\n            System.out.println(permutation);\n        }\n    }\n\n    // 初始化了一个空的结果列表\n    public static List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        // 全排列\n        backtrack(nums, new ArrayList<>(), result);\n        return result;\n    }\n\n\n    /**\n     * 回溯函数，用于生成全排列\n     * @param nums      数组 【1，2，3】\n     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素\n     * @param result    存储全排列结果\n     */\n    private static void backtrack(int[] nums, List<Integer> track, List<List<Integer>> result) {\n        // 到达叶子节点，将路径装入结果列表\n        if (track.size() == nums.length) {\n            result.add(new ArrayList<>(track));\n            return;\n        }\n\n        // 尝试每个未使用的元素\n        for (int num : nums) {\n            if (track.contains(num)) {\n                // 如果当前数字已经在排列中，跳过\n                continue;\n            }\n            track.add(num);\n            // 递归调用\n            backtrack(nums, track, result);\n            // 回溯，移除最后一个元素\n            track.remove(track.size() - 1);\n        }\n    }\n```\n\n```\n[1, 2, 3]\n[1, 3, 2]\n[2, 1, 3]\n[2, 3, 1]\n[3, 1, 2]\n[3, 2, 1]\n\nProcess finished with exit code 0\n```\n\n# 三、贪心算法\n\n**核心思想：**\n贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。\n\n贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。\n\n**贪心算法的一般步骤如下**：\n\n1. 定义问题的解空间，即所有可能的解组成的集合。\n1. 制定选择策略，即在每一步都选择一个局部最优解。\n1. 确定是否满足问题的约束条件，即该解是否可行。\n1. 判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。\n\n需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。\n\n**常见算法题：**\n\n1. 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n1. 区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。\n1. 分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。\n1. 买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。\n1. 跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。\n1. 柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。\n1. 汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。\n1. 分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。\n1. 非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。\n1. 跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。\n\n\n## 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n\n在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。\n\n贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。\n\n**解：**\n```\npublic class CoinChangeGreedy {\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 5}; // 零钱的面额\n        int amount = 11; // 要兑换的金额\n        int numCoins = coinChange(coins, amount);\n        System.out.println(\"最少需要的硬币数：\" + numCoins);\n    }\n\n    /**\n     *\n     * @param coins    硬币面额\n     * @param amount   要兑换的金额\n     * @return 最少使用硬币数目\n     */\n    public static int coinChange(int[] coins, int amount) {\n        // 面额按从小到大排序\n        Arrays.sort(coins);\n\n        // 记录硬币数量\n        int count = 0;\n        // 从最大面额的硬币开始尝试\n        int index = coins.length - 1;\n\n        while (amount > 0 && index >= 0) {\n\n            if (coins[index] <= amount) {\n                // 尝试使用当前面额的硬币数量\n                int numCoins = amount / coins[index];\n                count += numCoins;\n                amount -= numCoins * coins[index];\n            }\n            // 尝试下一个面额的硬币\n            index--;\n        }\n\n        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换\n        return amount == 0 ? count : -1;\n    }\n}\n```\n\n```\n最少需要的硬币数：3\n\nProcess finished with exit code 0\n```\n\n在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。==注意==，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。\n\n在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。\n\n","source":"_posts/Algorithm.md","raw":"---\ntitle: Algorithm\ndate: 2023-08-01 12:27:18\ntags:\n- 算法\n- 动态规划\n- 贪心算法\n- 回溯算法\ncategories:\n- 算法\n- 动态规划\n- 回溯算法\ntop_img: /img/suanfa.png\ncover: /img/suanfa.png\nkeywords: \"Algorithm\"\ndescription: \"算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。\"\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both \n    date_format: relative\n    categories: true \n    tags: true\n    label: true\n---\n# 一、动态规划\n\n动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过**将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解**。==动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率==。\n\n动态规划适用于满足以下两个条件的问题：\n\n1. 重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。\n\n2. 最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。\n\n动态规划通常有两种常见的方法：\n\n1. 自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。\n\n2. 自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。\n\n动态规划广泛应用于许多领域，例如：\n\n- 背包问题（Knapsack Problem）\n- 最短路径问题（Shortest Path Problem）\n- 最长公共子序列问题（Longest Common Subsequence Problem）\n- 斐波那契数列问题（Fibonacci Sequence Problem）\n- 编辑距离问题（Edit Distance Problem）\n- 最大子数组和问题（Maximum Subarray Sum Problem）\n- …等等\n\n总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。\n\n\n**大致步骤：**\n1. **定义子问题：** 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。\n\n2. **找出状态转移方程：** 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。\n\n3. **初始化：** 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。\n\n4. **自底向上求解（或者记忆化递归）：** 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。\n\n5. **存储中间结果：** 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。\n\n6. **得到最终解：** 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。\n\n7. **可选的优化：** 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。\n\n## 最长递增子序列\n\n**题目：**\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n\n示例 1：\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n示例 2：\n输入：nums = [0,1,0,3,2,3]\n输出：4\n\n示例 3：\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n \n提示：\n1 <= nums.length <= 2500\n-104 <= nums[i] <= 104\n\n**注意**「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的\n\n\n**思想解释：**\n1. 我们使用一个数组 `dp` 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。\n2. 我们从数组的第二个元素开始遍历，对于每个元素 `nums[i]`，我们再遍历它之前的所有元素 `nums[j]`（`j < i`）。如果 `nums[i]` 大于 `nums[j]`，说明可以将 `nums[i]` 加入以 `nums[j]` 结尾的子序列，从而构成一个更长的递增子序列。我们更新 `dp[i]` 为 `dp[j] + 1`，表示以 `nums[i]` 结尾的最长递增子序列长度。\n3. 在内层循环中，我们不断更新 `dp[i]`，找到以当前元素 `nums[i]` 结尾的最长递增子序列长度。\n4. 在整个过程中，我们维护一个全局变量 `maxLen`，记录最长递增子序列的长度。\n5. 最终，遍历完整个数组后，`maxLen` 就是最长递增子序列的长度。\n\n\n```java\npublic class LongestIncreasingSubsequence {\n    public static int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        \n        int[] dp = new int[nums.length]; // dp[i] 表示以 nums[i] 结尾的最长递增子序列长度\n        dp[0] = 1; // 初始化，单个元素也构成递增子序列\n        \n        int maxLen = 1; // 最长递增子序列长度\n        for (int i = 1; i < nums.length; i++) {\n            dp[i] = 1; // 默认以当前元素为结尾的子序列长度为 1\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1); // 更新最长递增子序列长度\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]); // 更新全局最长长度\n        }\n        \n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {10, 9, 2, 5, 3, 7, 101, 18};\n        int lisLength = lengthOfLIS(nums);\n        System.out.println(\"Length of Longest Increasing Subsequence: \" + lisLength);\n    }\n}\n```\n\n\n## 正则表达式匹配\n\n\n**题目：**\n请实现一个函数用来匹配包含'. '和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"ab*ac*a\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。\n\n示例 1:\n输入:\ns = \"aa\"\np = \"a\"\n输出: false\n解释: \"a\" 无法匹配 \"aa\" 整个字符串。\n\n示例 2:\n输入:\ns = \"aa\"\np = \"a*\"\n输出: true\n解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。\n\n示例 3:\n输入:\ns = \"ab\"\np = \".*\"\n输出: true\n解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。\n\n示例 4:\n输入:\ns = \"aab\"\np = \"c*a*b\"\n输出: true\n解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n示例 5:\n输入:\ns = \"mississippi\"\np = \"mis*is*p*.\"\n输出: false\ns 可能为空，且只包含从 a-z 的小写字母。\np 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 '*'。\n\n**解题思路如下：**\n1. 我们可以使用动态规划来解决正则表达式匹配问题。\n2. 定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。\n3. 初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。\n4. 遍历字符串和正则表达式的每个字符，逐步填充dp数组。\n5. 如果s[i]和p[j]相等，或者p[j]为'.'，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。\n6. 如果p[j]为'*'，则需要考虑两种情况：\n\n```\n-  '*'表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。\n-  '*'表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为'.'。\n```\n\n7. 其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。\n8. 最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。\n\n\n```java\npublic class RegularExpressionMatching {\n    public static boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        \n        // dp[i][j]表示s的前i个字符和p的前j个字符是否匹配\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        \n        // 空字符串和空正则表达式匹配\n        dp[0][0] = true;\n        \n        // 处理空正则表达式可以匹配的情况\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n        \n        // 填充dp表格\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                char sc = s.charAt(i - 1);\n                char pc = p.charAt(j - 1);\n                \n                if (sc == pc || pc == '.') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (pc == '*') {\n                    char prevPc = p.charAt(j - 2);\n                    if (prevPc == sc || prevPc == '.') {\n                        // 匹配0次、1次或多次\n                        dp[i][j] = dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2];\n                    } else {\n                        // 匹配0次\n                        dp[i][j] = dp[i][j - 2];\n                    }\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String s = \"mississippi\";\n        String p = \"mis*is*p*.\";\n        \n        boolean result = isMatch(s, p);\n        System.out.println(\"Is match: \" + result);\n    }\n}\n```\n注释解释：\n1. `dp[i][j]`表示s的前i个字符和p的前j个字符是否匹配。\n2. 初始化：空字符串和空正则表达式匹配，`dp[0][0] = true`。\n3. 处理空正则表达式可以匹配的情况：如果p的某个字符是'*'，那么它可以匹配0次，将`dp[0][j]`设置为`dp[0][j-2]`。\n4. 填充dp表格：根据字符匹配和'*'的特性，更新`dp[i][j]`的值。\n5. 最终结：`dp[m][n]`表示s的全部字符和p的全部字符是否匹配。\n\n## 最长回文子串\n回文串是指正着读和倒着读都一样的字符串。例如，\"aba\"、\"abba\"和\"level\"都是回文串。\n\n**题目：**\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n\n\n示例 1：\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n\n示例 2：\n输入：s = \"cbbd\"\n输出：\"bb\"\n \n提示：\n1 <= s.length <= 1000\ns 仅由数字和英文字母组成\n\n**解题思路：**\n1. 我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。\n2. 初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] = true。\n3. 遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。\n4. 对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] = (s[i] == s[j]) && dp[i+1][j-1]。\n5. 如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。\n6. 最终得到的最长回文子串就是最长的回文串。\n\n**解法：**\n\n```java\npublic class LongestPalindromeSubstring {\n    public static String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        int start = 0; // 记录最长回文子串的起始位置\n        int maxLength = 1; // 记录最长回文子串的长度\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                start = i;\n                maxLength = 2;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    start = i;\n                    maxLength = len;\n                }\n            }\n        }\n        \n        return s.substring(start, start + maxLength);\n    }\n\n    public static void main(String[] args) {\n        String input = \"babad\";\n        String longestPalindrome = longestPalindrome(input);\n        System.out.println(\"Longest Palindrome Substring: \" + longestPalindrome);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。\n5. 最终结果：根据`dp`数组的信息，找到最长回文子串的起始位置和长度，然后通过`substring`方法获取最长回文子串。\n注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。\n\n## 回文子串个数\n**题目：**\n给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n\n示例 1：\n输入：s = \"abc\"\n输出：3\n解释：三个回文子串: \"a\", \"b\", \"c\"\n\n示例 2：\n输入：s = \"aaa\"\n输出：6\n解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"\n \n提示：\n1 <= s.length <= 1000\ns 由小写英文字母组成\n\n**解法**：\n\n```java\npublic class CountPalindromicSubstrings {\n    public static int countSubstrings(String s) {\n        int n = s.length();\n        int count = 0; // 记录回文子串的个数\n        boolean[][] dp = new boolean[n][n]; // dp[i][j]表示s的子串从i到j是否为回文子串\n        \n        // 所有单个字符都是回文子串\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n            count++;\n        }\n        \n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                count++;\n            }\n        }\n        \n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1; // 子串的结束位置\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        String input = \"abc\";\n        int palindromeCount = countSubstrings(input);\n        System.out.println(\"Palindrome Substrings Count: \" + palindromeCount);\n    }\n}\n```\n\n注释解释：\n1. `dp[i][j]`表示s的子串从索引i到j是否是回文子串。\n2. 初始化：所有单个字符都是回文子串，即`dp[i][i] = true`，并且`count`加1。\n3. 检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即`dp[i][i+1] = true`，并且`count`加1。\n4. 检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则`dp[i][j]`为true，同时`count`加1。\n5. 最终结果：返回`count`，即回文子串的个数。\n\n\n## 背包问题\n背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示在前i个物品中选择总重量不超过j的情况下的最大价值。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。\n3. 遍历物品和背包承载重量，对于每个物品和背包承载重量：\n- 如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以`dp[i][j]`的最大价值和`dp[i-1][j]`一样。\n- 如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为`j - weights[i]`，所以最大价值为`values[i] + dp[i-1][j-weights[i]]`；如果不放入物品i，则最大价值为`dp[i-1][j]`。我们选择两者中较大的值作为`dp[i][j]`的最大价值。其中 `weight[i]` 为物品 i 的重量，`value[i]` 为物品 i 的价值。\n4. 最后`dp[n][W]`即为问题的解，其中n表示物品的个数，W表示背包的承载重量。\n\n\n\n```\npublic class KnapsackProblem {\n\n    /**\n     *\n     * @param weights    物品的重量数组\n     * @param values     价值数组\n     * @param capacity   背包容量\n     * @return 最大价值\n     */\n    public static int knapsack(int[] weights, int[] values, int capacity) {\n\n        int n = weights.length;\n\n        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值\n        int[][] dp = new int[n + 1][capacity + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= capacity; j++) {\n                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值\n                if (weights[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);\n                }\n            }\n        }\n\n        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值\n        return dp[n][capacity];\n    }\n\n    public static void main(String[] args) {\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3, 4, 5, 6};\n        int capacity = 5;\n        int result = knapsack(weights, values, capacity);\n        System.out.println(\"Maximum value: \" + result);\n    }\n}\n\n```\n\n```\n// 输出结果\nMaximum value: 7\n\nProcess finished with exit code 0\n```\n\n## 最长公共子序列（Longest Common Subsequence）问题\n\n最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。\n\n给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。\n\n**解题思路：**\n1. 我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组`dp`，其中`dp[i][j]`表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。\n2. 初始化`dp`数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。\n3. 遍历两个序列的元素，对于每个元素`A[i]`和`B[j]`：\n-  如果`A[i]`和`B[j]`相等，说明它们可以作为最长公共子序列的一部分，因此`dp[i][j]`的值应该是`dp[i-1][j-1] + 1`，即在之前的最长公共子序列长度上加1。\n-  如果`A[i]`和`B[j]`不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取`dp[i-1][j]`和`dp[i][j-1]`中的较大值作为`dp[i][j]`的值。\n4. 最后，`dp[n][m]`即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。\n\n\n```\npublic class LongestCommonSubsequence {\n\n    public static int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n\n        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度\n        int[][] dp = new int[m + 1][n + 1];\n\n        // 填充 dp 数组，进行状态转移\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        // 返回 text1 和 text2 的最长公共子序列长度\n        return dp[m][n];\n    }\n\n    public static void main(String[] args) {\n        String text1 = \"abcde\";\n        String text2 = \"ace\";\n        int result = longestCommonSubsequence(text1, text2);\n        System.out.println(\"Longest Common Subsequence: \" + result);\n    }\n}\n```\n\n```\nLongest Common Subsequence: 3\n\nProcess finished with exit code 0\n```\n\n\n## 打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\n**题目：**\n\n一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n \n\n示例 1：\n\n输入：nums = [1,2,3,1]\n输出：4\n解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n\n输入：nums = [2,7,9,3,1]\n输出：12\n解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n \n\n提示：\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 400\n\n\n**解题思路：**\n\n1. 我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。\n2. 初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。\n3. 遍历数组，对于每个房屋i，考虑两种情况：\n- 偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。\n- 不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。\n- 取两种情况中的较大值作为dp[i]的值。\n4. 最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。\n\n\n\n```\npublic class HouseRobberI {\n\n    /**\n     * @param nums 一个代表每个房屋存放金额的非负整数数组\n     * @return\n     */\n    public static int rob(int[] nums) {\n\n        int n = nums.length;\n\n        if (n == 0) {\n            return 0;\n        }\n\n        if (n == 1) {\n            return nums[0];\n        }\n\n        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < n; i++) {\n            // 在当前房屋偷窃或不偷窃之间选择最大值\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n        }\n\n        // 返回最后一个房屋偷窃或不偷窃的最大金额\n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {2, 7, 9, 3, 1};\n        int result = rob(nums);\n        System.out.println(\"Maximum amount: \" + result);\n    }\n}\n```\n\n```\nMaximum amount: 12\n\nProcess finished with exit code 0\n```\n\n\n# 二、回溯算法\n回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。\n\n回溯算法的基本步骤如下：\n- 确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。\n- 递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。\n- 剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。\n \n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。\n\n一些常见的回溯算法问题包括：\n- 全排列（Permutations）\n- 组合求和（Combination Sum）\n- 子集（Subsets）\n- N皇后问题（N-Queens）\n- 单词搜索（Word Search）\n- 正则表达式匹配（Regular Expression Matching）等。\n\n回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。\n\n**回溯算法框架：**\n```\nList<Value> result;\nvoid backtrack(路径， 选择列表) {\n    if (满足结束条件) {\n        result.add(路径);\n        return;\n    }\n    for (选择 ： 选择列表) {\n        做选择;\n        backtrack(路径， 选择列表);\n        撤销选择;\n    }\n}\n```\n\n## 全排列\n全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。\n\n**解题思路如下：**\n1. 首先，我们可以使用递归来实现回溯算法。\n1. 使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。\n1. 递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。\n1. 在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。\n1. 在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。\n\n**题目：**\n\n给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。\n\n \n示例 1：\n输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例 2：\n输入：nums = [0,1]\n输出：[[0,1],[1,0]]\n\n示例 3：\n输入：nums = [1]\n输出：[[1]]\n \n提示：\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nnums 中的所有整数 互不相同\n\n\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PermutationsBacktracking {\n\n    public static void main(String[] args) {\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> permutations = permute(nums);\n        for (List<Integer> permutation : permutations) {\n            System.out.println(permutation);\n        }\n    }\n\n    // 初始化了一个空的结果列表\n    public static List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        // 全排列\n        backtrack(nums, new ArrayList<>(), result);\n        return result;\n    }\n\n\n    /**\n     * 回溯函数，用于生成全排列\n     * @param nums      数组 【1，2，3】\n     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素\n     * @param result    存储全排列结果\n     */\n    private static void backtrack(int[] nums, List<Integer> track, List<List<Integer>> result) {\n        // 到达叶子节点，将路径装入结果列表\n        if (track.size() == nums.length) {\n            result.add(new ArrayList<>(track));\n            return;\n        }\n\n        // 尝试每个未使用的元素\n        for (int num : nums) {\n            if (track.contains(num)) {\n                // 如果当前数字已经在排列中，跳过\n                continue;\n            }\n            track.add(num);\n            // 递归调用\n            backtrack(nums, track, result);\n            // 回溯，移除最后一个元素\n            track.remove(track.size() - 1);\n        }\n    }\n```\n\n```\n[1, 2, 3]\n[1, 3, 2]\n[2, 1, 3]\n[2, 3, 1]\n[3, 1, 2]\n[3, 2, 1]\n\nProcess finished with exit code 0\n```\n\n# 三、贪心算法\n\n**核心思想：**\n贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。\n\n贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。\n\n**贪心算法的一般步骤如下**：\n\n1. 定义问题的解空间，即所有可能的解组成的集合。\n1. 制定选择策略，即在每一步都选择一个局部最优解。\n1. 确定是否满足问题的约束条件，即该解是否可行。\n1. 判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。\n\n需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。\n\n**常见算法题：**\n\n1. 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n1. 区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。\n1. 分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。\n1. 买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。\n1. 跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。\n1. 柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。\n1. 汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。\n1. 分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。\n1. 非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。\n1. 跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。\n\n\n## 零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\n\n在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。\n\n贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。\n\n**解：**\n```\npublic class CoinChangeGreedy {\n\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 5}; // 零钱的面额\n        int amount = 11; // 要兑换的金额\n        int numCoins = coinChange(coins, amount);\n        System.out.println(\"最少需要的硬币数：\" + numCoins);\n    }\n\n    /**\n     *\n     * @param coins    硬币面额\n     * @param amount   要兑换的金额\n     * @return 最少使用硬币数目\n     */\n    public static int coinChange(int[] coins, int amount) {\n        // 面额按从小到大排序\n        Arrays.sort(coins);\n\n        // 记录硬币数量\n        int count = 0;\n        // 从最大面额的硬币开始尝试\n        int index = coins.length - 1;\n\n        while (amount > 0 && index >= 0) {\n\n            if (coins[index] <= amount) {\n                // 尝试使用当前面额的硬币数量\n                int numCoins = amount / coins[index];\n                count += numCoins;\n                amount -= numCoins * coins[index];\n            }\n            // 尝试下一个面额的硬币\n            index--;\n        }\n\n        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换\n        return amount == 0 ? count : -1;\n    }\n}\n```\n\n```\n最少需要的硬币数：3\n\nProcess finished with exit code 0\n```\n\n在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。==注意==，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。\n\n在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。\n\n","slug":"Algorithm","published":1,"updated":"2023-09-01T11:59:55.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clm0l2iab0003g4thb3cqe7qu","content":"<h1 id=\"一、动态规划\"><a href=\"#一、动态规划\" class=\"headerlink\" title=\"一、动态规划\"></a>一、动态规划</h1><p>动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过<strong>将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解</strong>。&#x3D;&#x3D;动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率&#x3D;&#x3D;。</p>\n<p>动态规划适用于满足以下两个条件的问题：</p>\n<ol>\n<li><p>重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。</p>\n</li>\n<li><p>最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。</p>\n</li>\n</ol>\n<p>动态规划通常有两种常见的方法：</p>\n<ol>\n<li><p>自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。</p>\n</li>\n<li><p>自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。</p>\n</li>\n</ol>\n<p>动态规划广泛应用于许多领域，例如：</p>\n<ul>\n<li>背包问题（Knapsack Problem）</li>\n<li>最短路径问题（Shortest Path Problem）</li>\n<li>最长公共子序列问题（Longest Common Subsequence Problem）</li>\n<li>斐波那契数列问题（Fibonacci Sequence Problem）</li>\n<li>编辑距离问题（Edit Distance Problem）</li>\n<li>最大子数组和问题（Maximum Subarray Sum Problem）</li>\n<li>…等等</li>\n</ul>\n<p>总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。</p>\n<p><strong>大致步骤：</strong></p>\n<ol>\n<li><p><strong>定义子问题：</strong> 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。</p>\n</li>\n<li><p><strong>找出状态转移方程：</strong> 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。</p>\n</li>\n<li><p><strong>初始化：</strong> 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。</p>\n</li>\n<li><p><strong>自底向上求解（或者记忆化递归）：</strong> 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。</p>\n</li>\n<li><p><strong>存储中间结果：</strong> 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。</p>\n</li>\n<li><p><strong>得到最终解：</strong> 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。</p>\n</li>\n<li><p><strong>可选的优化：</strong> 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。</p>\n</li>\n</ol>\n<h2 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列\"></a>最长递增子序列</h2><p><strong>题目：</strong><br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>\n<p>示例 1：<br>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4</p>\n<p>示例 3：<br>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>\n<p><strong>注意</strong>「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的</p>\n<p><strong>思想解释：</strong></p>\n<ol>\n<li>我们使用一个数组 <code>dp</code> 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。</li>\n<li>我们从数组的第二个元素开始遍历，对于每个元素 <code>nums[i]</code>，我们再遍历它之前的所有元素 <code>nums[j]</code>（<code>j &lt; i</code>）。如果 <code>nums[i]</code> 大于 <code>nums[j]</code>，说明可以将 <code>nums[i]</code> 加入以 <code>nums[j]</code> 结尾的子序列，从而构成一个更长的递增子序列。我们更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code>，表示以 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在内层循环中，我们不断更新 <code>dp[i]</code>，找到以当前元素 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在整个过程中，我们维护一个全局变量 <code>maxLen</code>，记录最长递增子序列的长度。</li>\n<li>最终，遍历完整个数组后，<code>maxLen</code> 就是最长递增子序列的长度。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestIncreasingSubsequence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length]; <span class=\"comment\">// dp[i] 表示以 nums[i] 结尾的最长递增子序列长度</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化，单个元素也构成递增子序列</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 最长递增子序列长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">1</span>; <span class=\"comment\">// 默认以当前元素为结尾的子序列长度为 1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    dp[i] = Math.max(dp[i], dp[j] + <span class=\"number\">1</span>); <span class=\"comment\">// 更新最长递增子序列长度</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxLen = Math.max(maxLen, dp[i]); <span class=\"comment\">// 更新全局最长长度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">101</span>, <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lisLength</span> <span class=\"operator\">=</span> lengthOfLIS(nums);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Length of Longest Increasing Subsequence: &quot;</span> + lisLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"正则表达式匹配\"><a href=\"#正则表达式匹配\" class=\"headerlink\" title=\"正则表达式匹配\"></a>正则表达式匹配</h2><p><strong>题目：</strong><br>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>\n<p>示例 1:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>\n<p>示例 2:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>\n<p>示例 3:<br>输入:<br>s &#x3D; “ab”<br>p &#x3D; “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p>\n<p>示例 4:<br>输入:<br>s &#x3D; “aab”<br>p &#x3D; “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>\n<p>示例 5:<br>输入:<br>s &#x3D; “mississippi”<br>p &#x3D; “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决正则表达式匹配问题。</li>\n<li>定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。</li>\n<li>初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。</li>\n<li>遍历字符串和正则表达式的每个字符，逐步填充dp数组。</li>\n<li>如果s[i]和p[j]相等，或者p[j]为’.’，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。</li>\n<li>如果p[j]为’*’，则需要考虑两种情况：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。</span><br><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为&#x27;.&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。</li>\n<li>最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RegularExpressionMatching</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isMatch</span><span class=\"params\">(String s, String p)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> p.length();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j]表示s的前i个字符和p的前j个字符是否匹配</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 空字符串和空正则表达式匹配</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理空正则表达式可以匹配的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.charAt(j - <span class=\"number\">1</span>) == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 填充dp表格</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> s.charAt(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">pc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">1</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc == pc || pc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pc == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">char</span> <span class=\"variable\">prevPc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">2</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevPc == sc || prevPc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次、1次或多次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>] || dp[i - <span class=\"number\">1</span>][j] || dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mississippi&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mis*is*p*.&quot;</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> isMatch(s, p);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Is match: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的前i个字符和p的前j个字符是否匹配。</li>\n<li>初始化：空字符串和空正则表达式匹配，<code>dp[0][0] = true</code>。</li>\n<li>处理空正则表达式可以匹配的情况：如果p的某个字符是’*’，那么它可以匹配0次，将<code>dp[0][j]</code>设置为<code>dp[0][j-2]</code>。</li>\n<li>填充dp表格：根据字符匹配和’*’的特性，更新<code>dp[i][j]</code>的值。</li>\n<li>最终结：<code>dp[m][n]</code>表示s的全部字符和p的全部字符是否匹配。</li>\n</ol>\n<h2 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h2><p>回文串是指正着读和倒着读都一样的字符串。例如，”aba”、”abba”和”level”都是回文串。</p>\n<p><strong>题目：</strong><br>给你一个字符串 s，找到 s 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>\n<p>示例 1：<br>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>\n<p>示例 2：<br>输入：s &#x3D; “cbbd”<br>输出：”bb”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母组成</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。</li>\n<li>初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] &#x3D; true。</li>\n<li>遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。</li>\n<li>对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) &amp;&amp; dp[i+1][j-1]。</li>\n<li>如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。</li>\n<li>最终得到的最长回文子串就是最长的回文串。</li>\n</ol>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestPalindromeSubstring</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录最长回文子串的起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLength</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 记录最长回文子串的长度</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                start = i;</span><br><span class=\"line\">                maxLength = <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    start = i;</span><br><span class=\"line\">                    maxLength = len;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(start, start + maxLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;babad&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">longestPalindrome</span> <span class=\"operator\">=</span> longestPalindrome(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Longest Palindrome Substring: &quot;</span> + longestPalindrome);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。</li>\n<li>最终结果：根据<code>dp</code>数组的信息，找到最长回文子串的起始位置和长度，然后通过<code>substring</code>方法获取最长回文子串。<br>注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。</li>\n</ol>\n<h2 id=\"回文子串个数\"><a href=\"#回文子串个数\" class=\"headerlink\" title=\"回文子串个数\"></a>回文子串个数</h2><p><strong>题目：</strong><br>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n<p>示例 1：<br>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p>\n<p>示例 2：<br>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由小写英文字母组成</p>\n<p><strong>解法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountPalindromicSubstrings</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">countSubstrings</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录回文子串的个数</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">palindromeCount</span> <span class=\"operator\">=</span> countSubstrings(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Palindrome Substrings Count: &quot;</span> + palindromeCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则<code>dp[i][j]</code>为true，同时<code>count</code>加1。</li>\n<li>最终结果：返回<code>count</code>，即回文子串的个数。</li>\n</ol>\n<h2 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h2><p>背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示在前i个物品中选择总重量不超过j的情况下的最大价值。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。</li>\n<li>遍历物品和背包承载重量，对于每个物品和背包承载重量：</li>\n</ol>\n<ul>\n<li>如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以<code>dp[i][j]</code>的最大价值和<code>dp[i-1][j]</code>一样。</li>\n<li>如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为<code>j - weights[i]</code>，所以最大价值为<code>values[i] + dp[i-1][j-weights[i]]</code>；如果不放入物品i，则最大价值为<code>dp[i-1][j]</code>。我们选择两者中较大的值作为<code>dp[i][j]</code>的最大价值。其中 <code>weight[i]</code> 为物品 i 的重量，<code>value[i]</code> 为物品 i 的价值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后<code>dp[n][W]</code>即为问题的解，其中n表示物品的个数，W表示背包的承载重量。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class KnapsackProblem &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param weights    物品的重量数组</span><br><span class=\"line\">     * @param values     价值数组</span><br><span class=\"line\">     * @param capacity   背包容量</span><br><span class=\"line\">     * @return 最大价值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int knapsack(int[] weights, int[] values, int capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = weights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值</span><br><span class=\"line\">        int[][] dp = new int[n + 1][capacity + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= capacity; j++) &#123;</span><br><span class=\"line\">                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值</span><br><span class=\"line\">                if (weights[i - 1] &gt; j) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值</span><br><span class=\"line\">        return dp[n][capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] weights = &#123;2, 3, 4, 5&#125;;</span><br><span class=\"line\">        int[] values = &#123;3, 4, 5, 6&#125;;</span><br><span class=\"line\">        int capacity = 5;</span><br><span class=\"line\">        int result = knapsack(weights, values, capacity);</span><br><span class=\"line\">        System.out.println(&quot;Maximum value: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出结果</span><br><span class=\"line\">Maximum value: 7</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最长公共子序列（Longest-Common-Subsequence）问题\"><a href=\"#最长公共子序列（Longest-Common-Subsequence）问题\" class=\"headerlink\" title=\"最长公共子序列（Longest Common Subsequence）问题\"></a>最长公共子序列（Longest Common Subsequence）问题</h2><p>最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。</p>\n<p>给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。</li>\n<li>遍历两个序列的元素，对于每个元素<code>A[i]</code>和<code>B[j]</code>：</li>\n</ol>\n<ul>\n<li>如果<code>A[i]</code>和<code>B[j]</code>相等，说明它们可以作为最长公共子序列的一部分，因此<code>dp[i][j]</code>的值应该是<code>dp[i-1][j-1] + 1</code>，即在之前的最长公共子序列长度上加1。</li>\n<li>如果<code>A[i]</code>和<code>B[j]</code>不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>中的较大值作为<code>dp[i][j]</code>的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后，<code>dp[n][m]</code>即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LongestCommonSubsequence &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class=\"line\">        int m = text1.length();</span><br><span class=\"line\">        int n = text2.length();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class=\"line\">        int[][] dp = new int[m + 1][n + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一</span><br><span class=\"line\">                if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回 text1 和 text2 的最长公共子序列长度</span><br><span class=\"line\">        return dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String text1 = &quot;abcde&quot;;</span><br><span class=\"line\">        String text2 = &quot;ace&quot;;</span><br><span class=\"line\">        int result = longestCommonSubsequence(text1, text2);</span><br><span class=\"line\">        System.out.println(&quot;Longest Common Subsequence: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Longest Common Subsequence: 3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\"><a href=\"#打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\" class=\"headerlink\" title=\"打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\"></a>打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。</h2><p><strong>题目：</strong></p>\n<p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n<p>示例 1：</p>\n<p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n<p>示例 2：</p>\n<p>输入：nums &#x3D; [2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>\n<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>\n</ul>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。</li>\n<li>初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。</li>\n<li>遍历数组，对于每个房屋i，考虑两种情况：</li>\n</ol>\n<ul>\n<li>偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。</li>\n<li>不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。</li>\n<li>取两种情况中的较大值作为dp[i]的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HouseRobberI &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param nums 一个代表每个房屋存放金额的非负整数数组</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int rob(int[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 0) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 1) &#123;</span><br><span class=\"line\">            return nums[0];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额</span><br><span class=\"line\">        int[] dp = new int[n];</span><br><span class=\"line\">        dp[0] = nums[0];</span><br><span class=\"line\">        dp[1] = Math.max(nums[0], nums[1]);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 2; i &lt; n; i++) &#123;</span><br><span class=\"line\">            // 在当前房屋偷窃或不偷窃之间选择最大值</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最后一个房屋偷窃或不偷窃的最大金额</span><br><span class=\"line\">        return dp[n - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;2, 7, 9, 3, 1&#125;;</span><br><span class=\"line\">        int result = rob(nums);</span><br><span class=\"line\">        System.out.println(&quot;Maximum amount: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maximum amount: 12</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"二、回溯算法\"><a href=\"#二、回溯算法\" class=\"headerlink\" title=\"二、回溯算法\"></a>二、回溯算法</h1><p>回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。</p>\n<p>回溯算法的基本步骤如下：</p>\n<ul>\n<li>确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。</li>\n<li>递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。</li>\n<li>剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。</li>\n</ul>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>一些常见的回溯算法问题包括：</p>\n<ul>\n<li>全排列（Permutations）</li>\n<li>组合求和（Combination Sum）</li>\n<li>子集（Subsets）</li>\n<li>N皇后问题（N-Queens）</li>\n<li>单词搜索（Word Search）</li>\n<li>正则表达式匹配（Regular Expression Matching）等。</li>\n</ul>\n<p>回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。</p>\n<p><strong>回溯算法框架：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Value&gt; result;</span><br><span class=\"line\">void backtrack(路径， 选择列表) &#123;</span><br><span class=\"line\">    if (满足结束条件) &#123;</span><br><span class=\"line\">        result.add(路径);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (选择 ： 选择列表) &#123;</span><br><span class=\"line\">        做选择;</span><br><span class=\"line\">        backtrack(路径， 选择列表);</span><br><span class=\"line\">        撤销选择;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><p>全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>首先，我们可以使用递归来实现回溯算法。</li>\n<li>使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。</li>\n<li>递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。</li>\n<li>在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。</li>\n<li>在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。</li>\n</ol>\n<p><strong>题目：</strong></p>\n<p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p>\n<p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]</p>\n<p>示例 3：<br>输入：nums &#x3D; [1]<br>输出：[[1]]</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 6<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有整数 互不相同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PermutationsBacktracking &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; permutations = permute(nums);</span><br><span class=\"line\">        for (List&lt;Integer&gt; permutation : permutations) &#123;</span><br><span class=\"line\">            System.out.println(permutation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化了一个空的结果列表</span><br><span class=\"line\">    public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // 全排列</span><br><span class=\"line\">        backtrack(nums, new ArrayList&lt;&gt;(), result);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 回溯函数，用于生成全排列</span><br><span class=\"line\">     * @param nums      数组 【1，2，3】</span><br><span class=\"line\">     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素</span><br><span class=\"line\">     * @param result    存储全排列结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void backtrack(int[] nums, List&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class=\"line\">        // 到达叶子节点，将路径装入结果列表</span><br><span class=\"line\">        if (track.size() == nums.length) &#123;</span><br><span class=\"line\">            result.add(new ArrayList&lt;&gt;(track));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 尝试每个未使用的元素</span><br><span class=\"line\">        for (int num : nums) &#123;</span><br><span class=\"line\">            if (track.contains(num)) &#123;</span><br><span class=\"line\">                // 如果当前数字已经在排列中，跳过</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            track.add(num);</span><br><span class=\"line\">            // 递归调用</span><br><span class=\"line\">            backtrack(nums, track, result);</span><br><span class=\"line\">            // 回溯，移除最后一个元素</span><br><span class=\"line\">            track.remove(track.size() - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3]</span><br><span class=\"line\">[1, 3, 2]</span><br><span class=\"line\">[2, 1, 3]</span><br><span class=\"line\">[2, 3, 1]</span><br><span class=\"line\">[3, 1, 2]</span><br><span class=\"line\">[3, 2, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、贪心算法\"><a href=\"#三、贪心算法\" class=\"headerlink\" title=\"三、贪心算法\"></a>三、贪心算法</h1><p><strong>核心思想：</strong><br>贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。</p>\n<p>贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。</p>\n<p><strong>贪心算法的一般步骤如下</strong>：</p>\n<ol>\n<li>定义问题的解空间，即所有可能的解组成的集合。</li>\n<li>制定选择策略，即在每一步都选择一个局部最优解。</li>\n<li>确定是否满足问题的约束条件，即该解是否可行。</li>\n<li>判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。</li>\n</ol>\n<p>需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。</p>\n<p><strong>常见算法题：</strong></p>\n<ol>\n<li>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</li>\n<li>区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。</li>\n<li>分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。</li>\n<li>买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。</li>\n<li>跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。</li>\n<li>柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。</li>\n<li>汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。</li>\n<li>分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。</li>\n<li>非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。</li>\n<li>跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。</li>\n</ol>\n<h2 id=\"零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"><a href=\"#零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\" class=\"headerlink\" title=\"零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"></a>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</h2><p>在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。</p>\n<p>贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。</p>\n<p><strong>解：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CoinChangeGreedy &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] coins = &#123;1, 2, 5&#125;; // 零钱的面额</span><br><span class=\"line\">        int amount = 11; // 要兑换的金额</span><br><span class=\"line\">        int numCoins = coinChange(coins, amount);</span><br><span class=\"line\">        System.out.println(&quot;最少需要的硬币数：&quot; + numCoins);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param coins    硬币面额</span><br><span class=\"line\">     * @param amount   要兑换的金额</span><br><span class=\"line\">     * @return 最少使用硬币数目</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int coinChange(int[] coins, int amount) &#123;</span><br><span class=\"line\">        // 面额按从小到大排序</span><br><span class=\"line\">        Arrays.sort(coins);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 记录硬币数量</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        // 从最大面额的硬币开始尝试</span><br><span class=\"line\">        int index = coins.length - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        while (amount &gt; 0 &amp;&amp; index &gt;= 0) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (coins[index] &lt;= amount) &#123;</span><br><span class=\"line\">                // 尝试使用当前面额的硬币数量</span><br><span class=\"line\">                int numCoins = amount / coins[index];</span><br><span class=\"line\">                count += numCoins;</span><br><span class=\"line\">                amount -= numCoins * coins[index];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 尝试下一个面额的硬币</span><br><span class=\"line\">            index--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换</span><br><span class=\"line\">        return amount == 0 ? count : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最少需要的硬币数：3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。&#x3D;&#x3D;注意&#x3D;&#x3D;，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。</p>\n<p>在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"一、动态规划\"><a href=\"#一、动态规划\" class=\"headerlink\" title=\"一、动态规划\"></a>一、动态规划</h1><p>动态规划（Dynamic Programming，简称DP）是一种常用于解决优化问题和计数问题的算法思想。它通过<strong>将一个复杂问题分解为若干个子问题，然后逐步解决这些子问题，最终得到原问题的解</strong>。&#x3D;&#x3D;动态规划的核心思想是“递推”和“存储”，即通过已经解决的子问题的解来推导出更大规模问题的解，并将这些子问题的解进行存储以避免重复计算，从而提高算法的效率&#x3D;&#x3D;。</p>\n<p>动态规划适用于满足以下两个条件的问题：</p>\n<ol>\n<li><p>重叠子问题（Overlapping Subproblems）：问题的解可以被分解为多个子问题，而且这些子问题之间存在重叠，即同一个子问题可能会被多次求解。</p>\n</li>\n<li><p>最优子结构（Optimal Substructure）：问题的最优解可以由其子问题的最优解推导而来。换句话说，问题的整体最优解可以通过子问题的最优解组合而成。</p>\n</li>\n</ol>\n<p>动态规划通常有两种常见的方法：</p>\n<ol>\n<li><p>自顶向下（Top-Down）：也称为记忆化递归，通过递归地解决问题，但在求解子问题时使用数组等数据结构来存储已经计算过的解，以避免重复计算。</p>\n</li>\n<li><p>自底向上（Bottom-Up）：通过解决问题的子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这种方法通常会使用一个数组或表格来存储子问题的解，以便后续问题可以直接从已经计算出的解中获取。</p>\n</li>\n</ol>\n<p>动态规划广泛应用于许多领域，例如：</p>\n<ul>\n<li>背包问题（Knapsack Problem）</li>\n<li>最短路径问题（Shortest Path Problem）</li>\n<li>最长公共子序列问题（Longest Common Subsequence Problem）</li>\n<li>斐波那契数列问题（Fibonacci Sequence Problem）</li>\n<li>编辑距离问题（Edit Distance Problem）</li>\n<li>最大子数组和问题（Maximum Subarray Sum Problem）</li>\n<li>…等等</li>\n</ul>\n<p>总之，动态规划是一种通过将问题分解为子问题，逐步构建解决方案并存储已计算的结果来优化问题求解过程的算法思想。</p>\n<p><strong>大致步骤：</strong></p>\n<ol>\n<li><p><strong>定义子问题：</strong> 将原始问题分解为若干个更小的子问题。这些子问题应该满足最优子结构，即问题的最优解可以由子问题的最优解推导而来。</p>\n</li>\n<li><p><strong>找出状态转移方程：</strong> 对每个子问题定义一个状态，然后找出子问题之间的关系，即状态之间的转移方程。这个方程描述了子问题的解与其相关子问题解之间的关系。</p>\n</li>\n<li><p><strong>初始化：</strong> 初始化一些基本的子问题，通常是最小规模的问题的解。这些初始化值将作为构建更大规模问题解的基础。</p>\n</li>\n<li><p><strong>自底向上求解（或者记忆化递归）：</strong> 通过迭代地求解子问题，从最小规模的问题开始，逐步构建解决大规模问题的方法。这可以通过自底向上的迭代方法实现，或者使用自顶向下的记忆化递归方法，其中使用数组等数据结构来存储已经计算过的解。</p>\n</li>\n<li><p><strong>存储中间结果：</strong> 在求解子问题的过程中，将已经计算过的子问题的解存储起来，以避免重复计算，提高算法效率。</p>\n</li>\n<li><p><strong>得到最终解：</strong> 当所有子问题都求解完毕后，最终问题的解就可以从中获得。这通常是整个问题的最优解。</p>\n</li>\n<li><p><strong>可选的优化：</strong> 根据具体情况，你还可以对算法进行进一步优化，例如利用滚动数组、状态压缩等技巧来减少空间复杂度。</p>\n</li>\n</ol>\n<h2 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列\"></a>最长递增子序列</h2><p><strong>题目：</strong><br>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。<br><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>\n<p>示例 1：<br>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4</p>\n<p>示例 3：<br>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>\n<p><strong>注意</strong>「⼦序列」和「⼦串」这两个名词的区别，⼦串⼀定是连续的，⽽⼦序列不⼀定是连续的</p>\n<p><strong>思想解释：</strong></p>\n<ol>\n<li>我们使用一个数组 <code>dp</code> 来保存以每个元素结尾的最长递增子序列的长度。初始时，每个元素自成一个长度为1的子序列。</li>\n<li>我们从数组的第二个元素开始遍历，对于每个元素 <code>nums[i]</code>，我们再遍历它之前的所有元素 <code>nums[j]</code>（<code>j &lt; i</code>）。如果 <code>nums[i]</code> 大于 <code>nums[j]</code>，说明可以将 <code>nums[i]</code> 加入以 <code>nums[j]</code> 结尾的子序列，从而构成一个更长的递增子序列。我们更新 <code>dp[i]</code> 为 <code>dp[j] + 1</code>，表示以 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在内层循环中，我们不断更新 <code>dp[i]</code>，找到以当前元素 <code>nums[i]</code> 结尾的最长递增子序列长度。</li>\n<li>在整个过程中，我们维护一个全局变量 <code>maxLen</code>，记录最长递增子序列的长度。</li>\n<li>最终，遍历完整个数组后，<code>maxLen</code> 就是最长递增子序列的长度。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestIncreasingSubsequence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length]; <span class=\"comment\">// dp[i] 表示以 nums[i] 结尾的最长递增子序列长度</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化，单个元素也构成递增子序列</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 最长递增子序列长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = <span class=\"number\">1</span>; <span class=\"comment\">// 默认以当前元素为结尾的子序列长度为 1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    dp[i] = Math.max(dp[i], dp[j] + <span class=\"number\">1</span>); <span class=\"comment\">// 更新最长递增子序列长度</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxLen = Math.max(maxLen, dp[i]); <span class=\"comment\">// 更新全局最长长度</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">10</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">101</span>, <span class=\"number\">18</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lisLength</span> <span class=\"operator\">=</span> lengthOfLIS(nums);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Length of Longest Increasing Subsequence: &quot;</span> + lisLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"正则表达式匹配\"><a href=\"#正则表达式匹配\" class=\"headerlink\" title=\"正则表达式匹配\"></a>正则表达式匹配</h2><p><strong>题目：</strong><br>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>\n<p>示例 1:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p>\n<p>示例 2:<br>输入:<br>s &#x3D; “aa”<br>p &#x3D; “a*”<br>输出: true<br>解释: 因为 ‘*’ 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 ‘a’。因此，字符串 “aa” 可被视为 ‘a’ 重复了一次。</p>\n<p>示例 3:<br>输入:<br>s &#x3D; “ab”<br>p &#x3D; “.<em>“<br>输出: true<br>解释: “.</em>“ 表示可匹配零个或多个（’*’）任意字符（’.’）。</p>\n<p>示例 4:<br>输入:<br>s &#x3D; “aab”<br>p &#x3D; “c<em>a</em>b”<br>输出: true<br>解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>\n<p>示例 5:<br>输入:<br>s &#x3D; “mississippi”<br>p &#x3D; “mis<em>is</em>p*.”<br>输出: false<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 <em>，无连续的 ‘</em>‘。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决正则表达式匹配问题。</li>\n<li>定义一个二维布尔数组dp，其中dp[i][j]表示字符串的前i个字符与正则表达式的前j个字符是否匹配。</li>\n<li>初始化dp[0][0]为true，表示空字符串和空正则表达式是匹配的。</li>\n<li>遍历字符串和正则表达式的每个字符，逐步填充dp数组。</li>\n<li>如果s[i]和p[j]相等，或者p[j]为’.’，则dp[i][j]的值取决于dp[i-1][j-1]，表示当前字符匹配成功。</li>\n<li>如果p[j]为’*’，则需要考虑两种情况：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复0次，则dp[i][j]的值取决于dp[i][j-2]。</span><br><span class=\"line\">-  &#x27;*&#x27;表示前面的字符重复1次或多次，则dp[i][j]的值取决于dp[i-1][j]且s[i]和p[j-1]相等，或者p[j-1]为&#x27;.&#x27;。</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>其他情况下，dp[i][j]的值为false，表示当前字符匹配失败。</li>\n<li>最终返回dp[len(s)][len(p)]的值，表示整个字符串与正则表达式是否匹配。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RegularExpressionMatching</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isMatch</span><span class=\"params\">(String s, String p)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> p.length();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j]表示s的前i个字符和p的前j个字符是否匹配</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 空字符串和空正则表达式匹配</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 处理空正则表达式可以匹配的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p.charAt(j - <span class=\"number\">1</span>) == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 填充dp表格</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> s.charAt(i - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"type\">char</span> <span class=\"variable\">pc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">1</span>);</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sc == pc || pc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pc == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">char</span> <span class=\"variable\">prevPc</span> <span class=\"operator\">=</span> p.charAt(j - <span class=\"number\">2</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (prevPc == sc || prevPc == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次、1次或多次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>] || dp[i - <span class=\"number\">1</span>][j] || dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 匹配0次</span></span><br><span class=\"line\">                        dp[i][j] = dp[i][j - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mississippi&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">p</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;mis*is*p*.&quot;</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> isMatch(s, p);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Is match: &quot;</span> + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的前i个字符和p的前j个字符是否匹配。</li>\n<li>初始化：空字符串和空正则表达式匹配，<code>dp[0][0] = true</code>。</li>\n<li>处理空正则表达式可以匹配的情况：如果p的某个字符是’*’，那么它可以匹配0次，将<code>dp[0][j]</code>设置为<code>dp[0][j-2]</code>。</li>\n<li>填充dp表格：根据字符匹配和’*’的特性，更新<code>dp[i][j]</code>的值。</li>\n<li>最终结：<code>dp[m][n]</code>表示s的全部字符和p的全部字符是否匹配。</li>\n</ol>\n<h2 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h2><p>回文串是指正着读和倒着读都一样的字符串。例如，”aba”、”abba”和”level”都是回文串。</p>\n<p><strong>题目：</strong><br>给你一个字符串 s，找到 s 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>\n<p>示例 1：<br>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p>\n<p>示例 2：<br>输入：s &#x3D; “cbbd”<br>输出：”bb”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母组成</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决最长回文子串问题。定义一个二维数组dp，其中dp[i][j]表示从索引i到j的子串是否为回文串。</li>\n<li>初始化dp数组，将所有长度为1的子串都设为回文串，即dp[i][i] &#x3D; true。</li>\n<li>遍历字符串中所有可能的子串，从长度为2的子串开始，到长度为n的子串结束（n为字符串长度）。</li>\n<li>对于每个子串，判断头尾两个字符是否相等，并根据之前计算的dp数组来判断子串是否为回文串，即dp[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) &amp;&amp; dp[i+1][j-1]。</li>\n<li>如果当前子串是回文串并且长度比之前的最长回文串更长，更新最长回文串的起始位置和长度。</li>\n<li>最终得到的最长回文子串就是最长的回文串。</li>\n</ol>\n<p><strong>解法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LongestPalindromeSubstring</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录最长回文子串的起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLength</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; <span class=\"comment\">// 记录最长回文子串的长度</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                start = i;</span><br><span class=\"line\">                maxLength = <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    start = i;</span><br><span class=\"line\">                    maxLength = len;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(start, start + maxLength);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;babad&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">longestPalindrome</span> <span class=\"operator\">=</span> longestPalindrome(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Longest Palindrome Substring: &quot;</span> + longestPalindrome);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串。</li>\n<li>最终结果：根据<code>dp</code>数组的信息，找到最长回文子串的起始位置和长度，然后通过<code>substring</code>方法获取最长回文子串。<br>注意：虽然动态规划是一种解决最长回文子串问题的方法，但还有其他更优秀的算法，如Manacher算法等，可以在时间复杂度上做更多优化。</li>\n</ol>\n<h2 id=\"回文子串个数\"><a href=\"#回文子串个数\" class=\"headerlink\" title=\"回文子串个数\"></a>回文子串个数</h2><p><strong>题目：</strong><br>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n<p>示例 1：<br>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p>\n<p>示例 2：<br>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p>\n<p>提示：<br>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 由小写英文字母组成</p>\n<p><strong>解法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CountPalindromicSubstrings</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">countSubstrings</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; <span class=\"comment\">// 记录回文子串的个数</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n]; <span class=\"comment\">// dp[i][j]表示s的子串从i到j是否为回文子串</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 所有单个字符都是回文子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度为2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                dp[i][i + <span class=\"number\">1</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 检查长度大于2的子串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; len &lt;= n; len++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= n - len; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + len - <span class=\"number\">1</span>; <span class=\"comment\">// 子串的结束位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">input</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">palindromeCount</span> <span class=\"operator\">=</span> countSubstrings(input);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Palindrome Substrings Count: &quot;</span> + palindromeCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释解释：</p>\n<ol>\n<li><code>dp[i][j]</code>表示s的子串从索引i到j是否是回文子串。</li>\n<li>初始化：所有单个字符都是回文子串，即<code>dp[i][i] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度为2的子串：如果相邻两个字符相等，那么它们是回文子串，即<code>dp[i][i+1] = true</code>，并且<code>count</code>加1。</li>\n<li>检查长度大于2的子串：通过动态规划，依次计算长度为3到n的所有子串是否为回文子串，如果是，则<code>dp[i][j]</code>为true，同时<code>count</code>加1。</li>\n<li>最终结果：返回<code>count</code>，即回文子串的个数。</li>\n</ol>\n<h2 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h2><p>背包问题是动态规划中的经典问题之一。给定一组物品，每个物品有对应的重量和价值，背包有限的承载重量，要求在不超过背包承载重量的前提下，选择物品放入背包，使得背包中物品的总价值最大。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决0-1背包问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示在前i个物品中选择总重量不超过j的情况下的最大价值。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示没有物品或背包承载重量为0时的最大价值为0。</li>\n<li>遍历物品和背包承载重量，对于每个物品和背包承载重量：</li>\n</ol>\n<ul>\n<li>如果物品i的重量大于当前背包承载重量j，说明物品i不能放入背包，所以<code>dp[i][j]</code>的最大价值和<code>dp[i-1][j]</code>一样。</li>\n<li>如果物品i的重量小于等于当前背包承载重量j，我们可以考虑是否将物品i放入背包。如果放入物品i，则背包中剩余的重量为<code>j - weights[i]</code>，所以最大价值为<code>values[i] + dp[i-1][j-weights[i]]</code>；如果不放入物品i，则最大价值为<code>dp[i-1][j]</code>。我们选择两者中较大的值作为<code>dp[i][j]</code>的最大价值。其中 <code>weight[i]</code> 为物品 i 的重量，<code>value[i]</code> 为物品 i 的价值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后<code>dp[n][W]</code>即为问题的解，其中n表示物品的个数，W表示背包的承载重量。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class KnapsackProblem &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param weights    物品的重量数组</span><br><span class=\"line\">     * @param values     价值数组</span><br><span class=\"line\">     * @param capacity   背包容量</span><br><span class=\"line\">     * @return 最大价值</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int knapsack(int[] weights, int[] values, int capacity) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = weights.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组来保存状态转移结果，dp[i][j] 表示在前 i 个物品中，背包容量为 j 时的最大价值</span><br><span class=\"line\">        int[][] dp = new int[n + 1][capacity + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= capacity; j++) &#123;</span><br><span class=\"line\">                // 如果当前物品的重量大于当前背包容量，无法放入，直接继承上一行的最大价值</span><br><span class=\"line\">                if (weights[i - 1] &gt; j) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j];</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，可以选择放入当前物品或不放入，取两者中的最大值</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最终结果，即在考虑所有物品后，背包容量为 capacity 时的最大价值</span><br><span class=\"line\">        return dp[n][capacity];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] weights = &#123;2, 3, 4, 5&#125;;</span><br><span class=\"line\">        int[] values = &#123;3, 4, 5, 6&#125;;</span><br><span class=\"line\">        int capacity = 5;</span><br><span class=\"line\">        int result = knapsack(weights, values, capacity);</span><br><span class=\"line\">        System.out.println(&quot;Maximum value: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 输出结果</span><br><span class=\"line\">Maximum value: 7</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最长公共子序列（Longest-Common-Subsequence）问题\"><a href=\"#最长公共子序列（Longest-Common-Subsequence）问题\" class=\"headerlink\" title=\"最长公共子序列（Longest Common Subsequence）问题\"></a>最长公共子序列（Longest Common Subsequence）问题</h2><p>最长公共子序列（Longest Common Subsequence，简称LCS）问题是一种经典的动态规划问题，用于找到两个序列中最长的公共子序列的长度。</p>\n<p>给定两个序列A和B，我们要找到它们的最长公共子序列。子序列是指从序列中删除零个或多个元素而不改变其相对顺序后得到的新序列。</p>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决LCS问题。首先，定义一个二维数组<code>dp</code>，其中<code>dp[i][j]</code>表示序列A的前i个元素和序列B的前j个元素的最长公共子序列的长度。</li>\n<li>初始化<code>dp</code>数组，将第0行和第0列的值都设为0，表示当一个序列为空时，与任何序列的最长公共子序列长度都为0。</li>\n<li>遍历两个序列的元素，对于每个元素<code>A[i]</code>和<code>B[j]</code>：</li>\n</ol>\n<ul>\n<li>如果<code>A[i]</code>和<code>B[j]</code>相等，说明它们可以作为最长公共子序列的一部分，因此<code>dp[i][j]</code>的值应该是<code>dp[i-1][j-1] + 1</code>，即在之前的最长公共子序列长度上加1。</li>\n<li>如果<code>A[i]</code>和<code>B[j]</code>不相等，说明它们不能同时出现在最长公共子序列中，此时我们需要考虑舍弃其中一个元素，即取<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>中的较大值作为<code>dp[i][j]</code>的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最后，<code>dp[n][m]</code>即为序列A和B的最长公共子序列的长度，其中n和m分别是序列A和B的长度。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class LongestCommonSubsequence &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class=\"line\">        int m = text1.length();</span><br><span class=\"line\">        int n = text2.length();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个二维数组 dp，dp[i][j] 表示 text1 前 i 个字符和 text2 前 j 个字符的最长公共子序列长度</span><br><span class=\"line\">        int[][] dp = new int[m + 1][n + 1];</span><br><span class=\"line\"></span><br><span class=\"line\">        // 填充 dp 数组，进行状态转移</span><br><span class=\"line\">        for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class=\"line\">            for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class=\"line\">                // 如果当前字符相同，说明可以将这个字符纳入公共子序列中，长度加一</span><br><span class=\"line\">                if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    // 否则，选择不使用当前字符，取前面最长的公共子序列长度</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回 text1 和 text2 的最长公共子序列长度</span><br><span class=\"line\">        return dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        String text1 = &quot;abcde&quot;;</span><br><span class=\"line\">        String text2 = &quot;ace&quot;;</span><br><span class=\"line\">        int result = longestCommonSubsequence(text1, text2);</span><br><span class=\"line\">        System.out.println(&quot;Longest Common Subsequence: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Longest Common Subsequence: 3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\"><a href=\"#打家劫舍（House-Robber）问题：如不相邻的房屋偷窃的最大金额。\" class=\"headerlink\" title=\"打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。\"></a>打家劫舍（House Robber）问题：如不相邻的房屋偷窃的最大金额。</h2><p><strong>题目：</strong></p>\n<p>一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n<p>示例 1：</p>\n<p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p>\n<p>示例 2：</p>\n<p>输入：nums &#x3D; [2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p>\n<p>提示：</p>\n<ul>\n<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>\n<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>\n</ul>\n<p><strong>解题思路：</strong></p>\n<ol>\n<li>我们可以使用动态规划来解决这个问题。定义一个一维数组dp，其中dp[i]表示偷窃前i个房屋能够得到的最大金额。</li>\n<li>初始化dp数组，dp[0]为第一个房屋的金额，dp[1]为第二个房屋和第一个房屋金额的较大值。</li>\n<li>遍历数组，对于每个房屋i，考虑两种情况：</li>\n</ol>\n<ul>\n<li>偷窃第i个房屋：则最大金额为dp[i-2]+nums[i]，即偷窃第i-2个房屋的最大金额加上第i个房屋的金额。</li>\n<li>不偷窃第i个房屋：则最大金额为dp[i-1]，即偷窃前i-1个房屋的最大金额。</li>\n<li>取两种情况中的较大值作为dp[i]的值。</li>\n</ul>\n<ol start=\"4\">\n<li>最终，dp[n-1]即为偷窃到的最大金额，其中n为房屋的个数。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class HouseRobberI &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * @param nums 一个代表每个房屋存放金额的非负整数数组</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int rob(int[] nums) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 0) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (n == 1) &#123;</span><br><span class=\"line\">            return nums[0];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // dp[i] 表示偷窃前 i 个房屋能够获得的最大金额</span><br><span class=\"line\">        int[] dp = new int[n];</span><br><span class=\"line\">        dp[0] = nums[0];</span><br><span class=\"line\">        dp[1] = Math.max(nums[0], nums[1]);</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 2; i &lt; n; i++) &#123;</span><br><span class=\"line\">            // 在当前房屋偷窃或不偷窃之间选择最大值</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 返回最后一个房屋偷窃或不偷窃的最大金额</span><br><span class=\"line\">        return dp[n - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;2, 7, 9, 3, 1&#125;;</span><br><span class=\"line\">        int result = rob(nums);</span><br><span class=\"line\">        System.out.println(&quot;Maximum amount: &quot; + result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maximum amount: 12</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"二、回溯算法\"><a href=\"#二、回溯算法\" class=\"headerlink\" title=\"二、回溯算法\"></a>二、回溯算法</h1><p>回溯算法是一种穷举搜索的算法，其核心思想是通过递归的方式尝试所有可能的情况，直到找到问题的解或确定问题无解。在搜索过程中，当发现当前选择无法达到目标或导致问题无解时，会回退到上一步选择另一种可能，继续尝试。</p>\n<p>回溯算法的基本步骤如下：</p>\n<ul>\n<li>确定问题的解空间：即问题所有可能的解组成的空间。这个空间可能是一个树状结构，每个节点表示一个可能的选择。</li>\n<li>递归地搜索解空间：从根节点开始，对每个节点进行深度优先搜索，考虑当前节点的选择并继续向下搜索。如果搜索到达叶子节点且得到一个有效解，或者搜索无法继续进行，则回退到上一层节点，选择另一种可能继续搜索。</li>\n<li>剪枝优化：在搜索过程中，通过某些条件判断可以提前结束不可能得到解的搜索，从而减少不必要的计算。</li>\n</ul>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>回溯算法可以用来解决组合问题、排列问题、子集问题、棋盘问题等。当问题的解空间较大且搜索的过程中需要考虑选择与限制条件时，回溯算法通常是一种有效的解题思路。</p>\n<p>一些常见的回溯算法问题包括：</p>\n<ul>\n<li>全排列（Permutations）</li>\n<li>组合求和（Combination Sum）</li>\n<li>子集（Subsets）</li>\n<li>N皇后问题（N-Queens）</li>\n<li>单词搜索（Word Search）</li>\n<li>正则表达式匹配（Regular Expression Matching）等。</li>\n</ul>\n<p>回溯算法的灵活性和穷举性使得它适用于解决许多复杂的组合问题和排列问题。然而，由于其穷举搜索的性质，对于一些大规模问题，回溯算法的计算复杂度可能会非常高。因此，在实际应用中，对于问题规模较大的情况，可能需要结合其他优化方法来提高算法效率。</p>\n<p><strong>回溯算法框架：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Value&gt; result;</span><br><span class=\"line\">void backtrack(路径， 选择列表) &#123;</span><br><span class=\"line\">    if (满足结束条件) &#123;</span><br><span class=\"line\">        result.add(路径);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (选择 ： 选择列表) &#123;</span><br><span class=\"line\">        做选择;</span><br><span class=\"line\">        backtrack(路径， 选择列表);</span><br><span class=\"line\">        撤销选择;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><p>全排列（Permutations）问题是一个经典的回溯算法问题。给定一个不含重复元素的整数数组，要求返回所有可能的排列方式。</p>\n<p><strong>解题思路如下：</strong></p>\n<ol>\n<li>首先，我们可以使用递归来实现回溯算法。</li>\n<li>使用一个辅助函数来递归地生成排列。函数参数包括当前排列的状态、已使用的数字集合、原始整数数组，以及存储所有排列结果的变量。</li>\n<li>递归的终止条件是当前排列的长度等于原始整数数组的长度，表示当前排列已经完成，将其添加到结果中。</li>\n<li>在递归过程中，遍历未使用的数字，每次选择一个数字加入当前排列中，并将其标记为已使用，然后继续递归生成下一个位置的排列。</li>\n<li>在回溯的过程中，将已使用的数字状态恢复，以便尝试其他的选择。</li>\n</ol>\n<p><strong>题目：</strong></p>\n<p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p>\n<p>示例 1：<br>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>\n<p>示例 2：<br>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]</p>\n<p>示例 3：<br>输入：nums &#x3D; [1]<br>输出：[[1]]</p>\n<p>提示：<br>1 &lt;&#x3D; nums.length &lt;&#x3D; 6<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有整数 互不相同</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.util.ArrayList;</span><br><span class=\"line\">import java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PermutationsBacktracking &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] nums = &#123;1, 2, 3&#125;;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; permutations = permute(nums);</span><br><span class=\"line\">        for (List&lt;Integer&gt; permutation : permutations) &#123;</span><br><span class=\"line\">            System.out.println(permutation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化了一个空的结果列表</span><br><span class=\"line\">    public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        // 全排列</span><br><span class=\"line\">        backtrack(nums, new ArrayList&lt;&gt;(), result);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 回溯函数，用于生成全排列</span><br><span class=\"line\">     * @param nums      数组 【1，2，3】</span><br><span class=\"line\">     * @param track     记录路径  进入一个新节点，要加入这个节点的元素；退后一个节点时，要删除这个节点元素</span><br><span class=\"line\">     * @param result    存储全排列结果</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static void backtrack(int[] nums, List&lt;Integer&gt; track, List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class=\"line\">        // 到达叶子节点，将路径装入结果列表</span><br><span class=\"line\">        if (track.size() == nums.length) &#123;</span><br><span class=\"line\">            result.add(new ArrayList&lt;&gt;(track));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 尝试每个未使用的元素</span><br><span class=\"line\">        for (int num : nums) &#123;</span><br><span class=\"line\">            if (track.contains(num)) &#123;</span><br><span class=\"line\">                // 如果当前数字已经在排列中，跳过</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            track.add(num);</span><br><span class=\"line\">            // 递归调用</span><br><span class=\"line\">            backtrack(nums, track, result);</span><br><span class=\"line\">            // 回溯，移除最后一个元素</span><br><span class=\"line\">            track.remove(track.size() - 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[1, 2, 3]</span><br><span class=\"line\">[1, 3, 2]</span><br><span class=\"line\">[2, 1, 3]</span><br><span class=\"line\">[2, 3, 1]</span><br><span class=\"line\">[3, 1, 2]</span><br><span class=\"line\">[3, 2, 1]</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三、贪心算法\"><a href=\"#三、贪心算法\" class=\"headerlink\" title=\"三、贪心算法\"></a>三、贪心算法</h1><p><strong>核心思想：</strong><br>贪心算法（Greedy Algorithm）的核心思想是在每一步选择中都采取当前最优的选择，以期望达到全局最优解。换句话说，贪心算法每次都做出局部最优的选择，希望通过局部最优解的组合，达到整体最优解。</p>\n<p>贪心算法的特点是不回溯，不考虑选择对未来的影响，而只关注当前的局部最优解。贪心算法在解决一些最优化问题时，可以快速找到一个近似最优解，但并不保证一定能找到全局最优解。因此，贪心算法通常用于那些具有贪心选择性质和最优子结构性质的问题。</p>\n<p><strong>贪心算法的一般步骤如下</strong>：</p>\n<ol>\n<li>定义问题的解空间，即所有可能的解组成的集合。</li>\n<li>制定选择策略，即在每一步都选择一个局部最优解。</li>\n<li>确定是否满足问题的约束条件，即该解是否可行。</li>\n<li>判断是否达到问题的目标，即该解是否是最优解。如果达到目标，则算法结束；否则，返回步骤2，继续进行选择。</li>\n</ol>\n<p>需要注意的是，由于贪心算法每次只考虑当前的局部最优解，因此并不适用于所有问题。在某些情况下，贪心算法可能会得到次优解或错误的结果。因此，在应用贪心算法时，需要仔细分析问题的特点，确保问题具有贪心选择性质和最优子结构性质，以保证算法能够得到正确的结果。</p>\n<p><strong>常见算法题：</strong></p>\n<ol>\n<li>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</li>\n<li>区间调度（Interval Scheduling）：给定一组区间，选择尽可能多的不重叠区间。</li>\n<li>分糖果（Candy）：给定一组孩子和一些糖果，分配糖果使得每个孩子至少分得一颗，相邻孩子间的糖果数应尽可能不同。</li>\n<li>买卖股票的最佳时机（Best Time to Buy and Sell Stock）：给定一组股票的价格，只能买卖一次，求最大的利润。</li>\n<li>跳跃游戏（Jump Game）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，判断能否到达数组的最后一个位置。</li>\n<li>柠檬水找零（Lemonade Change）：给定一组客户支付的钞票面额，判断是否能找零（客户支付5、10、20元，柠檬水5元一杯）。</li>\n<li>汽车加油站（Gas Station）：给定一个环形路线上的加油站和对应的汽油量，选择一个起始加油站，判断是否能绕一圈回到起点，并找出可能的起始加油站。</li>\n<li>分发饼干（Assign Cookies）：给定一组孩子和一组饼干，每个孩子有一个满足度，每个饼干有一个大小，求能满足孩子的最大数量。</li>\n<li>非重叠区间（Non-overlapping Intervals）：给定一组区间，移除最少的区间，使得剩余的区间互不重叠。</li>\n<li>跳跃游戏 II（Jump Game II）：给定一个非负整数数组，每个元素代表在该位置可以跳跃的最大步数，求最少需要几步能够到达数组的最后一个位置。</li>\n</ol>\n<h2 id=\"零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"><a href=\"#零钱兑换（Coin-Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\" class=\"headerlink\" title=\"零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。\"></a>零钱兑换（Coin Change）：给定不同面额的硬币和一个总金额，求出使用最少的硬币数量凑成总金额。</h2><p>在零钱兑换问题中，贪心算法并不是最优的解决方案，因为不是所有情况下都可以通过贪心选择得到最少硬币数量。但是，为了展示贪心算法的思想，我们可以尝试使用贪心算法解决一部分情况。</p>\n<p>贪心算法的思想是每次都选择当前最优的硬币面额，然后尽可能多地使用该面额的硬币，直到凑满总金额。在这道题中，我们可以使用贪心算法来得到一个近似最优解，但并不能保证一定能得到全局最优解。</p>\n<p><strong>解：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class CoinChangeGreedy &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        int[] coins = &#123;1, 2, 5&#125;; // 零钱的面额</span><br><span class=\"line\">        int amount = 11; // 要兑换的金额</span><br><span class=\"line\">        int numCoins = coinChange(coins, amount);</span><br><span class=\"line\">        System.out.println(&quot;最少需要的硬币数：&quot; + numCoins);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param coins    硬币面额</span><br><span class=\"line\">     * @param amount   要兑换的金额</span><br><span class=\"line\">     * @return 最少使用硬币数目</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public static int coinChange(int[] coins, int amount) &#123;</span><br><span class=\"line\">        // 面额按从小到大排序</span><br><span class=\"line\">        Arrays.sort(coins);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 记录硬币数量</span><br><span class=\"line\">        int count = 0;</span><br><span class=\"line\">        // 从最大面额的硬币开始尝试</span><br><span class=\"line\">        int index = coins.length - 1;</span><br><span class=\"line\"></span><br><span class=\"line\">        while (amount &gt; 0 &amp;&amp; index &gt;= 0) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (coins[index] &lt;= amount) &#123;</span><br><span class=\"line\">                // 尝试使用当前面额的硬币数量</span><br><span class=\"line\">                int numCoins = amount / coins[index];</span><br><span class=\"line\">                count += numCoins;</span><br><span class=\"line\">                amount -= numCoins * coins[index];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 尝试下一个面额的硬币</span><br><span class=\"line\">            index--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 如果剩余金额为0，返回硬币数量，否则返回-1表示无法兑换</span><br><span class=\"line\">        return amount == 0 ? count : -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">最少需要的硬币数：3</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n\n<p>在这个示例中，我们通过贪心算法按照面额从大到小的顺序，尽量使用大面额的硬币来兑换金额。&#x3D;&#x3D;注意&#x3D;&#x3D;，贪心算法并不一定能得到最优解，有时候可能会得到错误的结果。例如，如果硬币面额为{1, 3, 4}，要兑换6元，贪心算法会选择使用3个硬币（4 + 1 + 1），但实际上最优解应该是2个硬币（3 + 3）。</p>\n<p>在实际应用中，零钱兑换问题更适合使用动态规划等算法来求解，以确保得到最优解。</p>\n"},{"title":"将本地代码提交至github仓库","date":"2018-01-01T04:50:18.000Z","top_img":"/img/githubImage.jpg","cover":"/img/githubImage.jpg","keywords":"github仓库","description":"将本地代码提交至github仓库","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"_content":"## 创建github账号：\n在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。\n\n## 创建代码仓库：\n在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。\n\n## 安装git\n在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。\n\n## 创建和配置密钥\n要在 Git 中创建密钥，请按照以下步骤进行操作：\n\n### 1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\n\n\n```\nssh-keygen -t rsa -b 4096 -C \"your_email\"\n```\n\n\n### 2.按回车键接受默认的文件名和位置。\n\n### 3.输入你的密码短语（如果需要）。\n\n### 4.确认密码短语。\n\n### 5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n### 6.复制你的公钥。\n\n### 7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\n\n### 8.点击 \"Add SSH key\"（或类似的按钮）。\n\n### 9.将你的公钥粘贴到 \"Key\" 字段中。\n\n### 10.输入一个描述性的标题以标识此密钥。\n\n### 11.点击 \"Add key\"（或类似的按钮）。\n\n现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。\n\n## 创建本地代码仓库：\n在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：\n\n\n```\ngit init\n```\n\n这将在该文件夹中创建一个新的Git仓库。\n\n## *添加文件到本地代码仓库（更新）：\n将新文件添加到本地代码仓库中。在终端中，执行以下命令：\n\n\n```\ngit add .\n```\n\n这将把hello-world.py文件添加到Git的暂存区。\n\n## *提交（更新）：\n提交更改描述。在终端中，执行以下命令：\n\n\n```\ngit commit -m \"Initial commit\"\n```\n\n这将提交文件更改，并把提交描述设置为“Initial commit”。\n\n## 建立本地仓库和github仓库的关联：\n在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：\n\n\n```\ngit remote add origin [仓库的URL地址]\n```\n\n这将将您的本地仓库与Github仓库关联起来。\n\n## *推送代码到github仓库（更新）：\n推送您的代码到Github仓库。执行以下命令：\n\n\n```\ngit push -u origin master\n```\n\n这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。\n\n完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。","source":"_posts/将本地代码提交至github仓库.md","raw":"---\ntitle: 将本地代码提交至github仓库\ndate: 2018-01-01 12:50:18\ntags:\n- github仓库\n- github\n- git\n- 本地代码\ncategories:\n- github仓库\n- github\ntop_img: /img/githubImage.jpg\ncover: /img/githubImage.jpg\nkeywords: \"github仓库\"\ndescription: \"将本地代码提交至github仓库\"\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both \n    date_format: relative\n    categories: true \n    tags: true\n    label: true\n---\n## 创建github账号：\n在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。\n\n## 创建代码仓库：\n在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。\n\n## 安装git\n在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。\n\n## 创建和配置密钥\n要在 Git 中创建密钥，请按照以下步骤进行操作：\n\n### 1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\n\n\n```\nssh-keygen -t rsa -b 4096 -C \"your_email\"\n```\n\n\n### 2.按回车键接受默认的文件名和位置。\n\n### 3.输入你的密码短语（如果需要）。\n\n### 4.确认密码短语。\n\n### 5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\n\n```\ncat ~/.ssh/id_rsa.pub\n```\n\n### 6.复制你的公钥。\n\n### 7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\n\n### 8.点击 \"Add SSH key\"（或类似的按钮）。\n\n### 9.将你的公钥粘贴到 \"Key\" 字段中。\n\n### 10.输入一个描述性的标题以标识此密钥。\n\n### 11.点击 \"Add key\"（或类似的按钮）。\n\n现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。\n\n## 创建本地代码仓库：\n在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：\n\n\n```\ngit init\n```\n\n这将在该文件夹中创建一个新的Git仓库。\n\n## *添加文件到本地代码仓库（更新）：\n将新文件添加到本地代码仓库中。在终端中，执行以下命令：\n\n\n```\ngit add .\n```\n\n这将把hello-world.py文件添加到Git的暂存区。\n\n## *提交（更新）：\n提交更改描述。在终端中，执行以下命令：\n\n\n```\ngit commit -m \"Initial commit\"\n```\n\n这将提交文件更改，并把提交描述设置为“Initial commit”。\n\n## 建立本地仓库和github仓库的关联：\n在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：\n\n\n```\ngit remote add origin [仓库的URL地址]\n```\n\n这将将您的本地仓库与Github仓库关联起来。\n\n## *推送代码到github仓库（更新）：\n推送您的代码到Github仓库。执行以下命令：\n\n\n```\ngit push -u origin master\n```\n\n这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。\n\n完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。","slug":"将本地代码提交至github仓库","published":1,"updated":"2023-09-01T16:33:23.724Z","_id":"clm0tbkoc0000ssth1y0b7c7i","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"创建github账号：\"><a href=\"#创建github账号：\" class=\"headerlink\" title=\"创建github账号：\"></a>创建github账号：</h2><p>在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。</p>\n<h2 id=\"创建代码仓库：\"><a href=\"#创建代码仓库：\" class=\"headerlink\" title=\"创建代码仓库：\"></a>创建代码仓库：</h2><p>在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。</p>\n<h2 id=\"创建和配置密钥\"><a href=\"#创建和配置密钥\" class=\"headerlink\" title=\"创建和配置密钥\"></a>创建和配置密钥</h2><p>要在 Git 中创建密钥，请按照以下步骤进行操作：</p>\n<h3 id=\"1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\"><a href=\"#1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\" class=\"headerlink\" title=\"1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\"></a>1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-按回车键接受默认的文件名和位置。\"><a href=\"#2-按回车键接受默认的文件名和位置。\" class=\"headerlink\" title=\"2.按回车键接受默认的文件名和位置。\"></a>2.按回车键接受默认的文件名和位置。</h3><h3 id=\"3-输入你的密码短语（如果需要）。\"><a href=\"#3-输入你的密码短语（如果需要）。\" class=\"headerlink\" title=\"3.输入你的密码短语（如果需要）。\"></a>3.输入你的密码短语（如果需要）。</h3><h3 id=\"4-确认密码短语。\"><a href=\"#4-确认密码短语。\" class=\"headerlink\" title=\"4.确认密码短语。\"></a>4.确认密码短语。</h3><h3 id=\"5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"><a href=\"#5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\" class=\"headerlink\" title=\"5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"></a>5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-复制你的公钥。\"><a href=\"#6-复制你的公钥。\" class=\"headerlink\" title=\"6.复制你的公钥。\"></a>6.复制你的公钥。</h3><h3 id=\"7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\"><a href=\"#7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\" class=\"headerlink\" title=\"7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\"></a>7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。</h3><h3 id=\"8-点击-“Add-SSH-key”（或类似的按钮）。\"><a href=\"#8-点击-“Add-SSH-key”（或类似的按钮）。\" class=\"headerlink\" title=\"8.点击 “Add SSH key”（或类似的按钮）。\"></a>8.点击 “Add SSH key”（或类似的按钮）。</h3><h3 id=\"9-将你的公钥粘贴到-“Key”-字段中。\"><a href=\"#9-将你的公钥粘贴到-“Key”-字段中。\" class=\"headerlink\" title=\"9.将你的公钥粘贴到 “Key” 字段中。\"></a>9.将你的公钥粘贴到 “Key” 字段中。</h3><h3 id=\"10-输入一个描述性的标题以标识此密钥。\"><a href=\"#10-输入一个描述性的标题以标识此密钥。\" class=\"headerlink\" title=\"10.输入一个描述性的标题以标识此密钥。\"></a>10.输入一个描述性的标题以标识此密钥。</h3><h3 id=\"11-点击-“Add-key”（或类似的按钮）。\"><a href=\"#11-点击-“Add-key”（或类似的按钮）。\" class=\"headerlink\" title=\"11.点击 “Add key”（或类似的按钮）。\"></a>11.点击 “Add key”（或类似的按钮）。</h3><p>现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。</p>\n<h2 id=\"创建本地代码仓库：\"><a href=\"#创建本地代码仓库：\" class=\"headerlink\" title=\"创建本地代码仓库：\"></a>创建本地代码仓库：</h2><p>在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>这将在该文件夹中创建一个新的Git仓库。</p>\n<h2 id=\"添加文件到本地代码仓库（更新）：\"><a href=\"#添加文件到本地代码仓库（更新）：\" class=\"headerlink\" title=\"*添加文件到本地代码仓库（更新）：\"></a>*添加文件到本地代码仓库（更新）：</h2><p>将新文件添加到本地代码仓库中。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>这将把hello-world.py文件添加到Git的暂存区。</p>\n<h2 id=\"提交（更新）：\"><a href=\"#提交（更新）：\" class=\"headerlink\" title=\"*提交（更新）：\"></a>*提交（更新）：</h2><p>提交更改描述。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这将提交文件更改，并把提交描述设置为“Initial commit”。</p>\n<h2 id=\"建立本地仓库和github仓库的关联：\"><a href=\"#建立本地仓库和github仓库的关联：\" class=\"headerlink\" title=\"建立本地仓库和github仓库的关联：\"></a>建立本地仓库和github仓库的关联：</h2><p>在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin [仓库的URL地址]</span><br></pre></td></tr></table></figure>\n\n<p>这将将您的本地仓库与Github仓库关联起来。</p>\n<h2 id=\"推送代码到github仓库（更新）：\"><a href=\"#推送代码到github仓库（更新）：\" class=\"headerlink\" title=\"*推送代码到github仓库（更新）：\"></a>*推送代码到github仓库（更新）：</h2><p>推送您的代码到Github仓库。执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。</p>\n<p>完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h2 id=\"创建github账号：\"><a href=\"#创建github账号：\" class=\"headerlink\" title=\"创建github账号：\"></a>创建github账号：</h2><p>在Github上创建一个账户。如果您已经拥有一个账户，可以跳过此步骤。</p>\n<h2 id=\"创建代码仓库：\"><a href=\"#创建代码仓库：\" class=\"headerlink\" title=\"创建代码仓库：\"></a>创建代码仓库：</h2><p>在Github上创建一个代码仓库。在Github主页面上，右上角有一个“New Repository”按钮，点击该按钮，输入仓库名称和描述信息，选择公共还是私有仓库（如果您没有选购Github的付费方案，则私有仓库是需要付费的）。在确认信息无误后，点击“Create Repository”按钮即可。</p>\n<h2 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h2><p>在本地电脑上安装Git。如果您已经安装了Git，可以跳过此步骤。</p>\n<h2 id=\"创建和配置密钥\"><a href=\"#创建和配置密钥\" class=\"headerlink\" title=\"创建和配置密钥\"></a>创建和配置密钥</h2><p>要在 Git 中创建密钥，请按照以下步骤进行操作：</p>\n<h3 id=\"1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\"><a href=\"#1-打开终端或命令提示符，输入以下命令来生成-SSH-密钥：\" class=\"headerlink\" title=\"1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：\"></a>1.打开终端或命令提示符，输入以下命令来生成 SSH 密钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email&quot;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-按回车键接受默认的文件名和位置。\"><a href=\"#2-按回车键接受默认的文件名和位置。\" class=\"headerlink\" title=\"2.按回车键接受默认的文件名和位置。\"></a>2.按回车键接受默认的文件名和位置。</h3><h3 id=\"3-输入你的密码短语（如果需要）。\"><a href=\"#3-输入你的密码短语（如果需要）。\" class=\"headerlink\" title=\"3.输入你的密码短语（如果需要）。\"></a>3.输入你的密码短语（如果需要）。</h3><h3 id=\"4-确认密码短语。\"><a href=\"#4-确认密码短语。\" class=\"headerlink\" title=\"4.确认密码短语。\"></a>4.确认密码短语。</h3><h3 id=\"5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"><a href=\"#5-你的-SSH-密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\" class=\"headerlink\" title=\"5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：\"></a>5.你的 SSH 密钥现在已经生成。在终端中，输入以下命令来查看你的公钥：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-复制你的公钥。\"><a href=\"#6-复制你的公钥。\" class=\"headerlink\" title=\"6.复制你的公钥。\"></a>6.复制你的公钥。</h3><h3 id=\"7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\"><a href=\"#7-在-Git-托管服务（如-GitHub、GitLab、Bitbucket-等）的网站上，导航到你的账户设置页面，找到-SSH-密钥设置选项。\" class=\"headerlink\" title=\"7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。\"></a>7.在 Git 托管服务（如 GitHub、GitLab、Bitbucket 等）的网站上，导航到你的账户设置页面，找到 SSH 密钥设置选项。</h3><h3 id=\"8-点击-“Add-SSH-key”（或类似的按钮）。\"><a href=\"#8-点击-“Add-SSH-key”（或类似的按钮）。\" class=\"headerlink\" title=\"8.点击 “Add SSH key”（或类似的按钮）。\"></a>8.点击 “Add SSH key”（或类似的按钮）。</h3><h3 id=\"9-将你的公钥粘贴到-“Key”-字段中。\"><a href=\"#9-将你的公钥粘贴到-“Key”-字段中。\" class=\"headerlink\" title=\"9.将你的公钥粘贴到 “Key” 字段中。\"></a>9.将你的公钥粘贴到 “Key” 字段中。</h3><h3 id=\"10-输入一个描述性的标题以标识此密钥。\"><a href=\"#10-输入一个描述性的标题以标识此密钥。\" class=\"headerlink\" title=\"10.输入一个描述性的标题以标识此密钥。\"></a>10.输入一个描述性的标题以标识此密钥。</h3><h3 id=\"11-点击-“Add-key”（或类似的按钮）。\"><a href=\"#11-点击-“Add-key”（或类似的按钮）。\" class=\"headerlink\" title=\"11.点击 “Add key”（或类似的按钮）。\"></a>11.点击 “Add key”（或类似的按钮）。</h3><p>现在，你已经成功地将 SSH 密钥添加到你的 Git 托管服务中。现在，你可以使用 SSH 协议来与 Git 托管服务进行通信，而不需要每次都输入用户名和密码。</p>\n<h2 id=\"创建本地代码仓库：\"><a href=\"#创建本地代码仓库：\" class=\"headerlink\" title=\"创建本地代码仓库：\"></a>创建本地代码仓库：</h2><p>在本地电脑上创建一个本地代码仓库。使用您喜欢的文件管理器，在您希望保存代码的位置创建一个新的文件夹。然后在终端中进入该文件夹，并执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>这将在该文件夹中创建一个新的Git仓库。</p>\n<h2 id=\"添加文件到本地代码仓库（更新）：\"><a href=\"#添加文件到本地代码仓库（更新）：\" class=\"headerlink\" title=\"*添加文件到本地代码仓库（更新）：\"></a>*添加文件到本地代码仓库（更新）：</h2><p>将新文件添加到本地代码仓库中。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>这将把hello-world.py文件添加到Git的暂存区。</p>\n<h2 id=\"提交（更新）：\"><a href=\"#提交（更新）：\" class=\"headerlink\" title=\"*提交（更新）：\"></a>*提交（更新）：</h2><p>提交更改描述。在终端中，执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;Initial commit&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这将提交文件更改，并把提交描述设置为“Initial commit”。</p>\n<h2 id=\"建立本地仓库和github仓库的关联：\"><a href=\"#建立本地仓库和github仓库的关联：\" class=\"headerlink\" title=\"建立本地仓库和github仓库的关联：\"></a>建立本地仓库和github仓库的关联：</h2><p>在Github仓库页面上，复制仓库的URL地址。然后在终端中执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin [仓库的URL地址]</span><br></pre></td></tr></table></figure>\n\n<p>这将将您的本地仓库与Github仓库关联起来。</p>\n<h2 id=\"推送代码到github仓库（更新）：\"><a href=\"#推送代码到github仓库（更新）：\" class=\"headerlink\" title=\"*推送代码到github仓库（更新）：\"></a>*推送代码到github仓库（更新）：</h2><p>推送您的代码到Github仓库。执行以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master</span><br></pre></td></tr></table></figure>\n\n<p>这将推送您的代码到Github仓库。如果您有多个分支，则将“master”替换为您要推送的分支名称。</p>\n<p>完成上述步骤后，您的代码将被提交到Github仓库。如果您打开Github仓库页面，您将看到刚刚提交的代码。在以后的工作中，您可以迭代地修改代码，并将更改推送到Github仓库上。</p>\n"},{"title":"JAVA之用Stream流将List转化为Map","date":"2019-02-01T04:50:18.000Z","top_img":"/img/java_stream.jpg","cover":"/img/java_stream.jpg","keywords":"Stream流","description":"JAVA之用Stream流将List转化为Map的方式","post_meta":{"page":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true},"post":{"date_type":"both","date_format":"relative","categories":true,"tags":true,"label":true}},"_content":"# 1、**JDK1.8流方式**\n**用户类**\n```\nimport lombok.Data;\n\n@Data\npublic class User {\n\n    private String id;\n    private String name;\n\n    public User(String id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n## 1. **收集成key为id，value为name：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, String> collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));\n\n        for (Map.Entry<String, String> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-1.png)\n\n\n## **2. 收集成实体本身**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getId, user -> user));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-2.png)\n\nuser -> user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：\n```\nMap<String, User> collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n```\n\n**重复key的情况：**\n代码如下：\n```\nMap<String, User> collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());\n```\n这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。\n![图片](/img/java-stream-3.png)\n\n**toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-4.png)\n\n**这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, List<User>> collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));\n\n        for (Map.Entry<String, List<User>> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-5.png)\n\n## **3. 指定具体收集的map**\ntoMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2, LinkedHashMap::new));\n\n        for (Map.Entry<String, User> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-6.png)\n\n","source":"_posts/JAVA之用Stream流将List转化为Map.md","raw":"---\ntitle: JAVA之用Stream流将List转化为Map\ndate: 2019-02-01 12:50:18\ntags:\n- Stream流\n- JDK 1.8\n- List转化为Map\ncategories:\n- Stream流\n- List转化为Map\ntop_img: /img/java_stream.jpg\ncover: /img/java_stream.jpg\nkeywords: \"Stream流\"\ndescription: \"JAVA之用Stream流将List转化为Map的方式\"\npost_meta:\n  page:\n    date_type: both\n    date_format: relative\n    categories: true\n    tags: true\n    label: true\n  post:\n    date_type: both \n    date_format: relative\n    categories: true \n    tags: true\n    label: true\n---\n# 1、**JDK1.8流方式**\n**用户类**\n```\nimport lombok.Data;\n\n@Data\npublic class User {\n\n    private String id;\n    private String name;\n\n    public User(String id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```\n\n## 1. **收集成key为id，value为name：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, String> collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));\n\n        for (Map.Entry<String, String> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-1.png)\n\n\n## **2. 收集成实体本身**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name1\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getId, user -> user));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-2.png)\n\nuser -> user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：\n```\nMap<String, User> collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));\n```\n\n**重复key的情况：**\n代码如下：\n```\nMap<String, User> collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());\n```\n这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。\n![图片](/img/java-stream-3.png)\n\n**toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2));\n\n        for (Map.Entry<String, User> next : collect.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-4.png)\n\n**这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：**\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, List<User>> collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));\n\n        for (Map.Entry<String, List<User>> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-5.png)\n\n## **3. 指定具体收集的map**\ntoMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：\n```\n        List<User> userList = new ArrayList<>();\n        User user1 = new User(\"1\", \"name2\");\n        User user2 = new User(\"2\", \"name2\");\n        User user3 = new User(\"3\", \"name3\");\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        Map<String, User> collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -> key2, LinkedHashMap::new));\n\n        for (Map.Entry<String, User> next : collect3.entrySet()) {\n            System.out.println(\"key: \" + next.getKey() + \" , \" + \"value: \" + next.getValue());\n        }\n```\n![图片](/img/java-stream-6.png)\n\n","slug":"JAVA之用Stream流将List转化为Map","published":1,"updated":"2023-09-01T17:02:50.289Z","_id":"clm0u10we0000ogth20ed63wz","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1、JDK1-8流方式\"><a href=\"#1、JDK1-8流方式\" class=\"headerlink\" title=\"1、JDK1.8流方式\"></a>1、<strong>JDK1.8流方式</strong></h1><p><strong>用户类</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class User &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User(String id, String name) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-收集成key为id，value为name：\"><a href=\"#1-收集成key为id，value为name：\" class=\"headerlink\" title=\"1. 收集成key为id，value为name：\"></a>1. <strong>收集成key为id，value为name：</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, String&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, String&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-1.png\" alt=\"图片\"></p>\n<h2 id=\"2-收集成实体本身\"><a href=\"#2-收集成实体本身\" class=\"headerlink\" title=\"2. 收集成实体本身\"></a><strong>2. 收集成实体本身</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, user -&gt; user));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-2.png\" alt=\"图片\"></p>\n<p>user -&gt; user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br></pre></td></tr></table></figure>\n\n<p><strong>重复key的情况：</strong><br>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());</span><br></pre></td></tr></table></figure>\n<p>这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。<br><img src=\"/img/java-stream-3.png\" alt=\"图片\"></p>\n<p><strong>toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-4.png\" alt=\"图片\"></p>\n<p><strong>这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, List&lt;User&gt;&gt; collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, List&lt;User&gt;&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-5.png\" alt=\"图片\"></p>\n<h2 id=\"3-指定具体收集的map\"><a href=\"#3-指定具体收集的map\" class=\"headerlink\" title=\"3. 指定具体收集的map\"></a><strong>3. 指定具体收集的map</strong></h2><p>toMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2, LinkedHashMap::new));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-6.png\" alt=\"图片\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"值得推荐的网站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"视频网站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中国最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover_type":"img","excerpt":"","more":"<h1 id=\"1、JDK1-8流方式\"><a href=\"#1、JDK1-8流方式\" class=\"headerlink\" title=\"1、JDK1.8流方式\"></a>1、<strong>JDK1.8流方式</strong></h1><p><strong>用户类</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import lombok.Data;</span><br><span class=\"line\"></span><br><span class=\"line\">@Data</span><br><span class=\"line\">public class User &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private String id;</span><br><span class=\"line\">    private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User(String id, String name) &#123;</span><br><span class=\"line\">        this.id = id;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-收集成key为id，value为name：\"><a href=\"#1-收集成key为id，value为name：\" class=\"headerlink\" title=\"1. 收集成key为id，value为name：\"></a>1. <strong>收集成key为id，value为name：</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, String&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, String&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-1.png\" alt=\"图片\"></p>\n<h2 id=\"2-收集成实体本身\"><a href=\"#2-收集成实体本身\" class=\"headerlink\" title=\"2. 收集成实体本身\"></a><strong>2. 收集成实体本身</strong></h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name1&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getId, user -&gt; user));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-2.png\" alt=\"图片\"></p>\n<p>user -&gt; user是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect1 = userList.stream().collect(Collectors.toMap(User::getId, Function.identity()));</span><br></pre></td></tr></table></figure>\n\n<p><strong>重复key的情况：</strong><br>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, User&gt; collect2 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity());</span><br></pre></td></tr></table></figure>\n<p>这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。<br><img src=\"/img/java-stream-3.png\" alt=\"图片\"></p>\n<p><strong>toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-4.png\" alt=\"图片\"></p>\n<p><strong>这里只是简单的使用后者覆盖前者来解决key重复问题。还有一种分组的方法：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, List&lt;User&gt;&gt; collect3 = userList.stream().collect(Collectors.groupingBy(User::getName));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, List&lt;User&gt;&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-5.png\" alt=\"图片\"></p>\n<h2 id=\"3-指定具体收集的map\"><a href=\"#3-指定具体收集的map\" class=\"headerlink\" title=\"3. 指定具体收集的map\"></a><strong>3. 指定具体收集的map</strong></h2><p>toMap还有另一个重载方法，可以指定一个Map的具体实现，来收集数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">User user1 = new User(&quot;1&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user2 = new User(&quot;2&quot;, &quot;name2&quot;);</span><br><span class=\"line\">User user3 = new User(&quot;3&quot;, &quot;name3&quot;);</span><br><span class=\"line\">userList.add(user1);</span><br><span class=\"line\">userList.add(user2);</span><br><span class=\"line\">userList.add(user3);</span><br><span class=\"line\"></span><br><span class=\"line\">Map&lt;String, User&gt; collect3 = userList.stream().collect(Collectors.toMap(User::getName, Function.identity(), (key1, key2) -&gt; key2, LinkedHashMap::new));</span><br><span class=\"line\"></span><br><span class=\"line\">for (Map.Entry&lt;String, User&gt; next : collect3.entrySet()) &#123;</span><br><span class=\"line\">    System.out.println(&quot;key: &quot; + next.getKey() + &quot; , &quot; + &quot;value: &quot; + next.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/java-stream-6.png\" alt=\"图片\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clm0l2iab0003g4thb3cqe7qu","category_id":"clm0l2iae0004g4thfpvo52m7","_id":"clm0l2iah000cg4th06tj48ez"},{"post_id":"clm0l2iab0003g4thb3cqe7qu","category_id":"clm0l2iag0007g4thhzmt3dnb","_id":"clm0l2iai000eg4th8p1s9few"},{"post_id":"clm0l2iab0003g4thb3cqe7qu","category_id":"clm0l2iah0009g4th64wh4spg","_id":"clm0l2iai000gg4thg0dzh29p"},{"post_id":"clm0tbkoc0000ssth1y0b7c7i","category_id":"clm0tbkoh0001ssth3cjz74og","_id":"clm0tbkok0007ssthcskx2mzy"},{"post_id":"clm0tbkoc0000ssth1y0b7c7i","category_id":"clm0tbkoj0004ssthc4qydvsl","_id":"clm0tbkok0008ssth8cphg4xh"},{"post_id":"clm0u10we0000ogth20ed63wz","category_id":"clm0u10wj0001ogth954e30ef","_id":"clm0u10wm0006ogth4kop1emz"},{"post_id":"clm0u10we0000ogth20ed63wz","category_id":"clm0u10wl0004ogthfwjq0lvg","_id":"clm0u10wm0008ogthf1v2cumu"}],"PostTag":[{"post_id":"clm0l2iab0003g4thb3cqe7qu","tag_id":"clm0l2iaf0005g4th2amccwz7","_id":"clm0l2iah000bg4thexje3bjd"},{"post_id":"clm0l2iab0003g4thb3cqe7qu","tag_id":"clm0l2iag0006g4th1w4obffg","_id":"clm0l2iai000dg4thfzu7aibw"},{"post_id":"clm0l2iab0003g4thb3cqe7qu","tag_id":"clm0l2iag0008g4th9gwv9s4j","_id":"clm0l2iai000fg4th3qmrdsry"},{"post_id":"clm0l2iab0003g4thb3cqe7qu","tag_id":"clm0l2iah000ag4th7n4w6519","_id":"clm0l2iai000hg4thfce34hs7"},{"post_id":"clm0tbkoc0000ssth1y0b7c7i","tag_id":"clm0tbkoi0002ssth5mbl2ofj","_id":"clm0tbkol0009ssth7abj6qr8"},{"post_id":"clm0tbkoc0000ssth1y0b7c7i","tag_id":"clm0tbkoj0003ssth8mxne44n","_id":"clm0tbkol000assthb71e3tmr"},{"post_id":"clm0tbkoc0000ssth1y0b7c7i","tag_id":"clm0tbkok0005ssthbs18ggl7","_id":"clm0tbkol000bssthfwy0dsn5"},{"post_id":"clm0tbkoc0000ssth1y0b7c7i","tag_id":"clm0tbkok0006ssth5a0eaibu","_id":"clm0tbkol000cssth6q9bg5te"},{"post_id":"clm0u10we0000ogth20ed63wz","tag_id":"clm0u10wk0002ogth69ih42t0","_id":"clm0u10wm0007ogthgboja8mb"},{"post_id":"clm0u10we0000ogth20ed63wz","tag_id":"clm0u10wl0003ogthf5ek3ef6","_id":"clm0u10wm0009ogth1is20q19"},{"post_id":"clm0u10we0000ogth20ed63wz","tag_id":"clm0u10wl0005ogthgws9ano9","_id":"clm0u10wm000aogth7tzj1qj3"}],"Tag":[{"name":"算法","_id":"clm0l2iaf0005g4th2amccwz7"},{"name":"动态规划","_id":"clm0l2iag0006g4th1w4obffg"},{"name":"贪心算法","_id":"clm0l2iag0008g4th9gwv9s4j"},{"name":"回溯算法","_id":"clm0l2iah000ag4th7n4w6519"},{"name":"github仓库","_id":"clm0tbkoi0002ssth5mbl2ofj"},{"name":"github","_id":"clm0tbkoj0003ssth8mxne44n"},{"name":"git","_id":"clm0tbkok0005ssthbs18ggl7"},{"name":"本地代码","_id":"clm0tbkok0006ssth5a0eaibu"},{"name":"Stream流","_id":"clm0u10wk0002ogth69ih42t0"},{"name":"JDK 1.8","_id":"clm0u10wl0003ogthf5ek3ef6"},{"name":"List转化为Map","_id":"clm0u10wl0005ogthgws9ano9"}]}}